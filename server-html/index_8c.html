<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>My Project: seafile/common/index/index.c File Reference</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />

<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>

</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">My Project
   
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.6.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>File&#160;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#define-members">Defines</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">seafile/common/index/index.c File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &quot;common.h&quot;</code><br/>
<code>#include &quot;utils.h&quot;</code><br/>
<code>#include &quot;<a class="el" href="index_8h_source.html">index.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="seafile-crypt_8h_source.html">../seafile-crypt.h</a>&quot;</code><br/>
<code>#include &lt;glib.h&gt;</code><br/>
<code>#include &lt;glib/gstdio.h&gt;</code><br/>
<code>#include &lt;openssl/sha.h&gt;</code><br/>
</div>
<p><a href="index_8c_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structWriteIndexInfo.html">WriteIndexInfo</a></td></tr>
<tr><td colspan="2"><h2><a name="define-members"></a>
Defines</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="index_8c.html#a998e2b1c5e9dbbf8ddc6b489ceb8d69a">NO_THE_INDEX_COMPATIBILITY_MACROS</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="index_8c.html#a6242a25f9d996f0cc4f4cdb911218b75">ARRAY_SIZE</a>(x)&#160;&#160;&#160;(sizeof(x)/sizeof(x[0]))</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="index_8c.html#a00b82f1418e7fe22a934b5867ad43279">SMALL_FILE_SIZE</a>&#160;&#160;&#160;(32*1024)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="index_8c.html#a45b6ee479d2daaf80ef51ad238c65c0d">WRITE_BUFFER_SIZE</a>&#160;&#160;&#160;8192</td></tr>
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="index_8c.html#a0f9de2761514c9136fb4b9c5541ef6f8">read_index_from</a> (struct <a class="el" href="structindex__state.html">index_state</a> *istate, const char *path, int repo_version)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="index_8c.html#a9527d61c2cbd37e4f1691dfc0f543a5d">is_index_unborn</a> (struct <a class="el" href="structindex__state.html">index_state</a> *istate)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="index_8c.html#a177df5d9afa8392326c1a1cef68f08c0">unmerged_index</a> (const struct <a class="el" href="structindex__state.html">index_state</a> *istate)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="index_8c.html#a36a1039c7b0e5005a36afc70220630e4">cache_name_compare</a> (const char *name1, int flags1, const char *name2, int <a class="el" href="index_8h.html#a6ca8a533250260e3d223c57328e61203">flags2</a>)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="index_8c.html#a8225ef1fb93e6538cc4c632928516314">fill_stat_cache_info</a> (struct <a class="el" href="structcache__entry.html">cache_entry</a> *ce, <a class="el" href="seafile_2lib_2utils_8h.html#a5b073bcbe1516b249924c3702002d32c">SeafStat</a> *st)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="index_8c.html#a1bcae1e686ad516d8b562a214c9e2cd8">mark_all_ce_unused</a> (struct <a class="el" href="structindex__state.html">index_state</a> *index)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="index_8c.html#a2a76921da1fbb55b7b33983ca9e8edc4">ie_match_stat</a> (struct <a class="el" href="structcache__entry.html">cache_entry</a> *ce, <a class="el" href="seafile_2lib_2utils_8h.html#a5b073bcbe1516b249924c3702002d32c">SeafStat</a> *st, unsigned int <a class="el" href="structoptions.html">options</a>)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="index_8c.html#a8a3589fc007481a8224103522e189254">df_name_compare</a> (const char *name1, int len1, int mode1, const char *name2, int len2, int mode2)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="index_8c.html#a1f5ad45bcfb5a2dcc3fae542fa293d4a">index_name_pos</a> (const struct <a class="el" href="structindex__state.html">index_state</a> *istate, const char *<a class="el" href="index_8h.html#a2a7f851274ec18e17d38114c39b8511a">name</a>, int namelen)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="index_8c.html#aae99b184a9d6c213a39042b5452081f9">remove_index_entry_at</a> (struct <a class="el" href="structindex__state.html">index_state</a> *istate, int pos)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="index_8c.html#a12825d79310dd67cd238e49161be5bfd">remove_marked_cache_entries</a> (struct <a class="el" href="structindex__state.html">index_state</a> *istate)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="index_8c.html#ac131057c151521f1cff71bf1510ef050">remove_file_from_index</a> (struct <a class="el" href="structindex__state.html">index_state</a> *istate, const char *path)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="index_8c.html#a72b1cce809dbffd745f5cba8e28ddbc5">ce_same_name</a> (struct <a class="el" href="structcache__entry.html">cache_entry</a> *a, struct <a class="el" href="structcache__entry.html">cache_entry</a> *b)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="index_8c.html#ab890017e37e01d5c50db73c40e72c24d">ce_path_match</a> (const struct <a class="el" href="structcache__entry.html">cache_entry</a> *ce, const char **pathspec)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="index_8c.html#a255f3c14715b9792f50ca3b2b600e91c">verify_path</a> (const char *path)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="index_8c.html#a21d6b0245750631144db52218a179633">remove_empty_parent_dir_entry</a> (struct <a class="el" href="structindex__state.html">index_state</a> *istate, const char *path)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="index_8c.html#afafdfbe15ca205599303d6e2230886c0">add_index_entry</a> (struct <a class="el" href="structindex__state.html">index_state</a> *istate, struct <a class="el" href="structcache__entry.html">cache_entry</a> *ce, int option)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="index_8c.html#ac412654516da827612dd5db31703b32c">add_to_index</a> (const char *repo_id, int <a class="el" href="block-tx-utils_8h.html#a1abe2c64ac9f8bc05bbb1719cad360f3">version</a>, struct <a class="el" href="structindex__state.html">index_state</a> *istate, const char *path, const char *full_path, <a class="el" href="seafile_2lib_2utils_8h.html#a5b073bcbe1516b249924c3702002d32c">SeafStat</a> *st, int <a class="el" href="index_8h.html#a1cbb17ede73ea044a04a129bf4d86976">flags</a>, <a class="el" href="structSeafileCrypt.html">SeafileCrypt</a> *crypt, <a class="el" href="index_8h.html#ad3590c8e6928357777aec72d944c748d">IndexCB</a> index_cb, const char *modifier, gboolean *added)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="index_8c.html#a0a287241a624545389a63a0b22a98513">add_empty_dir_to_index</a> (struct <a class="el" href="structindex__state.html">index_state</a> *istate, const char *path, <a class="el" href="seafile_2lib_2utils_8h.html#a5b073bcbe1516b249924c3702002d32c">SeafStat</a> *st)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="index_8c.html#a86bf1084dfc4e0057a52b4da1922de9b">remove_from_index_with_prefix</a> (struct <a class="el" href="structindex__state.html">index_state</a> *istate, const char *path_prefix, gboolean *not_found)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="index_8c.html#a56d1945a0677d925b25c610d613aeefc">rename_index_entries</a> (struct <a class="el" href="structindex__state.html">index_state</a> *istate, const char *src_path, const char *dst_path, gboolean *not_found)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="index_8c.html#ac3edae475009ceeec48b372556153c70">add_empty_dir_to_index_with_check</a> (struct <a class="el" href="structindex__state.html">index_state</a> *istate, const char *path, <a class="el" href="seafile_2lib_2utils_8h.html#a5b073bcbe1516b249924c3702002d32c">SeafStat</a> *st)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structcache__entry.html">cache_entry</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="index_8c.html#ac1791afc7341bbfdee313b82eb250c2c">make_cache_entry</a> (unsigned int <a class="el" href="index_8h.html#ac1b4d694fc07a39e06900e82872aac7f">mode</a>, const unsigned char *<a class="el" href="test-seafile-fmt_8c.html#a0f4af80189728258cd27679dee8ab2dc">sha1</a>, const char *path, const char *full_path, int stage, int refresh)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="index_8c.html#a37ae9831253a5201f6d773a14e1da9ac">index_fd</a> (unsigned char *<a class="el" href="test-seafile-fmt_8c.html#a0f4af80189728258cd27679dee8ab2dc">sha1</a>, int fd, <a class="el" href="seafile_2lib_2utils_8h.html#a5b073bcbe1516b249924c3702002d32c">SeafStat</a> *st, enum <a class="el" href="index_8h.html#af54461b7c3322b2256322f7b545bd623">object_type</a> <a class="el" href="fs-mgr_8c.html#a65cfc9e13d3352fd9099a0408cba715c">type</a>, const char *path)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="index_8c.html#a35caece3e3575d32521f820a8f0a24a7">index_path</a> (unsigned char *<a class="el" href="test-seafile-fmt_8c.html#a0f4af80189728258cd27679dee8ab2dc">sha1</a>, const char *path, <a class="el" href="seafile_2lib_2utils_8h.html#a5b073bcbe1516b249924c3702002d32c">SeafStat</a> *st)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="index_8c.html#a00594b344a866bd98aa1dad7d4a7b434">write_index</a> (struct <a class="el" href="structindex__state.html">index_state</a> *istate, int newfd)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="index_8c.html#a835affdb8e7226b619f5cbf69a36db1f">discard_index</a> (struct <a class="el" href="structindex__state.html">index_state</a> *istate)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="index_8c.html#a156a4ea461fcf14e0b73755b02e7e7d1">cache_entry_free</a> (struct <a class="el" href="structcache__entry.html">cache_entry</a> *ce)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="index_8c.html#a62df0f7f37866aabf0b0faf196fc0ddf">remove_name_hash</a> (struct <a class="el" href="structindex__state.html">index_state</a> *istate, struct <a class="el" href="structcache__entry.html">cache_entry</a> *ce)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="index_8c.html#a6807b08fb7e98733bcdc6b4207993524">add_name_hash</a> (struct <a class="el" href="structindex__state.html">index_state</a> *istate, struct <a class="el" href="structcache__entry.html">cache_entry</a> *ce)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structcache__entry.html">cache_entry</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="index_8c.html#a3931a94c55aad8bf8267f179ae846711">index_name_exists</a> (struct <a class="el" href="structindex__state.html">index_state</a> *istate, const char *<a class="el" href="index_8h.html#a2a7f851274ec18e17d38114c39b8511a">name</a>, int namelen, int igncase)</td></tr>
</table>
<hr/><h2>Define Documentation</h2>
<a class="anchor" id="a6242a25f9d996f0cc4f4cdb911218b75"></a><!-- doxytag: member="index.c::ARRAY_SIZE" ref="a6242a25f9d996f0cc4f4cdb911218b75" args="(x)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define <a class="el" href="index_8c.html#a6242a25f9d996f0cc4f4cdb911218b75">ARRAY_SIZE</a></td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">x</td><td>)</td>
          <td>&#160;&#160;&#160;(sizeof(x)/sizeof(x[0]))</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="index_8c_source.html#l01561">1561</a> of file <a class="el" href="index_8c_source.html">index.c</a>.</p>

</div>
</div>
<a class="anchor" id="a998e2b1c5e9dbbf8ddc6b489ceb8d69a"></a><!-- doxytag: member="index.c::NO_THE_INDEX_COMPATIBILITY_MACROS" ref="a998e2b1c5e9dbbf8ddc6b489ceb8d69a" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define <a class="el" href="name-hash_8c.html#a998e2b1c5e9dbbf8ddc6b489ceb8d69a">NO_THE_INDEX_COMPATIBILITY_MACROS</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="index_8c_source.html#l00007">7</a> of file <a class="el" href="index_8c_source.html">index.c</a>.</p>

</div>
</div>
<a class="anchor" id="a00b82f1418e7fe22a934b5867ad43279"></a><!-- doxytag: member="index.c::SMALL_FILE_SIZE" ref="a00b82f1418e7fe22a934b5867ad43279" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define <a class="el" href="index_8c.html#a00b82f1418e7fe22a934b5867ad43279">SMALL_FILE_SIZE</a>&#160;&#160;&#160;(32*1024)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="index_8c_source.html#l01612">1612</a> of file <a class="el" href="index_8c_source.html">index.c</a>.</p>

</div>
</div>
<a class="anchor" id="a45b6ee479d2daaf80ef51ad238c65c0d"></a><!-- doxytag: member="index.c::WRITE_BUFFER_SIZE" ref="a45b6ee479d2daaf80ef51ad238c65c0d" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define <a class="el" href="index_8c.html#a45b6ee479d2daaf80ef51ad238c65c0d">WRITE_BUFFER_SIZE</a>&#160;&#160;&#160;8192</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="index_8c_source.html#l01680">1680</a> of file <a class="el" href="index_8c_source.html">index.c</a>.</p>

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="a0a287241a624545389a63a0b22a98513"></a><!-- doxytag: member="index.c::add_empty_dir_to_index" ref="a0a287241a624545389a63a0b22a98513" args="(struct index_state *istate, const char *path, SeafStat *st)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="index_8h.html#a0a287241a624545389a63a0b22a98513">add_empty_dir_to_index</a> </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structindex__state.html">index_state</a> *&#160;</td>
          <td class="paramname"><em>istate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="seafile_2lib_2utils_8h.html#a5b073bcbe1516b249924c3702002d32c">SeafStat</a> *&#160;</td>
          <td class="paramname"><em>st</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="index_8c_source.html#l01141">1141</a> of file <a class="el" href="index_8c_source.html">index.c</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="keyword">struct </span><a class="code" href="structcache__entry.html">cache_entry</a> *ce, *alias;
    <span class="keywordtype">int</span> add_option = (<a class="code" href="index_8h.html#a4e7659151088d67c163cc90e6f12c39c">ADD_CACHE_OK_TO_ADD</a>|<a class="code" href="index_8h.html#a6b5725eef5481c5f354df57bd32a4d87">ADD_CACHE_OK_TO_REPLACE</a>);

    ce = create_empty_dir_index_entry (path, st);

    <span class="keywordflow">if</span> (is_garbage_empty_dir (istate, ce)) {
        free (ce);
        <span class="keywordflow">return</span> 0;
    }

    alias = <a class="code" href="index_8c.html#a3931a94c55aad8bf8267f179ae846711">index_name_exists</a>(istate, ce-&gt;<a class="code" href="structcache__entry.html#a792e4ea24cb16c76abe3229651e414a0">name</a>, ce_namelen(ce), 0);
    <span class="keywordflow">if</span> (alias) {
        free (ce);
        <span class="keywordflow">return</span> 0;
    } <span class="keywordflow">else</span> {
<span class="preprocessor">#if defined WIN32 || defined __APPLE__</span>
<span class="preprocessor"></span>        alias = <a class="code" href="index_8c.html#a3931a94c55aad8bf8267f179ae846711">index_name_exists</a> (istate, ce-&gt;<a class="code" href="structcache__entry.html#a792e4ea24cb16c76abe3229651e414a0">name</a>, ce_namelen(ce), 1);
        <span class="comment">/* If file exists case-insensitively but doesn&#39;t exist case-sensitively,</span>
<span class="comment">         * that file is actually being renamed.</span>
<span class="comment">         */</span>
        <span class="keywordflow">if</span> (alias) {
            <a class="code" href="index_8c.html#ac131057c151521f1cff71bf1510ef050">remove_file_from_index</a> (istate, alias-&gt;<a class="code" href="structcache__entry.html#a792e4ea24cb16c76abe3229651e414a0">name</a>);
            alias = NULL;
        }
<span class="preprocessor">#endif</span>
<span class="preprocessor"></span>    }

    <span class="keywordflow">if</span> (<a class="code" href="index_8c.html#afafdfbe15ca205599303d6e2230886c0">add_index_entry</a>(istate, ce, add_option)) {
        g_warning(<span class="stringliteral">&quot;unable to add %s to index\n&quot;</span>,path);
        free (ce);
        <span class="keywordflow">return</span> -1;
    }

    <span class="keywordflow">return</span> 0;
}
</pre></div>
</div>
</div>
<a class="anchor" id="ac3edae475009ceeec48b372556153c70"></a><!-- doxytag: member="index.c::add_empty_dir_to_index_with_check" ref="ac3edae475009ceeec48b372556153c70" args="(struct index_state *istate, const char *path, SeafStat *st)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="index_8h.html#ac3edae475009ceeec48b372556153c70">add_empty_dir_to_index_with_check</a> </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structindex__state.html">index_state</a> *&#160;</td>
          <td class="paramname"><em>istate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="seafile_2lib_2utils_8h.html#a5b073bcbe1516b249924c3702002d32c">SeafStat</a> *&#160;</td>
          <td class="paramname"><em>st</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="index_8c_source.html#l01441">1441</a> of file <a class="el" href="index_8c_source.html">index.c</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="keywordtype">int</span> pathlen = strlen(path);
    <span class="keywordtype">int</span> pos = <a class="code" href="index_8c.html#a1f5ad45bcfb5a2dcc3fae542fa293d4a">index_name_pos</a> (istate, path, pathlen);
    <span class="keyword">struct </span><a class="code" href="structcache__entry.html">cache_entry</a> *ce;

    <span class="comment">/* Exact match, empty dir entry already exists. */</span>
    <span class="keywordflow">if</span> (pos &gt;= 0) {
        <span class="keywordflow">return</span> 0;
    }

    <span class="comment">/* Otherwise it may be a prefix match, remove all entries begin with this prefix.</span>
<span class="comment">     */</span>

    <span class="comment">/* -pos = (the position this entry *should* be) + 1.</span>
<span class="comment">     * So -pos-1 is the first entry larger than this entry.</span>
<span class="comment">     */</span>
    pos = -pos-1;

    <span class="comment">/* Add &#39;/&#39; to the end of prefix so that we won&#39;t match a partial path component.</span>
<span class="comment">     * e.g. we don&#39;t want to match &#39;abc&#39; with &#39;abcd/ef&#39;</span>
<span class="comment">     */</span>
    <span class="keywordtype">char</span> *full_path = g_strconcat (path, <span class="stringliteral">&quot;/&quot;</span>, NULL);
    ++pathlen;

    gboolean is_empty = TRUE;

    <span class="keywordflow">while</span> (pos &lt; istate-&gt;cache_nr) {
        ce = istate-&gt;<a class="code" href="structindex__state.html#a8aa7a8aa984ec5a39ff2eee96412db07">cache</a>[pos];
        <span class="keywordtype">int</span> rc = strncmp (ce-&gt;<a class="code" href="structcache__entry.html#a792e4ea24cb16c76abe3229651e414a0">name</a>, full_path, pathlen);
        <span class="keywordflow">if</span> (rc &lt; 0) {
            ++pos;
        } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (rc == 0) {
            is_empty = FALSE;
            <span class="keywordflow">break</span>;
        } <span class="keywordflow">else</span>
            <span class="keywordflow">break</span>;
    }

    g_free (full_path);

    <span class="keywordflow">if</span> (is_empty) {
        ce = create_empty_dir_index_entry (path, st);

        <span class="comment">/* Make sure the array is big enough .. */</span>
        <span class="keywordflow">if</span> (istate-&gt;<a class="code" href="structindex__state.html#a15b38cdd30ad2374bc12da429f39312f">cache_nr</a> == istate-&gt;<a class="code" href="structindex__state.html#aa092fb08928f22bc28e892ba163d3103">cache_alloc</a>) {
            istate-&gt;<a class="code" href="structindex__state.html#aa092fb08928f22bc28e892ba163d3103">cache_alloc</a> = <a class="code" href="index_8h.html#a96824974fc1cbb6da7418f3ac5e4d57d">alloc_nr</a>(istate-&gt;<a class="code" href="structindex__state.html#aa092fb08928f22bc28e892ba163d3103">cache_alloc</a>);
            istate-&gt;<a class="code" href="structindex__state.html#a8aa7a8aa984ec5a39ff2eee96412db07">cache</a> = realloc(istate-&gt;<a class="code" href="structindex__state.html#a8aa7a8aa984ec5a39ff2eee96412db07">cache</a>,
                                    istate-&gt;<a class="code" href="structindex__state.html#aa092fb08928f22bc28e892ba163d3103">cache_alloc</a> * <span class="keyword">sizeof</span>(<span class="keyword">struct</span> <a class="code" href="structcache__entry.html">cache_entry</a> *));
        }

        <span class="comment">/* Add it in.. */</span>
        istate-&gt;<a class="code" href="structindex__state.html#a15b38cdd30ad2374bc12da429f39312f">cache_nr</a>++;
        <span class="keywordflow">if</span> (istate-&gt;<a class="code" href="structindex__state.html#a15b38cdd30ad2374bc12da429f39312f">cache_nr</a> &gt; pos + 1)
            memmove(istate-&gt;<a class="code" href="structindex__state.html#a8aa7a8aa984ec5a39ff2eee96412db07">cache</a> + pos + 1,
                    istate-&gt;<a class="code" href="structindex__state.html#a8aa7a8aa984ec5a39ff2eee96412db07">cache</a> + pos,
                    (istate-&gt;<a class="code" href="structindex__state.html#a15b38cdd30ad2374bc12da429f39312f">cache_nr</a> - pos - 1) * <span class="keyword">sizeof</span>(ce));
        set_index_entry(istate, pos, ce);
        istate-&gt;<a class="code" href="structindex__state.html#a8e22a9fe2486576488e72fe97801ebe5">cache_changed</a> = 1;
    }

    <span class="keywordflow">return</span> 0;
}
</pre></div>
</div>
</div>
<a class="anchor" id="afafdfbe15ca205599303d6e2230886c0"></a><!-- doxytag: member="index.c::add_index_entry" ref="afafdfbe15ca205599303d6e2230886c0" args="(struct index_state *istate, struct cache_entry *ce, int option)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="index_8h.html#a039d9ed6b4e6ece63bb1f4002ed6d16f">add_index_entry</a> </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structindex__state.html">index_state</a> *&#160;</td>
          <td class="paramname"><em>istate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structcache__entry.html">cache_entry</a> *&#160;</td>
          <td class="paramname"><em>ce</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>option</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="index_8c_source.html#l00942">942</a> of file <a class="el" href="index_8c_source.html">index.c</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="keywordtype">int</span> pos;

    <span class="keywordflow">if</span> (option &amp; <a class="code" href="index_8h.html#af3eef6db4672ee6e240c3eb4862f3b2a">ADD_CACHE_JUST_APPEND</a>)
        pos = istate-&gt;<a class="code" href="structindex__state.html#a15b38cdd30ad2374bc12da429f39312f">cache_nr</a>;
    <span class="keywordflow">else</span> {
        <span class="keywordtype">int</span> ret;
        ret = add_index_entry_with_check(istate, ce, option);
        <span class="keywordflow">if</span> (ret &lt;= 0)
            <span class="keywordflow">return</span> ret;
        pos = ret - 1;
    }

    <span class="comment">/* Make sure the array is big enough .. */</span>
    <span class="keywordflow">if</span> (istate-&gt;<a class="code" href="structindex__state.html#a15b38cdd30ad2374bc12da429f39312f">cache_nr</a> == istate-&gt;<a class="code" href="structindex__state.html#aa092fb08928f22bc28e892ba163d3103">cache_alloc</a>) {
        istate-&gt;<a class="code" href="structindex__state.html#aa092fb08928f22bc28e892ba163d3103">cache_alloc</a> = <a class="code" href="index_8h.html#a96824974fc1cbb6da7418f3ac5e4d57d">alloc_nr</a>(istate-&gt;<a class="code" href="structindex__state.html#aa092fb08928f22bc28e892ba163d3103">cache_alloc</a>);
        istate-&gt;<a class="code" href="structindex__state.html#a8aa7a8aa984ec5a39ff2eee96412db07">cache</a> = realloc(istate-&gt;<a class="code" href="structindex__state.html#a8aa7a8aa984ec5a39ff2eee96412db07">cache</a>,
                                istate-&gt;<a class="code" href="structindex__state.html#aa092fb08928f22bc28e892ba163d3103">cache_alloc</a> * <span class="keyword">sizeof</span>(<span class="keyword">struct</span> <a class="code" href="structcache__entry.html">cache_entry</a> *));
    }

    <span class="comment">/* Add it in.. */</span>
    istate-&gt;<a class="code" href="structindex__state.html#a15b38cdd30ad2374bc12da429f39312f">cache_nr</a>++;
    <span class="keywordflow">if</span> (istate-&gt;<a class="code" href="structindex__state.html#a15b38cdd30ad2374bc12da429f39312f">cache_nr</a> &gt; pos + 1)
        memmove(istate-&gt;<a class="code" href="structindex__state.html#a8aa7a8aa984ec5a39ff2eee96412db07">cache</a> + pos + 1,
                istate-&gt;<a class="code" href="structindex__state.html#a8aa7a8aa984ec5a39ff2eee96412db07">cache</a> + pos,
                (istate-&gt;<a class="code" href="structindex__state.html#a15b38cdd30ad2374bc12da429f39312f">cache_nr</a> - pos - 1) * <span class="keyword">sizeof</span>(ce));
    set_index_entry(istate, pos, ce);
    istate-&gt;<a class="code" href="structindex__state.html#a8e22a9fe2486576488e72fe97801ebe5">cache_changed</a> = 1;
    <span class="keywordflow">return</span> 0;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a6807b08fb7e98733bcdc6b4207993524"></a><!-- doxytag: member="index.c::add_name_hash" ref="a6807b08fb7e98733bcdc6b4207993524" args="(struct index_state *istate, struct cache_entry *ce)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="name-hash_8c.html#a6807b08fb7e98733bcdc6b4207993524">add_name_hash</a> </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structindex__state.html">index_state</a> *&#160;</td>
          <td class="paramname"><em>istate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structcache__entry.html">cache_entry</a> *&#160;</td>
          <td class="paramname"><em>ce</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="index_8c_source.html#l01989">1989</a> of file <a class="el" href="index_8c_source.html">index.c</a>.</p>
<div class="fragment"><pre class="fragment">{
    g_hash_table_insert (istate-&gt;<a class="code" href="structindex__state.html#ab30d2dde7a88b0d003ac7fc31952a376">name_hash</a>, g_strdup(ce-&gt;<a class="code" href="structcache__entry.html#a792e4ea24cb16c76abe3229651e414a0">name</a>), ce);
<span class="preprocessor">#if defined WIN32 || defined __APPLE__</span>
<span class="preprocessor"></span>    g_hash_table_insert (istate-&gt;i_name_hash, g_utf8_strdown(ce-&gt;<a class="code" href="structcache__entry.html#a792e4ea24cb16c76abe3229651e414a0">name</a>, -1), ce);
<span class="preprocessor">#endif</span>
<span class="preprocessor"></span>}
</pre></div>
</div>
</div>
<a class="anchor" id="ac412654516da827612dd5db31703b32c"></a><!-- doxytag: member="index.c::add_to_index" ref="ac412654516da827612dd5db31703b32c" args="(const char *repo_id, int version, struct index_state *istate, const char *path, const char *full_path, SeafStat *st, int flags, SeafileCrypt *crypt, IndexCB index_cb, const char *modifier, gboolean *added)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="index_8h.html#a2988327a0a98dd3e8868b4b902d310bf">add_to_index</a> </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>repo_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>version</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structindex__state.html">index_state</a> *&#160;</td>
          <td class="paramname"><em>istate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>full_path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="seafile_2lib_2utils_8h.html#a5b073bcbe1516b249924c3702002d32c">SeafStat</a> *&#160;</td>
          <td class="paramname"><em>st</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSeafileCrypt.html">SeafileCrypt</a> *&#160;</td>
          <td class="paramname"><em>crypt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="index_8h.html#ad3590c8e6928357777aec72d944c748d">IndexCB</a>&#160;</td>
          <td class="paramname"><em>index_cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>modifier</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gboolean *&#160;</td>
          <td class="paramname"><em>added</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="index_8c_source.html#l00974">974</a> of file <a class="el" href="index_8c_source.html">index.c</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="keywordtype">int</span> <a class="code" href="index_8h.html#af931a8871310b4dad23f0f0b0f623560">size</a>, namelen;
    mode_t st_mode = st-&gt;st_mode;
    <span class="keyword">struct </span><a class="code" href="structcache__entry.html">cache_entry</a> *ce, *alias;
    <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> <a class="code" href="index_8h.html#a96e76167c968d38441e90ee0488ee4aa">sha1</a>[20];
    <span class="keywordtype">unsigned</span> ce_option = <a class="code" href="index_8h.html#a3ecb29f06d046b6a99ed2148f91ae0c3">CE_MATCH_IGNORE_VALID</a>|<a class="code" href="index_8h.html#abd49280eba10dafd6f24cc3a6eab6313">CE_MATCH_IGNORE_SKIP_WORKTREE</a>|<a class="code" href="index_8h.html#a68c76b444c1d81fe952b07ad9f0f5fb7">CE_MATCH_RACY_IS_DIRTY</a>;
    <span class="keywordtype">int</span> add_option = (<a class="code" href="index_8h.html#a4e7659151088d67c163cc90e6f12c39c">ADD_CACHE_OK_TO_ADD</a>|<a class="code" href="index_8h.html#a6b5725eef5481c5f354df57bd32a4d87">ADD_CACHE_OK_TO_REPLACE</a>);

    *added = FALSE;

    <span class="keywordflow">if</span> (!S_ISREG(st_mode) &amp;&amp; !S_ISLNK(st_mode) &amp;&amp; !S_ISDIR(st_mode)) {
        g_warning(<span class="stringliteral">&quot;%s: can only add regular files, symbolic links or git-directories\n&quot;</span>, path);
        <span class="keywordflow">return</span> -1;
    }

    namelen = strlen(path);
    <span class="comment">/* if (S_ISDIR(st_mode)) { */</span>
    <span class="comment">/*     while (namelen &amp;&amp; path[namelen-1] == &#39;/&#39;) */</span>
    <span class="comment">/*         namelen--; */</span>
    <span class="comment">/* } */</span>
    size = <a class="code" href="index_8h.html#a07a18158c879287d1606ceec992ba702">cache_entry_size</a>(namelen);
    ce = calloc(1, size);
    memcpy(ce-&gt;<a class="code" href="structcache__entry.html#a792e4ea24cb16c76abe3229651e414a0">name</a>, path, namelen);
    ce-&gt;<a class="code" href="structcache__entry.html#a4dab14fd813a1bb6b67352674ff4afb2">ce_flags</a> = namelen;
    <a class="code" href="index_8c.html#a8225ef1fb93e6538cc4c632928516314">fill_stat_cache_info</a>(ce, st);

    ce-&gt;<a class="code" href="structcache__entry.html#a5fcbcc4e7265ae8150f136380ed92c05">ce_mode</a> = create_ce_mode(st_mode);

    alias = <a class="code" href="index_8c.html#a3931a94c55aad8bf8267f179ae846711">index_name_exists</a>(istate, ce-&gt;<a class="code" href="structcache__entry.html#a792e4ea24cb16c76abe3229651e414a0">name</a>, ce_namelen(ce), 0);
    <span class="keywordflow">if</span> (alias) {
        <span class="keywordflow">if</span> (!<a class="code" href="index_8h.html#a0379c411a3dc56c2d5ac0b1fcce22ead">ce_stage</a>(alias) &amp;&amp; !<a class="code" href="index_8c.html#a2a76921da1fbb55b7b33983ca9e8edc4">ie_match_stat</a>(alias, st, ce_option)) {
            <span class="comment">/* Nothing changed, really */</span>
            free(ce);
            <span class="keywordflow">if</span> (!<a class="code" href="index_8h.html#a63e538171307b264dd11b7685c94b9ac">S_ISGITLINK</a>(alias-&gt;<a class="code" href="structcache__entry.html#a5fcbcc4e7265ae8150f136380ed92c05">ce_mode</a>))
                <a class="code" href="index_8h.html#af89192589f914101b8c8cea880ab350d">ce_mark_uptodate</a>(alias);
            alias-&gt;<a class="code" href="structcache__entry.html#a4dab14fd813a1bb6b67352674ff4afb2">ce_flags</a> |= <a class="code" href="index_8h.html#a586309b1feb22f9865dd8925c4a998b2">CE_ADDED</a>;
            <span class="keywordflow">return</span> 0;
        }
    } <span class="keywordflow">else</span> {
<span class="preprocessor">#if defined WIN32 || defined __APPLE__</span>
<span class="preprocessor"></span>        alias = <a class="code" href="index_8c.html#a3931a94c55aad8bf8267f179ae846711">index_name_exists</a> (istate, ce-&gt;<a class="code" href="structcache__entry.html#a792e4ea24cb16c76abe3229651e414a0">name</a>, ce_namelen(ce), 1);
        <span class="comment">/* If file exists case-insensitively but doesn&#39;t exist case-sensitively,</span>
<span class="comment">         * that file is actually being renamed.</span>
<span class="comment">         */</span>
        <span class="keywordflow">if</span> (alias) {
            <a class="code" href="index_8c.html#ac131057c151521f1cff71bf1510ef050">remove_file_from_index</a> (istate, alias-&gt;<a class="code" href="structcache__entry.html#a792e4ea24cb16c76abe3229651e414a0">name</a>);
            alias = NULL;
        }
<span class="preprocessor">#endif</span>
<span class="preprocessor"></span>    }

<span class="preprocessor">#ifdef WIN32</span>
<span class="preprocessor"></span>    <span class="comment">/* On Windows, no &#39;x&#39; bit in file mode.</span>
<span class="comment">     * To prevent overwriting &#39;x&#39; bit, we directly use existing ce mode. </span>
<span class="comment">     */</span>
    <span class="keywordflow">if</span> (alias)
        ce-&gt;<a class="code" href="structcache__entry.html#a5fcbcc4e7265ae8150f136380ed92c05">ce_mode</a> = alias-&gt;<a class="code" href="structcache__entry.html#a5fcbcc4e7265ae8150f136380ed92c05">ce_mode</a>;
<span class="preprocessor">#endif</span>
<span class="preprocessor"></span>
<span class="preprocessor">#ifdef WIN32</span>
<span class="preprocessor"></span>    <span class="comment">/* Fix daylight saving time bug on Windows.</span>
<span class="comment">     * See http://www.codeproject.com/Articles/1144/Beating-the-Daylight-Savings-Time-bug-and-getting</span>
<span class="comment">     * If ce and wt timestamp has a 1 hour gap, it may be affected by the bug.</span>
<span class="comment">     * We then compare the file&#39;s id with the id in ce. If they&#39;re the same,</span>
<span class="comment">     * we don&#39;t need to copy the blocks again. Only update the index.</span>
<span class="comment">     */</span>
    <span class="keywordflow">if</span> (alias &amp;&amp; !<a class="code" href="index_8h.html#a0379c411a3dc56c2d5ac0b1fcce22ead">ce_stage</a>(alias) &amp;&amp;
        (ABS(alias-&gt;<a class="code" href="structcache__entry.html#a1c66f1f4e7773a56010e7ec64bd38a95">ce_mtime</a>.<a class="code" href="structcache__time64.html#ae37877c7f3995f5a44a4a9fd7bb91d46">sec</a> - st-&gt;st_mtime) == 3600 ||
         ABS(alias-&gt;<a class="code" href="structcache__entry.html#a5258a9a9e2fc3bfcd4859049912b65e8">ce_ctime</a>.<a class="code" href="structcache__time64.html#ae37877c7f3995f5a44a4a9fd7bb91d46">sec</a> - st-&gt;st_ctime) == 3600)) {
        <span class="keywordflow">if</span> (index_cb (repo_id, <a class="code" href="block-tx-utils_8h.html#a1abe2c64ac9f8bc05bbb1719cad360f3">version</a>, full_path, sha1, crypt, FALSE) &lt; 0) {
            free (ce);
            <span class="keywordflow">return</span> 0;
        }
        <span class="keywordflow">if</span> (memcmp (alias-&gt;<a class="code" href="structcache__entry.html#a119ab5c5e9db495e6e5f8d301f01421c">sha1</a>, sha1, 20) == 0)
            <span class="keywordflow">goto</span> <a class="code" href="vc-utils_8c.html#ab93fff6b962d6fd7482c95d17c8bf6eb">update_index</a>;
    }
<span class="preprocessor">#endif</span>
<span class="preprocessor"></span>
    <span class="comment">/* Skip index file errors. */</span>
    <span class="keywordflow">if</span> (index_cb (repo_id, <a class="code" href="block-tx-utils_8h.html#a1abe2c64ac9f8bc05bbb1719cad360f3">version</a>, full_path, sha1, crypt, TRUE) &lt; 0) {
        free (ce);
        <span class="keywordflow">return</span> 0;
    }

<a class="code" href="vc-utils_8c.html#ab93fff6b962d6fd7482c95d17c8bf6eb">update_index</a>:
    memcpy (ce-&gt;<a class="code" href="structcache__entry.html#a119ab5c5e9db495e6e5f8d301f01421c">sha1</a>, sha1, 20);
    ce-&gt;<a class="code" href="structcache__entry.html#a4dab14fd813a1bb6b67352674ff4afb2">ce_flags</a> |= <a class="code" href="index_8h.html#a586309b1feb22f9865dd8925c4a998b2">CE_ADDED</a>;
    ce-&gt;<a class="code" href="structcache__entry.html#a786aa5bc6234542fe202023bcf721afd">modifier</a> = g_strdup(<a class="code" href="structcache__entry.html#a786aa5bc6234542fe202023bcf721afd">modifier</a>);

    <span class="keywordflow">if</span> (<a class="code" href="index_8c.html#afafdfbe15ca205599303d6e2230886c0">add_index_entry</a>(istate, ce, add_option)) {
        g_warning(<span class="stringliteral">&quot;unable to add %s to index\n&quot;</span>,path);
        <span class="keywordflow">return</span> -1;
    }

    *added = TRUE;
    <span class="keywordflow">return</span> 0;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a156a4ea461fcf14e0b73755b02e7e7d1"></a><!-- doxytag: member="index.c::cache_entry_free" ref="a156a4ea461fcf14e0b73755b02e7e7d1" args="(struct cache_entry *ce)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="index_8h.html#a156a4ea461fcf14e0b73755b02e7e7d1">cache_entry_free</a> </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structcache__entry.html">cache_entry</a> *&#160;</td>
          <td class="paramname"><em>ce</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="index_8c_source.html#l01972">1972</a> of file <a class="el" href="index_8c_source.html">index.c</a>.</p>
<div class="fragment"><pre class="fragment">{
    g_free (ce-&gt;<a class="code" href="structcache__entry.html#a786aa5bc6234542fe202023bcf721afd">modifier</a>);
    free (ce);
}
</pre></div>
</div>
</div>
<a class="anchor" id="a36a1039c7b0e5005a36afc70220630e4"></a><!-- doxytag: member="index.c::cache_name_compare" ref="a36a1039c7b0e5005a36afc70220630e4" args="(const char *name1, int flags1, const char *name2, int flags2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="index_8h.html#ab905f6df06b1e76ab15e4572afbd35b1">cache_name_compare</a> </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flags1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flags2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="index_8c_source.html#l00418">418</a> of file <a class="el" href="index_8c_source.html">index.c</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="keywordtype">int</span> len1 = flags1 &amp; <a class="code" href="index_8h.html#a92e847bc81d825658bd3ef392e2f6c3b">CE_NAMEMASK</a>;
    <span class="keywordtype">int</span> len2 = <a class="code" href="index_8h.html#a6ca8a533250260e3d223c57328e61203">flags2</a> &amp; <a class="code" href="index_8h.html#a92e847bc81d825658bd3ef392e2f6c3b">CE_NAMEMASK</a>;
    <span class="keywordtype">int</span> len = len1 &lt; len2 ? len1 : len2;
    <span class="keywordtype">int</span> cmp;

    cmp = memcmp(name1, name2, len);
    <span class="keywordflow">if</span> (cmp)
        <span class="keywordflow">return</span> cmp;
    <span class="keywordflow">if</span> (len1 &lt; len2)
        <span class="keywordflow">return</span> -1;
    <span class="keywordflow">if</span> (len1 &gt; len2)
        <span class="keywordflow">return</span> 1;

    <span class="comment">/* Compare stages  */</span>
    flags1 &amp;= <a class="code" href="index_8h.html#ae53d91d6dee84ef5e3793ab535ea01c0">CE_STAGEMASK</a>;
    <a class="code" href="index_8h.html#a6ca8a533250260e3d223c57328e61203">flags2</a> &amp;= <a class="code" href="index_8h.html#ae53d91d6dee84ef5e3793ab535ea01c0">CE_STAGEMASK</a>;

    <span class="keywordflow">if</span> (flags1 &lt; <a class="code" href="index_8h.html#a6ca8a533250260e3d223c57328e61203">flags2</a>)
        <span class="keywordflow">return</span> -1;
    <span class="keywordflow">if</span> (flags1 &gt; <a class="code" href="index_8h.html#a6ca8a533250260e3d223c57328e61203">flags2</a>)
        <span class="keywordflow">return</span> 1;
    <span class="keywordflow">return</span> 0;
}
</pre></div>
</div>
</div>
<a class="anchor" id="ab890017e37e01d5c50db73c40e72c24d"></a><!-- doxytag: member="index.c::ce_path_match" ref="ab890017e37e01d5c50db73c40e72c24d" args="(const struct cache_entry *ce, const char **pathspec)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="index_8h.html#ab890017e37e01d5c50db73c40e72c24d">ce_path_match</a> </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structcache__entry.html">cache_entry</a> *&#160;</td>
          <td class="paramname"><em>ce</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char **&#160;</td>
          <td class="paramname"><em>pathspec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="index_8c_source.html#l00780">780</a> of file <a class="el" href="index_8c_source.html">index.c</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="keyword">const</span> <span class="keywordtype">char</span> *match, *<a class="code" href="index_8h.html#a2a7f851274ec18e17d38114c39b8511a">name</a>;
    <span class="keywordtype">int</span> len;

    <span class="keywordflow">if</span> (!pathspec)
        <span class="keywordflow">return</span> 1;

    len = ce_namelen(ce);
    name = ce-&gt;<a class="code" href="structcache__entry.html#a792e4ea24cb16c76abe3229651e414a0">name</a>;
    <span class="keywordflow">while</span> ((match = *pathspec++) != NULL) {
        <span class="keywordtype">int</span> matchlen = strlen(match);
        <span class="keywordflow">if</span> (matchlen &gt; len)
            <span class="keywordflow">continue</span>;
        <span class="keywordflow">if</span> (memcmp(name, match, matchlen))
            <span class="keywordflow">continue</span>;
        <span class="keywordflow">if</span> (matchlen &amp;&amp; name[matchlen-1] == <span class="charliteral">&#39;/&#39;</span>)
            <span class="keywordflow">return</span> 1;
        <span class="keywordflow">if</span> (name[matchlen] == <span class="charliteral">&#39;/&#39;</span> || !name[matchlen])
            <span class="keywordflow">return</span> 1;
        <span class="keywordflow">if</span> (!matchlen)
            <span class="keywordflow">return</span> 1;
    }
    <span class="keywordflow">return</span> 0;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a72b1cce809dbffd745f5cba8e28ddbc5"></a><!-- doxytag: member="index.c::ce_same_name" ref="a72b1cce809dbffd745f5cba8e28ddbc5" args="(struct cache_entry *a, struct cache_entry *b)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="index_8h.html#a72b1cce809dbffd745f5cba8e28ddbc5">ce_same_name</a> </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structcache__entry.html">cache_entry</a> *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structcache__entry.html">cache_entry</a> *&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="index_8c_source.html#l00774">774</a> of file <a class="el" href="index_8c_source.html">index.c</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="keywordtype">int</span> len = ce_namelen(a);
    <span class="keywordflow">return</span> ce_namelen(b) == len &amp;&amp; !memcmp(a-&gt;<a class="code" href="structcache__entry.html#a792e4ea24cb16c76abe3229651e414a0">name</a>, b-&gt;<a class="code" href="structcache__entry.html#a792e4ea24cb16c76abe3229651e414a0">name</a>, len);
}
</pre></div>
</div>
</div>
<a class="anchor" id="a8a3589fc007481a8224103522e189254"></a><!-- doxytag: member="index.c::df_name_compare" ref="a8a3589fc007481a8224103522e189254" args="(const char *name1, int len1, int mode1, const char *name2, int len2, int mode2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="index_8h.html#a8a3589fc007481a8224103522e189254">df_name_compare</a> </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>len1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>mode1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>len2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>mode2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="index_8c_source.html#l00677">677</a> of file <a class="el" href="index_8c_source.html">index.c</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="keywordtype">int</span> len = len1 &lt; len2 ? len1 : len2, cmp;
    <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> c1, c2;

    cmp = memcmp(name1, name2, len);
    <span class="keywordflow">if</span> (cmp)
        <span class="keywordflow">return</span> cmp;
    <span class="comment">/* Directories and files compare equal (same length, same name) */</span>
    <span class="keywordflow">if</span> (len1 == len2)
        <span class="keywordflow">return</span> 0;
    c1 = name1[len];
    <span class="keywordflow">if</span> (!c1 &amp;&amp; S_ISDIR(mode1))
        c1 = <span class="charliteral">&#39;/&#39;</span>;
    c2 = name2[len];
    <span class="keywordflow">if</span> (!c2 &amp;&amp; S_ISDIR(mode2))
        c2 = <span class="charliteral">&#39;/&#39;</span>;
    <span class="keywordflow">if</span> (c1 == <span class="charliteral">&#39;/&#39;</span> &amp;&amp; !c2)
        <span class="keywordflow">return</span> 0;
    <span class="keywordflow">if</span> (c2 == <span class="charliteral">&#39;/&#39;</span> &amp;&amp; !c1)
        <span class="keywordflow">return</span> 0;
    <span class="keywordflow">return</span> c1 - c2;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a835affdb8e7226b619f5cbf69a36db1f"></a><!-- doxytag: member="index.c::discard_index" ref="a835affdb8e7226b619f5cbf69a36db1f" args="(struct index_state *istate)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="index_8h.html#a8a33b476c3dc728e33e68cd63bda31e0">discard_index</a> </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structindex__state.html">index_state</a> *&#160;</td>
          <td class="paramname"><em>istate</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="index_8c_source.html#l01947">1947</a> of file <a class="el" href="index_8c_source.html">index.c</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="keywordtype">int</span> i;
    <span class="keywordflow">for</span> (i = 0; i &lt; istate-&gt;<a class="code" href="structindex__state.html#a15b38cdd30ad2374bc12da429f39312f">cache_nr</a>; ++i)
        <a class="code" href="index_8c.html#a156a4ea461fcf14e0b73755b02e7e7d1">cache_entry_free</a> (istate-&gt;<a class="code" href="structindex__state.html#a8aa7a8aa984ec5a39ff2eee96412db07">cache</a>[i]);

    istate-&gt;<a class="code" href="structindex__state.html#a15b38cdd30ad2374bc12da429f39312f">cache_nr</a> = 0;
    istate-&gt;<a class="code" href="structindex__state.html#a8e22a9fe2486576488e72fe97801ebe5">cache_changed</a> = 0;
    istate-&gt;<a class="code" href="structindex__state.html#aba21746d004309949f3af631aced813a">timestamp</a>.<a class="code" href="structcache__time.html#ad79ea7590f31a5cc560ab4809d31562d">sec</a> = 0;
    istate-&gt;<a class="code" href="structindex__state.html#aba21746d004309949f3af631aced813a">timestamp</a>.<a class="code" href="structcache__time.html#acb016b82c22470ffc173985cd88d1389">nsec</a> = 0;
    istate-&gt;<a class="code" href="structindex__state.html#a3bd0f3096cd69989b40dd6c444a6e78a">name_hash_initialized</a> = 0;
    g_hash_table_destroy (istate-&gt;<a class="code" href="structindex__state.html#ab30d2dde7a88b0d003ac7fc31952a376">name_hash</a>);
<span class="preprocessor">#if defined WIN32 || defined __APPLE__</span>
<span class="preprocessor"></span>    g_hash_table_destroy (istate-&gt;i_name_hash);
<span class="preprocessor">#endif</span>
<span class="preprocessor"></span>    <span class="comment">/* cache_tree_free(&amp;(istate-&gt;cache_tree)); */</span>
    <span class="comment">/* free(istate-&gt;alloc); */</span>
    free(istate-&gt;<a class="code" href="structindex__state.html#a8aa7a8aa984ec5a39ff2eee96412db07">cache</a>);
    istate-&gt;<a class="code" href="structindex__state.html#a766e7e93e87c07997838e7493c650b10">alloc</a> = NULL;
    istate-&gt;<a class="code" href="structindex__state.html#a013bd6f4d9c68a7b25db32c15d29c7e2">initialized</a> = 0;

    <span class="comment">/* no need to throw away allocated active_cache */</span>
    <span class="keywordflow">return</span> 0;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a8225ef1fb93e6538cc4c632928516314"></a><!-- doxytag: member="index.c::fill_stat_cache_info" ref="a8225ef1fb93e6538cc4c632928516314" args="(struct cache_entry *ce, SeafStat *st)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="index_8h.html#a8225ef1fb93e6538cc4c632928516314">fill_stat_cache_info</a> </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structcache__entry.html">cache_entry</a> *&#160;</td>
          <td class="paramname"><em>ce</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="seafile_2lib_2utils_8h.html#a5b073bcbe1516b249924c3702002d32c">SeafStat</a> *&#160;</td>
          <td class="paramname"><em>st</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="index_8c_source.html#l00449">449</a> of file <a class="el" href="index_8c_source.html">index.c</a>.</p>
<div class="fragment"><pre class="fragment">{
    ce-&gt;<a class="code" href="structcache__entry.html#a5258a9a9e2fc3bfcd4859049912b65e8">ce_ctime</a>.<a class="code" href="structcache__time64.html#ae37877c7f3995f5a44a4a9fd7bb91d46">sec</a> = st-&gt;st_ctime;
    ce-&gt;<a class="code" href="structcache__entry.html#a1c66f1f4e7773a56010e7ec64bd38a95">ce_mtime</a>.<a class="code" href="structcache__time64.html#ae37877c7f3995f5a44a4a9fd7bb91d46">sec</a> = st-&gt;st_mtime;
    ce-&gt;<a class="code" href="structcache__entry.html#a5258a9a9e2fc3bfcd4859049912b65e8">ce_ctime</a>.<a class="code" href="structcache__time64.html#a2de767d16c1d2c35cb29ff45ee7b0b71">nsec</a> = 0;
    ce-&gt;<a class="code" href="structcache__entry.html#a1c66f1f4e7773a56010e7ec64bd38a95">ce_mtime</a>.<a class="code" href="structcache__time64.html#a2de767d16c1d2c35cb29ff45ee7b0b71">nsec</a> = 0;
    ce-&gt;<a class="code" href="structcache__entry.html#af8f54d3d01f8b04ed2f72cc7bacd618d">ce_dev</a> = st-&gt;st_dev;
    ce-&gt;<a class="code" href="structcache__entry.html#a1151b621d379629900c574c6a7509dcf">ce_ino</a> = st-&gt;st_ino;
    ce-&gt;<a class="code" href="structcache__entry.html#a69e38fc6cc73fe7c41ad8770cf5751a4">ce_uid</a> = st-&gt;st_uid;
    ce-&gt;<a class="code" href="structcache__entry.html#a1c80f7ae1cdf5c7244ea33cf9241b2f5">ce_gid</a> = st-&gt;st_gid;
    ce-&gt;<a class="code" href="structcache__entry.html#a869a62534c704e5d24ee26cf2f7b86b7">ce_size</a> = st-&gt;st_size;

    <span class="comment">/* if (assume_unchanged) */</span>
    <span class="comment">/*     ce-&gt;ce_flags |= CE_VALID; */</span>

    <span class="keywordflow">if</span> (S_ISREG(st-&gt;st_mode))
        <a class="code" href="index_8h.html#af89192589f914101b8c8cea880ab350d">ce_mark_uptodate</a>(ce);
}
</pre></div>
</div>
</div>
<a class="anchor" id="a2a76921da1fbb55b7b33983ca9e8edc4"></a><!-- doxytag: member="index.c::ie_match_stat" ref="a2a76921da1fbb55b7b33983ca9e8edc4" args="(struct cache_entry *ce, SeafStat *st, unsigned int options)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="index_8h.html#ab298f4c9f4e01e029692bef63517a852">ie_match_stat</a> </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structcache__entry.html">cache_entry</a> *&#160;</td>
          <td class="paramname"><em>ce</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="seafile_2lib_2utils_8h.html#a5b073bcbe1516b249924c3702002d32c">SeafStat</a> *&#160;</td>
          <td class="paramname"><em>st</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>options</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="index_8c_source.html#l00609">609</a> of file <a class="el" href="index_8c_source.html">index.c</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> changed;
    <span class="keywordtype">int</span> ignore_valid = <a class="code" href="structoptions.html">options</a> &amp; <a class="code" href="index_8h.html#a3ecb29f06d046b6a99ed2148f91ae0c3">CE_MATCH_IGNORE_VALID</a>;
    <span class="keywordtype">int</span> ignore_skip_worktree = <a class="code" href="structoptions.html">options</a> &amp; <a class="code" href="index_8h.html#abd49280eba10dafd6f24cc3a6eab6313">CE_MATCH_IGNORE_SKIP_WORKTREE</a>;
    <span class="comment">/* int assume_racy_is_modified = options &amp; CE_MATCH_RACY_IS_DIRTY; */</span>

    <span class="comment">/*</span>
<span class="comment">     * If it&#39;s marked as always valid in the index, it&#39;s</span>
<span class="comment">     * valid whatever the checked-out copy says.</span>
<span class="comment">     *</span>
<span class="comment">     * skip-worktree has the same effect with higher precedence</span>
<span class="comment">     */</span>
    <span class="keywordflow">if</span> (!ignore_skip_worktree &amp;&amp; <a class="code" href="index_8h.html#aa9cb581aaeefbbd01aa6c7997f44a5e4">ce_skip_worktree</a>(ce))
        <span class="keywordflow">return</span> 0;
    <span class="keywordflow">if</span> (!ignore_valid &amp;&amp; (ce-&gt;<a class="code" href="structcache__entry.html#a4dab14fd813a1bb6b67352674ff4afb2">ce_flags</a> &amp; <a class="code" href="index_8h.html#a85680cf3653d1fd82efb449619733ea4">CE_VALID</a>))
        <span class="keywordflow">return</span> 0;

    <span class="comment">/*</span>
<span class="comment">     * Intent-to-add entries have not been added, so the index entry</span>
<span class="comment">     * by definition never matches what is in the work tree until it</span>
<span class="comment">     * actually gets added.</span>
<span class="comment">     */</span>
    <span class="comment">/* if (ce-&gt;ce_flags &amp; CE_INTENT_TO_ADD) */</span>
    <span class="comment">/*     return DATA_CHANGED | TYPE_CHANGED | MODE_CHANGED; */</span>

    changed = ce_match_stat_basic(ce, st);

    <span class="comment">/*</span>
<span class="comment">     * Within 1 second of this sequence:</span>
<span class="comment">     *     echo xyzzy &gt;file &amp;&amp; git-update-index --add file</span>
<span class="comment">     * running this command:</span>
<span class="comment">     *     echo frotz &gt;file</span>
<span class="comment">     * would give a falsely clean cache entry.  The mtime and</span>
<span class="comment">     * length match the cache, and other stat fields do not change.</span>
<span class="comment">     *</span>
<span class="comment">     * We could detect this at update-index time (the cache entry</span>
<span class="comment">     * being registered/updated records the same time as &quot;now&quot;)</span>
<span class="comment">     * and delay the return from git-update-index, but that would</span>
<span class="comment">     * effectively mean we can make at most one commit per second,</span>
<span class="comment">     * which is not acceptable.  Instead, we check cache entries</span>
<span class="comment">     * whose mtime are the same as the index file timestamp more</span>
<span class="comment">     * carefully than others.</span>
<span class="comment">     */</span>
<span class="preprocessor">#if 0</span>
<span class="preprocessor"></span>    <span class="keywordflow">if</span> (!changed &amp;&amp; is_racy_timestamp(istate, ce)) {
        <span class="comment">/* if (assume_racy_is_modified) */</span>
        <span class="comment">/*     changed |= DATA_CHANGED; */</span>
        <span class="comment">/* else */</span>
        <span class="comment">/*     changed |= ce_modified_check_fs(ce, st); */</span>
        changed = <a class="code" href="index_8h.html#a795e49b040736f9ff8d888ac89841d66">DATA_CHANGED</a>;
    }
<span class="preprocessor">#endif</span>
<span class="preprocessor"></span>
    <span class="keywordflow">return</span> changed;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a37ae9831253a5201f6d773a14e1da9ac"></a><!-- doxytag: member="index.c::index_fd" ref="a37ae9831253a5201f6d773a14e1da9ac" args="(unsigned char *sha1, int fd, SeafStat *st, enum object_type type, const char *path)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="index_8h.html#a37ae9831253a5201f6d773a14e1da9ac">index_fd</a> </td>
          <td>(</td>
          <td class="paramtype">unsigned char *&#160;</td>
          <td class="paramname"><em>sha1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>fd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="seafile_2lib_2utils_8h.html#a5b073bcbe1516b249924c3702002d32c">SeafStat</a> *&#160;</td>
          <td class="paramname"><em>st</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="index_8h.html#af54461b7c3322b2256322f7b545bd623">object_type</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="index_8c_source.html#l01614">1614</a> of file <a class="el" href="index_8c_source.html">index.c</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="keywordtype">int</span> ret;
    uint64_t <a class="code" href="index_8h.html#af931a8871310b4dad23f0f0b0f623560">size</a> = st-&gt;st_size;

    <span class="keywordflow">if</span> (!size) {
        ret = index_mem(<a class="code" href="index_8h.html#a96e76167c968d38441e90ee0488ee4aa">sha1</a>, NULL, size, <a class="code" href="fs-mgr_8c.html#a65cfc9e13d3352fd9099a0408cba715c">type</a>, path);
    } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (size &lt;= <a class="code" href="index_8c.html#a00b82f1418e7fe22a934b5867ad43279">SMALL_FILE_SIZE</a>) {
        <span class="keywordtype">char</span> *buf = malloc(size);
        <span class="keywordflow">if</span> (size == <a class="code" href="seafile_2lib_2utils_8c.html#a05f0eae648599d413d03103758473e30">readn</a>(fd, buf, size)) {
            ret = index_mem(<a class="code" href="index_8h.html#a96e76167c968d38441e90ee0488ee4aa">sha1</a>, buf, size, <a class="code" href="fs-mgr_8c.html#a65cfc9e13d3352fd9099a0408cba715c">type</a>, path);
        } <span class="keywordflow">else</span> {
            g_warning(<span class="stringliteral">&quot;short read %s\n&quot;</span>, strerror(errno));
            ret = -1;
        }
        free(buf);
    } <span class="keywordflow">else</span> {
        <span class="keywordtype">void</span> *buf = mmap(NULL, size, PROT_READ, MAP_PRIVATE, fd, 0);
        ret = index_mem(<a class="code" href="index_8h.html#a96e76167c968d38441e90ee0488ee4aa">sha1</a>, buf, size, <a class="code" href="fs-mgr_8c.html#a65cfc9e13d3352fd9099a0408cba715c">type</a>, path);
        munmap(buf, size);
    }
    close(fd);
    <span class="keywordflow">return</span> ret;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a3931a94c55aad8bf8267f179ae846711"></a><!-- doxytag: member="index.c::index_name_exists" ref="a3931a94c55aad8bf8267f179ae846711" args="(struct index_state *istate, const char *name, int namelen, int igncase)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structcache__entry.html">cache_entry</a>* <a class="el" href="name-hash_8c.html#aa04dd65e5bcc8fc409a90a17ff80449a">index_name_exists</a> </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structindex__state.html">index_state</a> *&#160;</td>
          <td class="paramname"><em>istate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>namelen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>igncase</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [read]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="index_8c_source.html#l01997">1997</a> of file <a class="el" href="index_8c_source.html">index.c</a>.</p>
<div class="fragment"><pre class="fragment">{
<span class="preprocessor">#if defined WIN32 || defined __APPLE__</span>
<span class="preprocessor"></span>    <span class="keywordflow">if</span> (!igncase)
        <span class="keywordflow">return</span> g_hash_table_lookup (istate-&gt;<a class="code" href="structindex__state.html#ab30d2dde7a88b0d003ac7fc31952a376">name_hash</a>, <a class="code" href="index_8h.html#a2a7f851274ec18e17d38114c39b8511a">name</a>);
    <span class="keywordflow">else</span> {
        <span class="keyword">struct </span><a class="code" href="structcache__entry.html">cache_entry</a> *ce;
        <span class="keywordtype">char</span> *i_name = g_utf8_strdown (<a class="code" href="index_8h.html#a2a7f851274ec18e17d38114c39b8511a">name</a>, -1);
        ce = g_hash_table_lookup (istate-&gt;i_name_hash, i_name);
        g_free (i_name);
        <span class="keywordflow">return</span> ce;
    }
<span class="preprocessor">#else</span>
<span class="preprocessor"></span>    <span class="keywordflow">return</span> g_hash_table_lookup (istate-&gt;<a class="code" href="structindex__state.html#ab30d2dde7a88b0d003ac7fc31952a376">name_hash</a>, <a class="code" href="index_8h.html#a2a7f851274ec18e17d38114c39b8511a">name</a>);
<span class="preprocessor">#endif</span>
<span class="preprocessor"></span>}
</pre></div>
</div>
</div>
<a class="anchor" id="a1f5ad45bcfb5a2dcc3fae542fa293d4a"></a><!-- doxytag: member="index.c::index_name_pos" ref="a1f5ad45bcfb5a2dcc3fae542fa293d4a" args="(const struct index_state *istate, const char *name, int namelen)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="index_8h.html#a6d8301cfe39c3625c2e6132d81ea4867">index_name_pos</a> </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structindex__state.html">index_state</a> *&#160;</td>
          <td class="paramname"><em>istate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>namelen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="index_8c_source.html#l00702">702</a> of file <a class="el" href="index_8c_source.html">index.c</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="keywordtype">int</span> first, last;

    first = 0;
    last = istate-&gt;<a class="code" href="structindex__state.html#a15b38cdd30ad2374bc12da429f39312f">cache_nr</a>;
    <span class="keywordflow">while</span> (last &gt; first) {
        <span class="keywordtype">int</span> <a class="code" href="structcache__entry.html#afd4bec9067a7e0c76158d32a9d287684">next</a> = (last + first) &gt;&gt; 1;
        <span class="keyword">struct </span><a class="code" href="structcache__entry.html">cache_entry</a> *ce = istate-&gt;<a class="code" href="structindex__state.html#a8aa7a8aa984ec5a39ff2eee96412db07">cache</a>[<a class="code" href="structcache__entry.html#afd4bec9067a7e0c76158d32a9d287684">next</a>];
        <span class="keywordtype">int</span> cmp = <a class="code" href="index_8c.html#a36a1039c7b0e5005a36afc70220630e4">cache_name_compare</a>(<a class="code" href="index_8h.html#a2a7f851274ec18e17d38114c39b8511a">name</a>, namelen, ce-&gt;<a class="code" href="structcache__entry.html#a792e4ea24cb16c76abe3229651e414a0">name</a>, ce-&gt;<a class="code" href="structcache__entry.html#a4dab14fd813a1bb6b67352674ff4afb2">ce_flags</a>);
        <span class="keywordflow">if</span> (!cmp)
            <span class="keywordflow">return</span> <a class="code" href="structcache__entry.html#afd4bec9067a7e0c76158d32a9d287684">next</a>;
        <span class="keywordflow">if</span> (cmp &lt; 0) {
            last = <a class="code" href="structcache__entry.html#afd4bec9067a7e0c76158d32a9d287684">next</a>;
            <span class="keywordflow">continue</span>;
        }
        first = next+1;
    }
    <span class="keywordflow">return</span> -first-1;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a35caece3e3575d32521f820a8f0a24a7"></a><!-- doxytag: member="index.c::index_path" ref="a35caece3e3575d32521f820a8f0a24a7" args="(unsigned char *sha1, const char *path, SeafStat *st)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="index_8h.html#a35caece3e3575d32521f820a8f0a24a7">index_path</a> </td>
          <td>(</td>
          <td class="paramtype">unsigned char *&#160;</td>
          <td class="paramname"><em>sha1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="seafile_2lib_2utils_8h.html#a5b073bcbe1516b249924c3702002d32c">SeafStat</a> *&#160;</td>
          <td class="paramname"><em>st</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="index_8c_source.html#l01640">1640</a> of file <a class="el" href="index_8c_source.html">index.c</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="keywordtype">int</span> fd;
    <span class="keywordtype">char</span> buf[<a class="code" href="seafile_2common_2common_8h.html#a169a119979344433b9e2a39e4e8e334a">SEAF_PATH_MAX</a>];
    <span class="keywordtype">int</span> pathlen;

    <span class="keywordflow">switch</span> (st-&gt;st_mode &amp; S_IFMT) {
    <span class="keywordflow">case</span> S_IFREG:
        fd = <a class="code" href="seafile_2lib_2utils_8c.html#ad154e736c3751fe880395dff55fab739">seaf_util_open</a> (path, O_RDONLY | O_BINARY);
        <span class="keywordflow">if</span> (fd &lt; 0) {
            g_warning(<span class="stringliteral">&quot;g_open (\&quot;%s\&quot;): %s\n&quot;</span>, path, strerror(errno));
            <span class="keywordflow">return</span> -1;
        }
        <span class="keywordflow">if</span> (<a class="code" href="index_8c.html#a37ae9831253a5201f6d773a14e1da9ac">index_fd</a>(<a class="code" href="index_8h.html#a96e76167c968d38441e90ee0488ee4aa">sha1</a>, fd, st, <a class="code" href="index_8h.html#af54461b7c3322b2256322f7b545bd623a349804bd0b40b4a3a21bd0fb78154459">OBJ_BLOB</a>, path) &lt; 0) {
            <span class="keywordflow">return</span> -1;
        }
        <span class="keywordflow">break</span>;
<span class="preprocessor">#ifndef WIN32        </span>
<span class="preprocessor"></span>    <span class="keywordflow">case</span> S_IFLNK:
        pathlen = readlink(path, buf, <a class="code" href="seafile_2common_2common_8h.html#a169a119979344433b9e2a39e4e8e334a">SEAF_PATH_MAX</a>);
        <span class="keywordflow">if</span> (pathlen != st-&gt;st_size) {
            <span class="keywordtype">char</span> *errstr = strerror(errno);
            g_warning(<span class="stringliteral">&quot;readlink(\&quot;%s\&quot;): %s\n&quot;</span>, path, errstr);
            <span class="keywordflow">return</span> -1;
        }
        hash_sha1_file(buf, pathlen, <span class="keyword">typename</span>(<a class="code" href="index_8h.html#af54461b7c3322b2256322f7b545bd623a349804bd0b40b4a3a21bd0fb78154459">OBJ_BLOB</a>), <a class="code" href="index_8h.html#a96e76167c968d38441e90ee0488ee4aa">sha1</a>);
        <span class="keywordflow">break</span>;
<span class="preprocessor">#endif        </span>
<span class="preprocessor"></span>    <span class="keywordflow">default</span>:
        g_warning(<span class="stringliteral">&quot;%s: unsupported file type\n&quot;</span>, path);
        <span class="keywordflow">return</span> -1;
    }
    <span class="keywordflow">return</span> 0;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a9527d61c2cbd37e4f1691dfc0f543a5d"></a><!-- doxytag: member="index.c::is_index_unborn" ref="a9527d61c2cbd37e4f1691dfc0f543a5d" args="(struct index_state *istate)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="index_8h.html#a23cf99ad7e0d7bffd70767fecdd7a8bd">is_index_unborn</a> </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structindex__state.html">index_state</a> *&#160;</td>
          <td class="paramname"><em>istate</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="index_8c_source.html#l00403">403</a> of file <a class="el" href="index_8c_source.html">index.c</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="keywordflow">return</span> (!istate-&gt;<a class="code" href="structindex__state.html#a15b38cdd30ad2374bc12da429f39312f">cache_nr</a> &amp;&amp; !istate-&gt;<a class="code" href="structindex__state.html#a766e7e93e87c07997838e7493c650b10">alloc</a> &amp;&amp; !istate-&gt;<a class="code" href="structindex__state.html#aba21746d004309949f3af631aced813a">timestamp</a>.<a class="code" href="structcache__time.html#ad79ea7590f31a5cc560ab4809d31562d">sec</a>);
}
</pre></div>
</div>
</div>
<a class="anchor" id="ac1791afc7341bbfdee313b82eb250c2c"></a><!-- doxytag: member="index.c::make_cache_entry" ref="ac1791afc7341bbfdee313b82eb250c2c" args="(unsigned int mode, const unsigned char *sha1, const char *path, const char *full_path, int stage, int refresh)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structcache__entry.html">cache_entry</a>* <a class="el" href="index_8h.html#ac1791afc7341bbfdee313b82eb250c2c">make_cache_entry</a> </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned char *&#160;</td>
          <td class="paramname"><em>sha1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>full_path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>stage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>refresh</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [read]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="index_8c_source.html#l01520">1520</a> of file <a class="el" href="index_8c_source.html">index.c</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="keywordtype">int</span> <a class="code" href="index_8h.html#af931a8871310b4dad23f0f0b0f623560">size</a>, len;
    <span class="keyword">struct </span><a class="code" href="structcache__entry.html">cache_entry</a> *ce;

    <span class="comment">/* if (!verify_path(path)) { */</span>
    <span class="comment">/*     g_warning(&quot;Invalid path &#39;%s&#39;&quot;, path); */</span>
    <span class="comment">/*     return NULL; */</span>
    <span class="comment">/* } */</span>

    len = strlen(path);
    size = <a class="code" href="index_8h.html#a07a18158c879287d1606ceec992ba702">cache_entry_size</a>(len);
    ce = calloc(1, size);

    hashcpy(ce-&gt;<a class="code" href="structcache__entry.html#a119ab5c5e9db495e6e5f8d301f01421c">sha1</a>, <a class="code" href="index_8h.html#a96e76167c968d38441e90ee0488ee4aa">sha1</a>);
    memcpy(ce-&gt;<a class="code" href="structcache__entry.html#a792e4ea24cb16c76abe3229651e414a0">name</a>, path, len);
    ce-&gt;<a class="code" href="structcache__entry.html#a4dab14fd813a1bb6b67352674ff4afb2">ce_flags</a> = create_ce_flags(len, stage);
    ce-&gt;<a class="code" href="structcache__entry.html#a5fcbcc4e7265ae8150f136380ed92c05">ce_mode</a> = create_ce_mode(<a class="code" href="index_8h.html#ac1b4d694fc07a39e06900e82872aac7f">mode</a>);

    <span class="keywordflow">if</span> (refresh)
        <span class="keywordflow">return</span> refresh_cache_entry(ce, full_path);

    <span class="keywordflow">return</span> ce;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a1bcae1e686ad516d8b562a214c9e2cd8"></a><!-- doxytag: member="index.c::mark_all_ce_unused" ref="a1bcae1e686ad516d8b562a214c9e2cd8" args="(struct index_state *index)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="index_8h.html#a1bcae1e686ad516d8b562a214c9e2cd8">mark_all_ce_unused</a> </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structindex__state.html">index_state</a> *&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="index_8c_source.html#l00468">468</a> of file <a class="el" href="index_8c_source.html">index.c</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="keywordtype">int</span> i;
    <span class="keywordflow">for</span> (i = 0; i &lt; index-&gt;<a class="code" href="structindex__state.html#a15b38cdd30ad2374bc12da429f39312f">cache_nr</a>; i++)
        index-&gt;<a class="code" href="structindex__state.html#a8aa7a8aa984ec5a39ff2eee96412db07">cache</a>[i]-&gt;<a class="code" href="structcache__entry.html#a4dab14fd813a1bb6b67352674ff4afb2">ce_flags</a> &amp;= ~(<a class="code" href="index_8h.html#ab9f9391faf6b3de1d55d71cb07417d0e">CE_UNPACKED</a> | <a class="code" href="index_8h.html#a586309b1feb22f9865dd8925c4a998b2">CE_ADDED</a> | <a class="code" href="index_8h.html#a8067adb7b7861023504f0dccaf0db8f3">CE_NEW_SKIP_WORKTREE</a>);
}
</pre></div>
</div>
</div>
<a class="anchor" id="a0f9de2761514c9136fb4b9c5541ef6f8"></a><!-- doxytag: member="index.c::read_index_from" ref="a0f9de2761514c9136fb4b9c5541ef6f8" args="(struct index_state *istate, const char *path, int repo_version)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="index_8h.html#a34634123a8512d58dda6621a79080e56">read_index_from</a> </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structindex__state.html">index_state</a> *&#160;</td>
          <td class="paramname"><em>istate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>repo_version</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="index_8c_source.html#l00276">276</a> of file <a class="el" href="index_8c_source.html">index.c</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="keywordtype">int</span> fd, i;
    <a class="code" href="seafile_2lib_2utils_8h.html#a5b073bcbe1516b249924c3702002d32c">SeafStat</a> st;
    <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> src_offset;
    <span class="keyword">struct </span><a class="code" href="structcache__header.html">cache_header</a> *hdr;
    <span class="keywordtype">void</span> *mm;
    <span class="keywordtype">size_t</span> mmap_size;

    <span class="keywordflow">if</span> (istate-&gt;<a class="code" href="structindex__state.html#a013bd6f4d9c68a7b25db32c15d29c7e2">initialized</a>)
        <span class="keywordflow">return</span> istate-&gt;<a class="code" href="structindex__state.html#a15b38cdd30ad2374bc12da429f39312f">cache_nr</a>;

    <span class="comment">/* All newly created index files are version 4. */</span>
    istate-&gt;<a class="code" href="structindex__state.html#a0fb0d6a2dabae448b68f04e75ffc1612">version</a> = 4;
    <span class="comment">/* Index file stores modifier info if repo version &gt; 0 */</span>
    <span class="keywordflow">if</span> (repo_version &gt; 0)
        istate-&gt;<a class="code" href="structindex__state.html#ac5f843973ed4eba3c6370ae193ac97a9">has_modifier</a> = 1;
    istate-&gt;<a class="code" href="structindex__state.html#aba21746d004309949f3af631aced813a">timestamp</a>.<a class="code" href="structcache__time.html#ad79ea7590f31a5cc560ab4809d31562d">sec</a> = 0;
    istate-&gt;<a class="code" href="structindex__state.html#aba21746d004309949f3af631aced813a">timestamp</a>.<a class="code" href="structcache__time.html#acb016b82c22470ffc173985cd88d1389">nsec</a> = 0;
    fd = <a class="code" href="seafile_2lib_2utils_8c.html#ad154e736c3751fe880395dff55fab739">seaf_util_open</a> (path, O_RDONLY | O_BINARY);
    <span class="keywordflow">if</span> (fd &lt; 0) {
        <span class="keywordflow">if</span> (errno == ENOENT) {
            alloc_index (istate);
            <span class="keywordflow">return</span> 0;
        }
        g_critical(<span class="stringliteral">&quot;index file open failed\n&quot;</span>);
        <span class="keywordflow">return</span> -1;
    }

    <span class="keywordflow">if</span> (<a class="code" href="seafile_2lib_2utils_8c.html#a09f0677ad28b98b7a85bcda57f71e7c8">seaf_fstat</a>(fd, &amp;st)) {
        g_critical(<span class="stringliteral">&quot;cannot stat the open index\n&quot;</span>);
        <span class="keywordflow">return</span> -1;
    }

    mmap_size = (size_t)st.st_size;
    if (mmap_size &lt; <span class="keyword">sizeof</span>(<span class="keyword">struct</span> <a class="code" href="structcache__header.html">cache_header</a>) + 20) {
        g_critical(<span class="stringliteral">&quot;index file smaller than expected\n&quot;</span>);
        <span class="keywordflow">return</span> -1;
    }

    mm = mmap(NULL, mmap_size, PROT_READ | PROT_WRITE, MAP_PRIVATE, fd, 0);
    close(fd);
    <span class="keywordflow">if</span> (mm == MAP_FAILED) {
        g_critical(<span class="stringliteral">&quot;unable to map index file\n&quot;</span>);
        <span class="keywordflow">return</span> -1;
    }

    hdr = mm;
    <span class="keywordflow">if</span> (verify_hdr(hdr, mmap_size) &lt; 0)
        <span class="keywordflow">goto</span> unmap;

    <span class="comment">/* Index version will be set to on-disk value here.</span>
<span class="comment">     * If the index is from an old repo, it will be set to 2.</span>
<span class="comment">     * But when we write the index, it&#39;ll be updated to version 4.</span>
<span class="comment">     */</span>
    istate-&gt;<a class="code" href="structindex__state.html#a0fb0d6a2dabae448b68f04e75ffc1612">version</a> = ntohl(hdr-&gt;<a class="code" href="structcache__header.html#a42d8ebfd084e6f8a35bb0d7fd384c2e1">hdr_version</a>);
    istate-&gt;<a class="code" href="structindex__state.html#a15b38cdd30ad2374bc12da429f39312f">cache_nr</a> = ntohl(hdr-&gt;<a class="code" href="structcache__header.html#a9eda4ffb0b1c1f379195d68cf6bd04eb">hdr_entries</a>);
    alloc_index (istate);

    <span class="comment">/*</span>
<span class="comment">     * The disk format is actually larger than the in-memory format,</span>
<span class="comment">     * due to space for nsec etc, so even though the in-memory one</span>
<span class="comment">     * has room for a few  more flags, we can allocate using the same</span>
<span class="comment">     * index size</span>
<span class="comment">     */</span>

    src_offset = <span class="keyword">sizeof</span>(*hdr);
    <span class="keywordflow">for</span> (i = 0; i &lt; istate-&gt;<a class="code" href="structindex__state.html#a15b38cdd30ad2374bc12da429f39312f">cache_nr</a>; i++) {
        <span class="keyword">struct </span><a class="code" href="structondisk__cache__entry.html">ondisk_cache_entry</a> *disk_ce;
        <span class="keyword">struct </span><a class="code" href="structondisk__cache__entry2.html">ondisk_cache_entry2</a> *disk_ce2;
        <span class="keyword">struct </span><a class="code" href="structcache__entry.html">cache_entry</a> *ce;

        <span class="keywordflow">if</span> (istate-&gt;<a class="code" href="structindex__state.html#a0fb0d6a2dabae448b68f04e75ffc1612">version</a> &lt; 4) {
            disk_ce = (<span class="keyword">struct </span><a class="code" href="structondisk__cache__entry.html">ondisk_cache_entry</a> *)((<span class="keywordtype">char</span> *)mm + src_offset);

            <span class="comment">/* allocate each ce separately so that we can free new</span>
<span class="comment">             * entries added by add_index_entry() later.</span>
<span class="comment">             */</span>
            <span class="keywordflow">if</span> (convert_from_disk(disk_ce, &amp;ce) &lt; 0)
                <span class="keywordflow">return</span> -1;

            src_offset += <a class="code" href="index_8h.html#ad562eeda2e10022dc93db2b51b3df1e9">ondisk_ce_size</a>(ce);
        } <span class="keywordflow">else</span> {
            disk_ce2 = (<span class="keyword">struct </span><a class="code" href="structondisk__cache__entry2.html">ondisk_cache_entry2</a> *)((<span class="keywordtype">char</span> *)mm + src_offset);

            <span class="comment">/* allocate each ce separately so that we can free new</span>
<span class="comment">             * entries added by add_index_entry() later.</span>
<span class="comment">             */</span>
            <span class="keywordflow">if</span> (convert_from_disk2(disk_ce2, &amp;ce) &lt; 0)
                <span class="keywordflow">return</span> -1;

            src_offset += <a class="code" href="index_8h.html#a75e5d7a68fa10d5816da166b78d2d25a">ondisk_ce_size2</a>(ce);
        }
        set_index_entry(istate, i, ce);
    }
    istate-&gt;<a class="code" href="structindex__state.html#aba21746d004309949f3af631aced813a">timestamp</a>.<a class="code" href="structcache__time.html#ad79ea7590f31a5cc560ab4809d31562d">sec</a> = st.st_mtime;
    istate-&gt;<a class="code" href="structindex__state.html#aba21746d004309949f3af631aced813a">timestamp</a>.<a class="code" href="structcache__time.html#acb016b82c22470ffc173985cd88d1389">nsec</a> = 0;

    <span class="keywordflow">while</span> (src_offset &lt;= mmap_size - 20 - <span class="keyword">sizeof</span>(<span class="keyword">struct</span> <a class="code" href="structcache__ext__hdr.html">cache_ext_hdr</a>)) {
        <span class="comment">/* After an array of active_nr index entries,</span>
<span class="comment">         * there can be arbitrary number of extended</span>
<span class="comment">         * sections, each of which is prefixed with</span>
<span class="comment">         * extension name (4-byte) and section length</span>
<span class="comment">         * in 4-byte network byte order.</span>
<span class="comment">         */</span>
        <span class="keyword">struct </span><a class="code" href="structcache__ext__hdr.html">cache_ext_hdr</a> *exthdr;
        exthdr = (<span class="keyword">struct </span><a class="code" href="structcache__ext__hdr.html">cache_ext_hdr</a> *) ((<span class="keywordtype">char</span> *)mm + src_offset);
        <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="index_8h.html#a2a7f851274ec18e17d38114c39b8511a">name</a> = ntohl(exthdr-&gt;<a class="code" href="structcache__ext__hdr.html#aa8927d4824d0db0ebb5b9b0ded6ec16f">ext_name</a>);
        <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="index_8h.html#af931a8871310b4dad23f0f0b0f623560">size</a> = ntohl(exthdr-&gt;<a class="code" href="structcache__ext__hdr.html#a638ba3d19b4e56af024989857bafc8dd">ext_size</a>);
        <span class="keywordflow">if</span> (read_index_extension(istate,
                                 name,
                                 (<span class="keywordtype">char</span> *) mm + src_offset + <span class="keyword">sizeof</span>(<span class="keyword">struct</span> <a class="code" href="structcache__ext__hdr.html">cache_ext_hdr</a>),
                                 size) &lt; 0)
            <span class="keywordflow">goto</span> unmap;
        src_offset += <span class="keyword">sizeof</span>(<span class="keyword">struct </span><a class="code" href="structcache__ext__hdr.html">cache_ext_hdr</a>);
        src_offset += <a class="code" href="index_8h.html#af931a8871310b4dad23f0f0b0f623560">size</a>;
    }

    munmap(mm, mmap_size);
    <span class="keywordflow">return</span> istate-&gt;<a class="code" href="structindex__state.html#a15b38cdd30ad2374bc12da429f39312f">cache_nr</a>;

unmap:
    munmap(mm, mmap_size);
    g_critical(<span class="stringliteral">&quot;index file corrupt\n&quot;</span>);
    <span class="keywordflow">return</span> -1;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a21d6b0245750631144db52218a179633"></a><!-- doxytag: member="index.c::remove_empty_parent_dir_entry" ref="a21d6b0245750631144db52218a179633" args="(struct index_state *istate, const char *path)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="index_8h.html#a21d6b0245750631144db52218a179633">remove_empty_parent_dir_entry</a> </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structindex__state.html">index_state</a> *&#160;</td>
          <td class="paramname"><em>istate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="index_8c_source.html#l00870">870</a> of file <a class="el" href="index_8c_source.html">index.c</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="keywordtype">char</span> *parent = g_strdup(path);
    <span class="keywordtype">char</span> *slash;

    <span class="comment">/* Find and remove empty dir entry from low level to top level. */</span>
    <span class="keywordflow">while</span> (1) {
        slash = strrchr (parent, <span class="charliteral">&#39;/&#39;</span>);
        <span class="keywordflow">if</span> (!slash)
            <span class="keywordflow">break</span>;

        *slash = 0;

        <span class="keywordflow">if</span> (<a class="code" href="index_8c.html#a3931a94c55aad8bf8267f179ae846711">index_name_exists</a> (istate, parent, strlen(parent), 0) != NULL) {
            <a class="code" href="index_8c.html#ac131057c151521f1cff71bf1510ef050">remove_file_from_index</a> (istate, parent);
            <span class="keywordflow">break</span>;
        }
    }

    g_free (parent);
}
</pre></div>
</div>
</div>
<a class="anchor" id="ac131057c151521f1cff71bf1510ef050"></a><!-- doxytag: member="index.c::remove_file_from_index" ref="ac131057c151521f1cff71bf1510ef050" args="(struct index_state *istate, const char *path)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="index_8h.html#a478519e092fd07dacd10c804cfec4282">remove_file_from_index</a> </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structindex__state.html">index_state</a> *&#160;</td>
          <td class="paramname"><em>istate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="index_8c_source.html#l00763">763</a> of file <a class="el" href="index_8c_source.html">index.c</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="keywordtype">int</span> pos = <a class="code" href="index_8c.html#a1f5ad45bcfb5a2dcc3fae542fa293d4a">index_name_pos</a>(istate, path, strlen(path));
    <span class="keywordflow">if</span> (pos &lt; 0)
        pos = -pos-1;
    <span class="comment">/* cache_tree_invalidate_path(istate-&gt;cache_tree, path); */</span>
    <span class="keywordflow">while</span> (pos &lt; istate-&gt;cache_nr &amp;&amp; !strcmp(istate-&gt;<a class="code" href="structindex__state.html#a8aa7a8aa984ec5a39ff2eee96412db07">cache</a>[pos]-&gt;<a class="code" href="structcache__entry.html#a792e4ea24cb16c76abe3229651e414a0">name</a>, path))
        <a class="code" href="index_8c.html#aae99b184a9d6c213a39042b5452081f9">remove_index_entry_at</a>(istate, pos);
    <span class="keywordflow">return</span> 0;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a86bf1084dfc4e0057a52b4da1922de9b"></a><!-- doxytag: member="index.c::remove_from_index_with_prefix" ref="a86bf1084dfc4e0057a52b4da1922de9b" args="(struct index_state *istate, const char *path_prefix, gboolean *not_found)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="index_8h.html#a86bf1084dfc4e0057a52b4da1922de9b">remove_from_index_with_prefix</a> </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structindex__state.html">index_state</a> *&#160;</td>
          <td class="paramname"><em>istate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path_prefix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gboolean *&#160;</td>
          <td class="paramname"><em>not_found</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="index_8c_source.html#l01180">1180</a> of file <a class="el" href="index_8c_source.html">index.c</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="keywordtype">int</span> pathlen = strlen(path_prefix);
    <span class="keywordtype">int</span> pos = <a class="code" href="index_8c.html#a1f5ad45bcfb5a2dcc3fae542fa293d4a">index_name_pos</a> (istate, path_prefix, pathlen);
    <span class="keyword">struct </span><a class="code" href="structcache__entry.html">cache_entry</a> *ce;

    <span class="keywordflow">if</span> (not_found)
        *not_found = FALSE;

    <span class="comment">/* Exact match, remove that entry. */</span>
    <span class="keywordflow">if</span> (pos &gt;= 0) {
        <a class="code" href="index_8c.html#aae99b184a9d6c213a39042b5452081f9">remove_index_entry_at</a> (istate, pos);
        <span class="keywordflow">return</span> 0;
    }

    <span class="comment">/* Otherwise it may be a prefix match, remove all entries begin with this prefix.</span>
<span class="comment">     */</span>

    <span class="comment">/* -pos = (the position this entry *should* be) + 1.</span>
<span class="comment">     * So -pos-1 is the first entry larger than this entry.</span>
<span class="comment">     */</span>
    pos = -pos-1;

    <span class="comment">/* Add &#39;/&#39; to the end of prefix so that we won&#39;t match a partial path component.</span>
<span class="comment">     * e.g. we don&#39;t want to match &#39;abc&#39; with &#39;abcd/ef&#39;</span>
<span class="comment">     */</span>
    <span class="keywordtype">char</span> *full_path_prefix = g_strconcat (path_prefix, <span class="stringliteral">&quot;/&quot;</span>, NULL);
    ++pathlen;

    <span class="keywordflow">while</span> (pos &lt; istate-&gt;cache_nr) {
        ce = istate-&gt;<a class="code" href="structindex__state.html#a8aa7a8aa984ec5a39ff2eee96412db07">cache</a>[pos];
        <span class="keywordflow">if</span> (strncmp (ce-&gt;<a class="code" href="structcache__entry.html#a792e4ea24cb16c76abe3229651e414a0">name</a>, full_path_prefix, pathlen) &lt; 0) {
            ++pos;
        } <span class="keywordflow">else</span>
            <span class="keywordflow">break</span>;
    }

    <span class="keywordflow">if</span> (pos == istate-&gt;<a class="code" href="structindex__state.html#a15b38cdd30ad2374bc12da429f39312f">cache_nr</a>) {
        g_free (full_path_prefix);
        <span class="keywordflow">if</span> (not_found)
            *not_found = TRUE;
        <span class="keywordflow">return</span> 0;
    }

    <span class="keywordtype">int</span> i = pos;
    <span class="keywordflow">while</span> (i &lt; istate-&gt;cache_nr) {
        ce = istate-&gt;<a class="code" href="structindex__state.html#a8aa7a8aa984ec5a39ff2eee96412db07">cache</a>[i];
        <span class="keywordflow">if</span> (strncmp (ce-&gt;<a class="code" href="structcache__entry.html#a792e4ea24cb16c76abe3229651e414a0">name</a>, full_path_prefix, pathlen) == 0) {
            <a class="code" href="index_8c.html#a62df0f7f37866aabf0b0faf196fc0ddf">remove_name_hash</a>(istate, ce);
            <a class="code" href="index_8c.html#a156a4ea461fcf14e0b73755b02e7e7d1">cache_entry_free</a> (ce);
            ++i;
        } <span class="keywordflow">else</span>
            <span class="keywordflow">break</span>;
    }
    g_free (full_path_prefix);

    <span class="comment">/* No match. */</span>
    <span class="keywordflow">if</span> (i == pos) {
        <span class="keywordflow">if</span> (not_found)
            *not_found = TRUE;
        <span class="keywordflow">return</span> 0;
    }

    <span class="keywordflow">if</span> (i &lt; istate-&gt;cache_nr)
        memmove (istate-&gt;<a class="code" href="structindex__state.html#a8aa7a8aa984ec5a39ff2eee96412db07">cache</a> + pos,
                 istate-&gt;<a class="code" href="structindex__state.html#a8aa7a8aa984ec5a39ff2eee96412db07">cache</a> + i,
                 (istate-&gt;<a class="code" href="structindex__state.html#a15b38cdd30ad2374bc12da429f39312f">cache_nr</a> - i) * <span class="keyword">sizeof</span>(<span class="keyword">struct</span> <a class="code" href="structcache__entry.html">cache_entry</a> *));
    istate-&gt;<a class="code" href="structindex__state.html#a15b38cdd30ad2374bc12da429f39312f">cache_nr</a> -= (i - pos);
    istate-&gt;<a class="code" href="structindex__state.html#a8e22a9fe2486576488e72fe97801ebe5">cache_changed</a> = 1;

    <span class="keywordflow">return</span> 0;
}
</pre></div>
</div>
</div>
<a class="anchor" id="aae99b184a9d6c213a39042b5452081f9"></a><!-- doxytag: member="index.c::remove_index_entry_at" ref="aae99b184a9d6c213a39042b5452081f9" args="(struct index_state *istate, int pos)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="index_8h.html#a0e4ddc1ec8c4039bc06b09cff58995d3">remove_index_entry_at</a> </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structindex__state.html">index_state</a> *&#160;</td>
          <td class="paramname"><em>istate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>pos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="index_8c_source.html#l00724">724</a> of file <a class="el" href="index_8c_source.html">index.c</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="keyword">struct </span><a class="code" href="structcache__entry.html">cache_entry</a> *ce = istate-&gt;<a class="code" href="structindex__state.html#a8aa7a8aa984ec5a39ff2eee96412db07">cache</a>[pos];

    <span class="comment">/* record_resolve_undo(istate, ce); */</span>
    <a class="code" href="index_8c.html#a62df0f7f37866aabf0b0faf196fc0ddf">remove_name_hash</a>(istate, ce);
    <a class="code" href="index_8c.html#a156a4ea461fcf14e0b73755b02e7e7d1">cache_entry_free</a> (ce);
    istate-&gt;<a class="code" href="structindex__state.html#a8e22a9fe2486576488e72fe97801ebe5">cache_changed</a> = 1;
    istate-&gt;<a class="code" href="structindex__state.html#a15b38cdd30ad2374bc12da429f39312f">cache_nr</a>--;
    <span class="keywordflow">if</span> (pos &gt;= istate-&gt;<a class="code" href="structindex__state.html#a15b38cdd30ad2374bc12da429f39312f">cache_nr</a>)
        <span class="keywordflow">return</span> 0;
    memmove(istate-&gt;<a class="code" href="structindex__state.html#a8aa7a8aa984ec5a39ff2eee96412db07">cache</a> + pos,
            istate-&gt;<a class="code" href="structindex__state.html#a8aa7a8aa984ec5a39ff2eee96412db07">cache</a> + pos + 1,
            (istate-&gt;<a class="code" href="structindex__state.html#a15b38cdd30ad2374bc12da429f39312f">cache_nr</a> - pos) * <span class="keyword">sizeof</span>(<span class="keyword">struct</span> <a class="code" href="structcache__entry.html">cache_entry</a> *));
    <span class="keywordflow">return</span> 1;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a12825d79310dd67cd238e49161be5bfd"></a><!-- doxytag: member="index.c::remove_marked_cache_entries" ref="a12825d79310dd67cd238e49161be5bfd" args="(struct index_state *istate)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="index_8h.html#a12825d79310dd67cd238e49161be5bfd">remove_marked_cache_entries</a> </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structindex__state.html">index_state</a> *&#160;</td>
          <td class="paramname"><em>istate</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="index_8c_source.html#l00746">746</a> of file <a class="el" href="index_8c_source.html">index.c</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="keyword">struct </span><a class="code" href="structcache__entry.html">cache_entry</a> **ce_array = istate-&gt;<a class="code" href="structindex__state.html#a8aa7a8aa984ec5a39ff2eee96412db07">cache</a>;
    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i, j;

    <span class="keywordflow">for</span> (i = j = 0; i &lt; istate-&gt;<a class="code" href="structindex__state.html#a15b38cdd30ad2374bc12da429f39312f">cache_nr</a>; i++) {
        <span class="keywordflow">if</span> (ce_array[i]-&gt;<a class="code" href="structcache__entry.html#a4dab14fd813a1bb6b67352674ff4afb2">ce_flags</a> &amp; <a class="code" href="index_8h.html#aa5ee599d9d7af67f19dba204ce9030c0">CE_REMOVE</a>) {
            <a class="code" href="index_8c.html#a62df0f7f37866aabf0b0faf196fc0ddf">remove_name_hash</a>(istate, ce_array[i]);
            <a class="code" href="index_8c.html#a156a4ea461fcf14e0b73755b02e7e7d1">cache_entry_free</a> (ce_array[i]);
        } <span class="keywordflow">else</span> {
            ce_array[j++] = ce_array[i];
        }
    }
    istate-&gt;<a class="code" href="structindex__state.html#a8e22a9fe2486576488e72fe97801ebe5">cache_changed</a> = 1;
    istate-&gt;<a class="code" href="structindex__state.html#a15b38cdd30ad2374bc12da429f39312f">cache_nr</a> = j;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a62df0f7f37866aabf0b0faf196fc0ddf"></a><!-- doxytag: member="index.c::remove_name_hash" ref="a62df0f7f37866aabf0b0faf196fc0ddf" args="(struct index_state *istate, struct cache_entry *ce)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="index_8h.html#a62df0f7f37866aabf0b0faf196fc0ddf">remove_name_hash</a> </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structindex__state.html">index_state</a> *&#160;</td>
          <td class="paramname"><em>istate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structcache__entry.html">cache_entry</a> *&#160;</td>
          <td class="paramname"><em>ce</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="index_8c_source.html#l01978">1978</a> of file <a class="el" href="index_8c_source.html">index.c</a>.</p>
<div class="fragment"><pre class="fragment">{
    g_hash_table_remove (istate-&gt;<a class="code" href="structindex__state.html#ab30d2dde7a88b0d003ac7fc31952a376">name_hash</a>, ce-&gt;<a class="code" href="structcache__entry.html#a792e4ea24cb16c76abe3229651e414a0">name</a>);

<span class="preprocessor">#if defined WIN32 || defined __APPLE__</span>
<span class="preprocessor"></span>    <span class="keywordtype">char</span> *i_name = g_utf8_strdown (ce-&gt;<a class="code" href="structcache__entry.html#a792e4ea24cb16c76abe3229651e414a0">name</a>, -1);
    g_hash_table_remove (istate-&gt;i_name_hash, i_name);
    g_free (i_name);
<span class="preprocessor">#endif</span>
<span class="preprocessor"></span>}
</pre></div>
</div>
</div>
<a class="anchor" id="a56d1945a0677d925b25c610d613aeefc"></a><!-- doxytag: member="index.c::rename_index_entries" ref="a56d1945a0677d925b25c610d613aeefc" args="(struct index_state *istate, const char *src_path, const char *dst_path, gboolean *not_found)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="index_8h.html#a56d1945a0677d925b25c610d613aeefc">rename_index_entries</a> </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structindex__state.html">index_state</a> *&#160;</td>
          <td class="paramname"><em>istate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>src_path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>dst_path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gboolean *&#160;</td>
          <td class="paramname"><em>not_found</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="index_8c_source.html#l01366">1366</a> of file <a class="el" href="index_8c_source.html">index.c</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="keyword">struct </span><a class="code" href="structcache__entry.html">cache_entry</a> **new_ces;
    <span class="keywordtype">int</span> n_entries;
    <span class="keywordtype">int</span> ret = 0;
    <span class="keywordtype">int</span> i;

    <span class="keywordflow">if</span> (not_found)
        *not_found = FALSE;

    new_ces = create_renamed_cache_entries (istate, src_path, dst_path, &amp;n_entries);
    <span class="keywordflow">if</span> (n_entries == 0) {
        <span class="keywordflow">if</span> (not_found)
            *not_found = TRUE;
        <span class="keywordflow">return</span> 0;
    }

    <span class="comment">/* Remove entries under dst_path. It&#39;s necessary for the situation that</span>
<span class="comment">     * one file is renamed to overwrite another file.</span>
<span class="comment">     */</span>
    <a class="code" href="index_8c.html#a86bf1084dfc4e0057a52b4da1922de9b">remove_from_index_with_prefix</a> (istate, dst_path, NULL);

    <a class="code" href="index_8c.html#a21d6b0245750631144db52218a179633">remove_empty_parent_dir_entry</a> (istate, dst_path);

    <span class="comment">/* Insert the renamed entries to their position. */</span>
    <span class="keywordtype">int</span> dst_pathlen = strlen(dst_path);
    <span class="keywordtype">int</span> pos = <a class="code" href="index_8c.html#a1f5ad45bcfb5a2dcc3fae542fa293d4a">index_name_pos</a> (istate, dst_path, dst_pathlen);
    <span class="keywordflow">if</span> (pos &gt;= 0) {
        g_warning (<span class="stringliteral">&quot;BUG: %s should not exist in index after remove.\n&quot;</span>, dst_path);
        ret = -1;
        <span class="keywordflow">goto</span> out;
    }

    pos = -pos-1;

    <span class="comment">/* There should be at least n_entries free room in istate-&gt;cache array,</span>
<span class="comment">     * since we just removed n_entries from the index in</span>
<span class="comment">     * create_renamed_cache_entires(). </span>
<span class="comment">     */</span>
    <span class="keywordflow">if</span> (istate-&gt;<a class="code" href="structindex__state.html#aa092fb08928f22bc28e892ba163d3103">cache_alloc</a> - istate-&gt;<a class="code" href="structindex__state.html#a15b38cdd30ad2374bc12da429f39312f">cache_nr</a> &lt; n_entries) {
        g_warning (<span class="stringliteral">&quot;BUG: not enough room to insert renamed entries.\n&quot;</span>
                   <span class="stringliteral">&quot;cache_alloc: %u, cache_nr: %u, n_entries: %d.\n&quot;</span>,
                   istate-&gt;<a class="code" href="structindex__state.html#aa092fb08928f22bc28e892ba163d3103">cache_alloc</a>, istate-&gt;<a class="code" href="structindex__state.html#a15b38cdd30ad2374bc12da429f39312f">cache_nr</a>, n_entries);
        ret = -1;
        <span class="keywordflow">goto</span> out;
    }

    <span class="keywordflow">if</span> (pos &lt; istate-&gt;cache_nr)
        memmove (istate-&gt;<a class="code" href="structindex__state.html#a8aa7a8aa984ec5a39ff2eee96412db07">cache</a> + pos + n_entries,
                 istate-&gt;<a class="code" href="structindex__state.html#a8aa7a8aa984ec5a39ff2eee96412db07">cache</a> + pos,
                 (istate-&gt;<a class="code" href="structindex__state.html#a15b38cdd30ad2374bc12da429f39312f">cache_nr</a> - pos) * <span class="keyword">sizeof</span>(<span class="keyword">struct</span> <a class="code" href="structcache__entry.html">cache_entry</a> *));

    memcpy (istate-&gt;<a class="code" href="structindex__state.html#a8aa7a8aa984ec5a39ff2eee96412db07">cache</a> + pos, new_ces, n_entries * <span class="keyword">sizeof</span>(<span class="keyword">struct</span> <a class="code" href="structcache__entry.html">cache_entry</a> *));
    <span class="keywordflow">for</span> (i = 0; i &lt; n_entries; ++i)
        <a class="code" href="index_8c.html#a6807b08fb7e98733bcdc6b4207993524">add_name_hash</a> (istate, new_ces[i]);
    istate-&gt;<a class="code" href="structindex__state.html#a15b38cdd30ad2374bc12da429f39312f">cache_nr</a> += n_entries;
    istate-&gt;<a class="code" href="structindex__state.html#a8e22a9fe2486576488e72fe97801ebe5">cache_changed</a> = 1;

out:
    <span class="keywordflow">if</span> (ret &lt; 0) {
        <span class="keywordflow">for</span> (i = 0; i &lt; n_entries; ++i)
            <a class="code" href="index_8c.html#a156a4ea461fcf14e0b73755b02e7e7d1">cache_entry_free</a> (new_ces[i]);
    }
    free (new_ces);

    <span class="keywordflow">return</span> ret;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a177df5d9afa8392326c1a1cef68f08c0"></a><!-- doxytag: member="index.c::unmerged_index" ref="a177df5d9afa8392326c1a1cef68f08c0" args="(const struct index_state *istate)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="index_8h.html#adb97ed95dd5c3c043e0f1cdf05d0f667">unmerged_index</a> </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structindex__state.html">index_state</a> *&#160;</td>
          <td class="paramname"><em>istate</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="index_8c_source.html#l00408">408</a> of file <a class="el" href="index_8c_source.html">index.c</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="keywordtype">int</span> i;
    <span class="keywordflow">for</span> (i = 0; i &lt; istate-&gt;<a class="code" href="structindex__state.html#a15b38cdd30ad2374bc12da429f39312f">cache_nr</a>; i++) {
        <span class="keywordflow">if</span> (<a class="code" href="index_8h.html#a0379c411a3dc56c2d5ac0b1fcce22ead">ce_stage</a>(istate-&gt;<a class="code" href="structindex__state.html#a8aa7a8aa984ec5a39ff2eee96412db07">cache</a>[i]))
            <span class="keywordflow">return</span> 1;
    }
    <span class="keywordflow">return</span> 0;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a255f3c14715b9792f50ca3b2b600e91c"></a><!-- doxytag: member="index.c::verify_path" ref="a255f3c14715b9792f50ca3b2b600e91c" args="(const char *path)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="index_8h.html#a255f3c14715b9792f50ca3b2b600e91c">verify_path</a> </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="index_8c_source.html#l00844">844</a> of file <a class="el" href="index_8c_source.html">index.c</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="keywordtype">char</span> c;

    <span class="keywordflow">goto</span> inside;
    <span class="keywordflow">for</span> (;;) {
        <span class="keywordflow">if</span> (!c)
            <span class="keywordflow">return</span> 1;
        <span class="keywordflow">if</span> (c == <span class="charliteral">&#39;/&#39;</span>) {
        inside:
            c = *path++;
            <span class="keywordflow">switch</span> (c) {
            <span class="keywordflow">default</span>:
                <span class="keywordflow">continue</span>;
            <span class="keywordflow">case</span> <span class="charliteral">&#39;/&#39;</span>: <span class="keywordflow">case</span> <span class="charliteral">&#39;\0&#39;</span>:
                <span class="keywordflow">break</span>;
            <span class="keywordflow">case</span> <span class="charliteral">&#39;.&#39;</span>:
                <span class="keywordflow">if</span> (verify_dotfile(path))
                    <span class="keywordflow">continue</span>;
            }
            <span class="keywordflow">return</span> 0;
        }
        c = *path++;
    }
}
</pre></div>
</div>
</div>
<a class="anchor" id="a00594b344a866bd98aa1dad7d4a7b434"></a><!-- doxytag: member="index.c::write_index" ref="a00594b344a866bd98aa1dad7d4a7b434" args="(struct index_state *istate, int newfd)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="index_8h.html#aec9458995edf7bf9c6389908ab3366f5">write_index</a> </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structindex__state.html">index_state</a> *&#160;</td>
          <td class="paramname"><em>istate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>newfd</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="index_8c_source.html#l01881">1881</a> of file <a class="el" href="index_8c_source.html">index.c</a>.</p>
<div class="fragment"><pre class="fragment">{
    <a class="code" href="structWriteIndexInfo.html">WriteIndexInfo</a> info;
    <span class="keyword">struct </span><a class="code" href="structcache__header.html">cache_header</a> hdr;
    <span class="keywordtype">int</span> i, removed, extended;
    <span class="keyword">struct </span><a class="code" href="structcache__entry.html">cache_entry</a> **cache = istate-&gt;<a class="code" href="structindex__state.html#a8aa7a8aa984ec5a39ff2eee96412db07">cache</a>;
    <span class="keywordtype">int</span> entries = istate-&gt;<a class="code" href="structindex__state.html#a15b38cdd30ad2374bc12da429f39312f">cache_nr</a>;
    <a class="code" href="seafile_2lib_2utils_8h.html#a5b073bcbe1516b249924c3702002d32c">SeafStat</a> st;

    memset (&amp;info, 0, <span class="keyword">sizeof</span>(info));

    <span class="keywordflow">for</span> (i = removed = extended = 0; i &lt; entries; i++) {
        <span class="keywordflow">if</span> (cache[i]-&gt;<a class="code" href="structcache__entry.html#a4dab14fd813a1bb6b67352674ff4afb2">ce_flags</a> &amp; <a class="code" href="index_8h.html#aa5ee599d9d7af67f19dba204ce9030c0">CE_REMOVE</a>)
            removed++;

        <span class="comment">/* reduce extended entries if possible */</span>
        <span class="comment">/* cache[i]-&gt;ce_flags &amp;= ~CE_EXTENDED; */</span>
        <span class="comment">/* if (cache[i]-&gt;ce_flags &amp; CE_EXTENDED_FLAGS) { */</span>
        <span class="comment">/*     extended++; */</span>
        <span class="comment">/*     cache[i]-&gt;ce_flags |= CE_EXTENDED; */</span>
        <span class="comment">/* } */</span>
    }

    hdr.hdr_signature = htonl(<a class="code" href="index_8h.html#a1df97b2e673364fd2f0d469e21b1c4e4">CACHE_SIGNATURE</a>);
    <span class="comment">/* Always use version 4 for newly created index files */</span>
    hdr.hdr_version = htonl(4);
    hdr.hdr_entries = htonl(entries - removed);

    SHA1_Init(&amp;info.<a class="code" href="structWriteIndexInfo.html#ae9b01f6b1a14788da78b63ce09354a6b">context</a>);
    <span class="keywordflow">if</span> (ce_write(&amp;info, newfd, &amp;hdr, <span class="keyword">sizeof</span>(hdr)) &lt; 0)
        <span class="keywordflow">return</span> -1;

    <span class="keywordflow">for</span> (i = 0; i &lt; entries; i++) {
        <span class="keyword">struct </span><a class="code" href="structcache__entry.html">cache_entry</a> *ce = cache[i];
        <span class="keywordflow">if</span> (ce-&gt;<a class="code" href="structcache__entry.html#a4dab14fd813a1bb6b67352674ff4afb2">ce_flags</a> &amp; <a class="code" href="index_8h.html#aa5ee599d9d7af67f19dba204ce9030c0">CE_REMOVE</a>)
            <span class="keywordflow">continue</span>;
        <span class="comment">/* if (!ce_uptodate(ce) &amp;&amp; is_racy_timestamp(istate, ce)) */</span>
        <span class="comment">/*     ce_smudge_racily_clean_entry(ce); */</span>
        <span class="keywordflow">if</span> (ce_write_entry2(&amp;info, newfd, ce) &lt; 0)
            <span class="keywordflow">return</span> -1;
    }

    <span class="comment">/* Write extension data here */</span>
    <span class="keywordflow">if</span> (istate-&gt;<a class="code" href="structindex__state.html#ac5f843973ed4eba3c6370ae193ac97a9">has_modifier</a>) {
        GString *buf = g_string_new (<span class="stringliteral">&quot;&quot;</span>);
        <span class="keywordtype">int</span> err;

        <span class="keywordflow">if</span> (modifiers_to_string (buf, istate) &lt; 0) {
            g_string_free (buf, TRUE);
            <span class="keywordflow">return</span> -1;
        }

        err = write_index_ext_header(&amp;info, newfd, <a class="code" href="index_8h.html#aac01f026b0dad25cdade5134d4870190">CACHE_EXT_MODIFIER</a>, buf-&gt;len) &lt; 0
            || ce_write(&amp;info, newfd, buf-&gt;str, buf-&gt;len) &lt; 0;
        g_string_free (buf, TRUE);
        <span class="keywordflow">if</span> (err)
            <span class="keywordflow">return</span> -1;
    }

    <span class="keywordflow">if</span> (ce_flush(&amp;info, newfd) || <a class="code" href="seafile_2lib_2utils_8c.html#a09f0677ad28b98b7a85bcda57f71e7c8">seaf_fstat</a>(newfd, &amp;st))
        <span class="keywordflow">return</span> -1;
    istate-&gt;<a class="code" href="structindex__state.html#aba21746d004309949f3af631aced813a">timestamp</a>.<a class="code" href="structcache__time.html#ad79ea7590f31a5cc560ab4809d31562d">sec</a> = (<span class="keywordtype">unsigned</span> int)st.st_mtime;
    istate-&gt;<a class="code" href="structindex__state.html#aba21746d004309949f3af631aced813a">timestamp</a>.<a class="code" href="structcache__time.html#acb016b82c22470ffc173985cd88d1389">nsec</a> = 0;
    <span class="keywordflow">return</span> 0;
}
</pre></div>
</div>
</div>
</div><!-- contents -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>



<hr class="footer"/><address class="footer"><small>
Generated on Wed Aug 19 2015 03:19:05 for My Project by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.7.6.1
</small></address>

</body>
</html>

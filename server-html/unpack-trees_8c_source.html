<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>My Project: seafile/common/unpack-trees.c Source File</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />

<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>

</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">My Project
   
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.6.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>File&#160;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="headertitle">
<div class="title">seafile/common/unpack-trees.c</div>  </div>
</div><!--header-->
<div class="contents">
<a href="unpack-trees_8c.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">/* -*- Mode: C; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */</span>
<a name="l00002"></a>00002 
<a name="l00003"></a>00003 <span class="preprocessor">#include &quot;<a class="code" href="seafile_2common_2common_8h.html">common.h</a>&quot;</span>
<a name="l00004"></a>00004 <span class="preprocessor">#include &quot;<a class="code" href="seaf-tree-walk_8h.html">seaf-tree-walk.h</a>&quot;</span>
<a name="l00005"></a>00005 <span class="comment">/* #include &quot;cache-tree.h&quot; */</span>
<a name="l00006"></a>00006 <span class="preprocessor">#include &quot;<a class="code" href="unpack-trees_8h.html">unpack-trees.h</a>&quot;</span>
<a name="l00007"></a>00007 <span class="comment">/* #include &quot;vc-utils.h&quot; */</span>
<a name="l00008"></a>00008 
<a name="l00009"></a>00009 <span class="keyword">static</span> <span class="keywordtype">void</span> add_entry(<span class="keyword">struct</span> <a class="code" href="structunpack__trees__options.html">unpack_trees_options</a> *o, <span class="keyword">struct</span> <a class="code" href="structcache__entry.html">cache_entry</a> *ce,
<a name="l00010"></a>00010                       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <span class="keyword">set</span>, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> clear)
<a name="l00011"></a>00011 {
<a name="l00012"></a>00012     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="index_8h.html#af931a8871310b4dad23f0f0b0f623560">size</a> = <a class="code" href="index_8h.html#acde7ea7616605cb5336badf6884a87ca">ce_size</a>(ce);
<a name="l00013"></a>00013     <span class="keyword">struct </span><a class="code" href="structcache__entry.html">cache_entry</a> *<span class="keyword">new</span> = malloc(size);
<a name="l00014"></a>00014 
<a name="l00015"></a>00015     clear |= <a class="code" href="index_8h.html#a4c6ac242046e51f8bd8a82fd7ba586cd">CE_HASHED</a> | <a class="code" href="index_8h.html#a5808b104dc5c393d448471d68841eae7">CE_UNHASHED</a>;
<a name="l00016"></a>00016 
<a name="l00017"></a>00017     <span class="keywordflow">if</span> (<span class="keyword">set</span> &amp; <a class="code" href="index_8h.html#aa5ee599d9d7af67f19dba204ce9030c0">CE_REMOVE</a>)
<a name="l00018"></a>00018         <span class="keyword">set</span> |= <a class="code" href="index_8h.html#ab8db831d893aba29775bf7251661296b">CE_WT_REMOVE</a>;
<a name="l00019"></a>00019 
<a name="l00020"></a>00020     memcpy(<span class="keyword">new</span>, ce, size);
<a name="l00021"></a>00021     <span class="keyword">new</span>-&gt;next = NULL;
<a name="l00022"></a>00022     <span class="keyword">new</span>-&gt;ce_flags = (<span class="keyword">new</span>-&gt;ce_flags &amp; ~clear) | <span class="keyword">set</span>;
<a name="l00023"></a>00023     <span class="keyword">new</span>-&gt;modifier = g_strdup(ce-&gt;<a class="code" href="structcache__entry.html#a786aa5bc6234542fe202023bcf721afd">modifier</a>);
<a name="l00024"></a>00024     <a class="code" href="index_8c.html#afafdfbe15ca205599303d6e2230886c0">add_index_entry</a>(&amp;o-&gt;<a class="code" href="structunpack__trees__options.html#a091d6e59892b9009809e45dfb38c24da">result</a>, <span class="keyword">new</span>, <a class="code" href="index_8h.html#a4e7659151088d67c163cc90e6f12c39c">ADD_CACHE_OK_TO_ADD</a>|<a class="code" href="index_8h.html#a6b5725eef5481c5f354df57bd32a4d87">ADD_CACHE_OK_TO_REPLACE</a>);
<a name="l00025"></a>00025 }
<a name="l00026"></a>00026 
<a name="l00027"></a>00027 <span class="comment">/*</span>
<a name="l00028"></a>00028 <span class="comment"> * add error messages on path &lt;path&gt;</span>
<a name="l00029"></a>00029 <span class="comment"> * corresponding to the type &lt;e&gt; with the message &lt;msg&gt;</span>
<a name="l00030"></a>00030 <span class="comment"> * indicating if it should be display in porcelain or not</span>
<a name="l00031"></a>00031 <span class="comment"> */</span>
<a name="l00032"></a>00032 <span class="keyword">static</span> <span class="keywordtype">int</span> add_rejected_path(<span class="keyword">struct</span> <a class="code" href="structunpack__trees__options.html">unpack_trees_options</a> *o,
<a name="l00033"></a>00033                              <span class="keyword">enum</span> <a class="code" href="unpack-trees_8h.html#ad2203a7733606ab3a15e195914f9d90d">unpack_trees_error_types</a> e,
<a name="l00034"></a>00034                              <span class="keyword">const</span> <span class="keywordtype">char</span> *path)
<a name="l00035"></a>00035 {
<a name="l00036"></a>00036     o-&gt;<a class="code" href="structunpack__trees__options.html#a423e136b07515c8f4736a23e74334b64">unpack_rejects</a>[e] = g_list_prepend(o-&gt;<a class="code" href="structunpack__trees__options.html#a423e136b07515c8f4736a23e74334b64">unpack_rejects</a>[e], g_strdup(path));
<a name="l00037"></a>00037     <span class="keywordflow">return</span> -1;
<a name="l00038"></a>00038 }
<a name="l00039"></a>00039 
<a name="l00040"></a>00040 <span class="preprocessor">#if 0</span>
<a name="l00041"></a>00041 <span class="preprocessor"></span><span class="comment">/*</span>
<a name="l00042"></a>00042 <span class="comment"> * Unlink the last component and schedule the leading directories for</span>
<a name="l00043"></a>00043 <span class="comment"> * removal, such that empty directories get removed.</span>
<a name="l00044"></a>00044 <span class="comment"> */</span>
<a name="l00045"></a>00045 <span class="keyword">static</span> <span class="keywordtype">void</span> unlink_entry(<span class="keyword">struct</span> <a class="code" href="structcache__entry.html">cache_entry</a> *ce)
<a name="l00046"></a>00046 {
<a name="l00047"></a>00047     <span class="keywordflow">if</span> (!check_leading_path(ce-&gt;<a class="code" href="structcache__entry.html#a792e4ea24cb16c76abe3229651e414a0">name</a>, ce_namelen(ce)))
<a name="l00048"></a>00048         <span class="keywordflow">return</span>;
<a name="l00049"></a>00049     <span class="keywordflow">if</span> (remove_or_warn(ce-&gt;<a class="code" href="structcache__entry.html#a5fcbcc4e7265ae8150f136380ed92c05">ce_mode</a>, ce-&gt;<a class="code" href="structcache__entry.html#a792e4ea24cb16c76abe3229651e414a0">name</a>))
<a name="l00050"></a>00050         <span class="keywordflow">return</span>;
<a name="l00051"></a>00051     schedule_dir_for_removal(ce-&gt;<a class="code" href="structcache__entry.html#a792e4ea24cb16c76abe3229651e414a0">name</a>, ce_namelen(ce));
<a name="l00052"></a>00052 }
<a name="l00053"></a>00053 
<a name="l00054"></a>00054 <span class="keyword">static</span> <span class="keyword">struct </span>checkout state;
<a name="l00055"></a>00055 <span class="keyword">static</span> <span class="keywordtype">int</span> check_updates(<span class="keyword">struct</span> <a class="code" href="structunpack__trees__options.html">unpack_trees_options</a> *o)
<a name="l00056"></a>00056 {
<a name="l00057"></a>00057     <span class="keywordtype">unsigned</span> cnt = 0, total = 0;
<a name="l00058"></a>00058     <span class="keyword">struct </span>progress *progress = NULL;
<a name="l00059"></a>00059     <span class="keyword">struct </span><a class="code" href="structindex__state.html">index_state</a> *index = &amp;o-&gt;<a class="code" href="structunpack__trees__options.html#a091d6e59892b9009809e45dfb38c24da">result</a>;
<a name="l00060"></a>00060     <span class="keywordtype">int</span> i;
<a name="l00061"></a>00061     <span class="keywordtype">int</span> errs = 0;
<a name="l00062"></a>00062 
<a name="l00063"></a>00063     <span class="keywordflow">if</span> (o-&gt;<a class="code" href="structunpack__trees__options.html#a41b55dd4c6ef32c4938cc1b53936aacf">update</a> &amp;&amp; o-&gt;<a class="code" href="structunpack__trees__options.html#a90508a87b1070ef3a68d410c50982aac">verbose_update</a>) {
<a name="l00064"></a>00064         <span class="keywordflow">for</span> (total = cnt = 0; cnt &lt; index-&gt;<a class="code" href="structindex__state.html#a15b38cdd30ad2374bc12da429f39312f">cache_nr</a>; cnt++) {
<a name="l00065"></a>00065             <span class="keyword">struct </span><a class="code" href="structcache__entry.html">cache_entry</a> *ce = index-&gt;<a class="code" href="structindex__state.html#a8aa7a8aa984ec5a39ff2eee96412db07">cache</a>[cnt];
<a name="l00066"></a>00066             <span class="keywordflow">if</span> (ce-&gt;<a class="code" href="structcache__entry.html#a4dab14fd813a1bb6b67352674ff4afb2">ce_flags</a> &amp; (<a class="code" href="index_8h.html#a1d46becf22e28d6f8bffa8ee949acb45">CE_UPDATE</a> | <a class="code" href="index_8h.html#ab8db831d893aba29775bf7251661296b">CE_WT_REMOVE</a>))
<a name="l00067"></a>00067                 total++;
<a name="l00068"></a>00068         }
<a name="l00069"></a>00069 
<a name="l00070"></a>00070         progress = start_progress_delay(<span class="stringliteral">&quot;Checking out files&quot;</span>,
<a name="l00071"></a>00071                                         total, 50, 1);
<a name="l00072"></a>00072         cnt = 0;
<a name="l00073"></a>00073     }
<a name="l00074"></a>00074 
<a name="l00075"></a>00075     <span class="keywordflow">if</span> (o-&gt;<a class="code" href="structunpack__trees__options.html#a41b55dd4c6ef32c4938cc1b53936aacf">update</a>)
<a name="l00076"></a>00076         git_attr_set_direction(GIT_ATTR_CHECKOUT, &amp;o-&gt;<a class="code" href="structunpack__trees__options.html#a091d6e59892b9009809e45dfb38c24da">result</a>);
<a name="l00077"></a>00077     <span class="keywordflow">for</span> (i = 0; i &lt; index-&gt;<a class="code" href="structindex__state.html#a15b38cdd30ad2374bc12da429f39312f">cache_nr</a>; i++) {
<a name="l00078"></a>00078         <span class="keyword">struct </span><a class="code" href="structcache__entry.html">cache_entry</a> *ce = index-&gt;<a class="code" href="structindex__state.html#a8aa7a8aa984ec5a39ff2eee96412db07">cache</a>[i];
<a name="l00079"></a>00079 
<a name="l00080"></a>00080         <span class="keywordflow">if</span> (ce-&gt;<a class="code" href="structcache__entry.html#a4dab14fd813a1bb6b67352674ff4afb2">ce_flags</a> &amp; <a class="code" href="index_8h.html#ab8db831d893aba29775bf7251661296b">CE_WT_REMOVE</a>) {
<a name="l00081"></a>00081             display_progress(progress, ++cnt);
<a name="l00082"></a>00082             <span class="keywordflow">if</span> (o-&gt;<a class="code" href="structunpack__trees__options.html#a41b55dd4c6ef32c4938cc1b53936aacf">update</a>)
<a name="l00083"></a>00083                 unlink_entry(ce);
<a name="l00084"></a>00084             <span class="keywordflow">continue</span>;
<a name="l00085"></a>00085         }
<a name="l00086"></a>00086     }
<a name="l00087"></a>00087     <a class="code" href="index_8c.html#a12825d79310dd67cd238e49161be5bfd">remove_marked_cache_entries</a>(&amp;o-&gt;<a class="code" href="structunpack__trees__options.html#a091d6e59892b9009809e45dfb38c24da">result</a>);
<a name="l00088"></a>00088     remove_scheduled_dirs();
<a name="l00089"></a>00089 
<a name="l00090"></a>00090     <span class="keywordflow">for</span> (i = 0; i &lt; index-&gt;<a class="code" href="structindex__state.html#a15b38cdd30ad2374bc12da429f39312f">cache_nr</a>; i++) {
<a name="l00091"></a>00091         <span class="keyword">struct </span><a class="code" href="structcache__entry.html">cache_entry</a> *ce = index-&gt;<a class="code" href="structindex__state.html#a8aa7a8aa984ec5a39ff2eee96412db07">cache</a>[i];
<a name="l00092"></a>00092 
<a name="l00093"></a>00093         <span class="keywordflow">if</span> (ce-&gt;<a class="code" href="structcache__entry.html#a4dab14fd813a1bb6b67352674ff4afb2">ce_flags</a> &amp; <a class="code" href="index_8h.html#a1d46becf22e28d6f8bffa8ee949acb45">CE_UPDATE</a>) {
<a name="l00094"></a>00094             display_progress(progress, ++cnt);
<a name="l00095"></a>00095             ce-&gt;<a class="code" href="structcache__entry.html#a4dab14fd813a1bb6b67352674ff4afb2">ce_flags</a> &amp;= ~<a class="code" href="index_8h.html#a1d46becf22e28d6f8bffa8ee949acb45">CE_UPDATE</a>;
<a name="l00096"></a>00096             <span class="keywordflow">if</span> (o-&gt;<a class="code" href="structunpack__trees__options.html#a41b55dd4c6ef32c4938cc1b53936aacf">update</a>) {
<a name="l00097"></a>00097                 errs |= checkout_entry(ce, &amp;state, NULL);
<a name="l00098"></a>00098             }
<a name="l00099"></a>00099         }
<a name="l00100"></a>00100     }
<a name="l00101"></a>00101     stop_progress(&amp;progress);
<a name="l00102"></a>00102     <span class="keywordflow">if</span> (o-&gt;<a class="code" href="structunpack__trees__options.html#a41b55dd4c6ef32c4938cc1b53936aacf">update</a>)
<a name="l00103"></a>00103         git_attr_set_direction(GIT_ATTR_CHECKIN, NULL);
<a name="l00104"></a>00104     <span class="keywordflow">return</span> errs != 0;
<a name="l00105"></a>00105 }
<a name="l00106"></a>00106 <span class="preprocessor">#endif</span>
<a name="l00107"></a>00107 <span class="preprocessor"></span>
<a name="l00108"></a>00108 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> call_unpack_fn(<span class="keyword">struct</span> <a class="code" href="structcache__entry.html">cache_entry</a> **src, <span class="keyword">struct</span> <a class="code" href="structunpack__trees__options.html">unpack_trees_options</a> *o)
<a name="l00109"></a>00109 {
<a name="l00110"></a>00110     <span class="keywordtype">int</span> ret = o-&gt;<a class="code" href="structunpack__trees__options.html#adb26db5d8b826c55137939df5122c859">fn</a>(src, o);
<a name="l00111"></a>00111     <span class="keywordflow">if</span> (ret &gt; 0)
<a name="l00112"></a>00112         ret = 0;
<a name="l00113"></a>00113     <span class="keywordflow">return</span> ret;
<a name="l00114"></a>00114 }
<a name="l00115"></a>00115 
<a name="l00116"></a>00116 <span class="keyword">static</span> <span class="keywordtype">void</span> mark_ce_used(<span class="keyword">struct</span> <a class="code" href="structcache__entry.html">cache_entry</a> *ce, <span class="keyword">struct</span> <a class="code" href="structunpack__trees__options.html">unpack_trees_options</a> *o)
<a name="l00117"></a>00117 {
<a name="l00118"></a>00118     ce-&gt;<a class="code" href="structcache__entry.html#a4dab14fd813a1bb6b67352674ff4afb2">ce_flags</a> |= <a class="code" href="index_8h.html#ab9f9391faf6b3de1d55d71cb07417d0e">CE_UNPACKED</a>;
<a name="l00119"></a>00119 
<a name="l00120"></a>00120     <span class="keywordflow">if</span> (o-&gt;<a class="code" href="structunpack__trees__options.html#a0489ef1bdaa94d6ff0706167005ed557">cache_bottom</a> &lt; o-&gt;<a class="code" href="structunpack__trees__options.html#a5781bfdf9479b84caf218a475e48476c">src_index</a>-&gt;<a class="code" href="structindex__state.html#a15b38cdd30ad2374bc12da429f39312f">cache_nr</a> &amp;&amp;
<a name="l00121"></a>00121         o-&gt;<a class="code" href="structunpack__trees__options.html#a5781bfdf9479b84caf218a475e48476c">src_index</a>-&gt;<a class="code" href="structindex__state.html#a8aa7a8aa984ec5a39ff2eee96412db07">cache</a>[o-&gt;<a class="code" href="structunpack__trees__options.html#a0489ef1bdaa94d6ff0706167005ed557">cache_bottom</a>] == ce) {
<a name="l00122"></a>00122         <span class="keywordtype">int</span> bottom = o-&gt;<a class="code" href="structunpack__trees__options.html#a0489ef1bdaa94d6ff0706167005ed557">cache_bottom</a>;
<a name="l00123"></a>00123         <span class="keywordflow">while</span> (bottom &lt; o-&gt;src_index-&gt;cache_nr &amp;&amp;
<a name="l00124"></a>00124                o-&gt;<a class="code" href="structunpack__trees__options.html#a5781bfdf9479b84caf218a475e48476c">src_index</a>-&gt;<a class="code" href="structindex__state.html#a8aa7a8aa984ec5a39ff2eee96412db07">cache</a>[bottom]-&gt;<a class="code" href="structcache__entry.html#a4dab14fd813a1bb6b67352674ff4afb2">ce_flags</a> &amp; <a class="code" href="index_8h.html#ab9f9391faf6b3de1d55d71cb07417d0e">CE_UNPACKED</a>)
<a name="l00125"></a>00125             bottom++;
<a name="l00126"></a>00126         o-&gt;<a class="code" href="structunpack__trees__options.html#a0489ef1bdaa94d6ff0706167005ed557">cache_bottom</a> = bottom;
<a name="l00127"></a>00127     }
<a name="l00128"></a>00128 }
<a name="l00129"></a>00129 
<a name="l00130"></a>00130 <span class="keyword">static</span> <span class="keywordtype">int</span> locate_in_src_index(<span class="keyword">struct</span> <a class="code" href="structcache__entry.html">cache_entry</a> *ce,
<a name="l00131"></a>00131                                <span class="keyword">struct</span> <a class="code" href="structunpack__trees__options.html">unpack_trees_options</a> *o)
<a name="l00132"></a>00132 {
<a name="l00133"></a>00133     <span class="keyword">struct </span><a class="code" href="structindex__state.html">index_state</a> *index = o-&gt;<a class="code" href="structunpack__trees__options.html#a5781bfdf9479b84caf218a475e48476c">src_index</a>;
<a name="l00134"></a>00134     <span class="keywordtype">int</span> len = ce_namelen(ce);
<a name="l00135"></a>00135     <span class="keywordtype">int</span> pos = <a class="code" href="index_8c.html#a1f5ad45bcfb5a2dcc3fae542fa293d4a">index_name_pos</a>(index, ce-&gt;<a class="code" href="structcache__entry.html#a792e4ea24cb16c76abe3229651e414a0">name</a>, len);
<a name="l00136"></a>00136     <span class="keywordflow">if</span> (pos &lt; 0)
<a name="l00137"></a>00137         pos = -1 - pos;
<a name="l00138"></a>00138     <span class="keywordflow">return</span> pos;
<a name="l00139"></a>00139 }
<a name="l00140"></a>00140 
<a name="l00141"></a>00141 <span class="comment">/*</span>
<a name="l00142"></a>00142 <span class="comment"> * We call unpack_index_entry() with an unmerged cache entry</span>
<a name="l00143"></a>00143 <span class="comment"> * only in diff-index, and it wants a single callback.  Skip</span>
<a name="l00144"></a>00144 <span class="comment"> * the other unmerged entry with the same name.</span>
<a name="l00145"></a>00145 <span class="comment"> */</span>
<a name="l00146"></a>00146 <span class="keyword">static</span> <span class="keywordtype">void</span> mark_ce_used_same_name(<span class="keyword">struct</span> <a class="code" href="structcache__entry.html">cache_entry</a> *ce,
<a name="l00147"></a>00147                                    <span class="keyword">struct</span> <a class="code" href="structunpack__trees__options.html">unpack_trees_options</a> *o)
<a name="l00148"></a>00148 {
<a name="l00149"></a>00149     <span class="keyword">struct </span><a class="code" href="structindex__state.html">index_state</a> *index = o-&gt;<a class="code" href="structunpack__trees__options.html#a5781bfdf9479b84caf218a475e48476c">src_index</a>;
<a name="l00150"></a>00150     <span class="keywordtype">int</span> len = ce_namelen(ce);
<a name="l00151"></a>00151     <span class="keywordtype">int</span> pos;
<a name="l00152"></a>00152 
<a name="l00153"></a>00153     <span class="keywordflow">for</span> (pos = locate_in_src_index(ce, o); pos &lt; index-&gt;<a class="code" href="structindex__state.html#a15b38cdd30ad2374bc12da429f39312f">cache_nr</a>; pos++) {
<a name="l00154"></a>00154         <span class="keyword">struct </span><a class="code" href="structcache__entry.html">cache_entry</a> *<a class="code" href="structcache__entry.html#afd4bec9067a7e0c76158d32a9d287684">next</a> = index-&gt;<a class="code" href="structindex__state.html#a8aa7a8aa984ec5a39ff2eee96412db07">cache</a>[pos];
<a name="l00155"></a>00155         <span class="keywordflow">if</span> (len != ce_namelen(next) ||
<a name="l00156"></a>00156             memcmp(ce-&gt;<a class="code" href="structcache__entry.html#a792e4ea24cb16c76abe3229651e414a0">name</a>, next-&gt;<a class="code" href="structcache__entry.html#a792e4ea24cb16c76abe3229651e414a0">name</a>, len))
<a name="l00157"></a>00157             <span class="keywordflow">break</span>;
<a name="l00158"></a>00158         mark_ce_used(next, o);
<a name="l00159"></a>00159     }
<a name="l00160"></a>00160 }
<a name="l00161"></a>00161 
<a name="l00162"></a>00162 <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structcache__entry.html">cache_entry</a> *next_cache_entry(<span class="keyword">struct</span> <a class="code" href="structunpack__trees__options.html">unpack_trees_options</a> *o)
<a name="l00163"></a>00163 {
<a name="l00164"></a>00164     <span class="keyword">const</span> <span class="keyword">struct </span><a class="code" href="structindex__state.html">index_state</a> *index = o-&gt;<a class="code" href="structunpack__trees__options.html#a5781bfdf9479b84caf218a475e48476c">src_index</a>;
<a name="l00165"></a>00165     <span class="keywordtype">int</span> pos = o-&gt;<a class="code" href="structunpack__trees__options.html#a0489ef1bdaa94d6ff0706167005ed557">cache_bottom</a>;
<a name="l00166"></a>00166 
<a name="l00167"></a>00167     <span class="keywordflow">while</span> (pos &lt; index-&gt;<a class="code" href="structindex__state.html#a15b38cdd30ad2374bc12da429f39312f">cache_nr</a>) {
<a name="l00168"></a>00168         <span class="keyword">struct </span><a class="code" href="structcache__entry.html">cache_entry</a> *ce = index-&gt;<a class="code" href="structindex__state.html#a8aa7a8aa984ec5a39ff2eee96412db07">cache</a>[pos];
<a name="l00169"></a>00169         <span class="keywordflow">if</span> (!(ce-&gt;<a class="code" href="structcache__entry.html#a4dab14fd813a1bb6b67352674ff4afb2">ce_flags</a> &amp; <a class="code" href="index_8h.html#ab9f9391faf6b3de1d55d71cb07417d0e">CE_UNPACKED</a>))
<a name="l00170"></a>00170             <span class="keywordflow">return</span> ce;
<a name="l00171"></a>00171         pos++;
<a name="l00172"></a>00172     }
<a name="l00173"></a>00173     <span class="keywordflow">return</span> NULL;
<a name="l00174"></a>00174 }
<a name="l00175"></a>00175 
<a name="l00176"></a>00176 <span class="keyword">static</span> <span class="keywordtype">void</span> add_same_unmerged(<span class="keyword">struct</span> <a class="code" href="structcache__entry.html">cache_entry</a> *ce,
<a name="l00177"></a>00177                               <span class="keyword">struct</span> <a class="code" href="structunpack__trees__options.html">unpack_trees_options</a> *o)
<a name="l00178"></a>00178 {
<a name="l00179"></a>00179     <span class="keyword">struct </span><a class="code" href="structindex__state.html">index_state</a> *index = o-&gt;<a class="code" href="structunpack__trees__options.html#a5781bfdf9479b84caf218a475e48476c">src_index</a>;
<a name="l00180"></a>00180     <span class="keywordtype">int</span> len = ce_namelen(ce);
<a name="l00181"></a>00181     <span class="keywordtype">int</span> pos = <a class="code" href="index_8c.html#a1f5ad45bcfb5a2dcc3fae542fa293d4a">index_name_pos</a>(index, ce-&gt;<a class="code" href="structcache__entry.html#a792e4ea24cb16c76abe3229651e414a0">name</a>, len);
<a name="l00182"></a>00182 
<a name="l00183"></a>00183     <span class="keywordflow">if</span> (0 &lt;= pos) {
<a name="l00184"></a>00184         g_error(<span class="stringliteral">&quot;programming error in a caller of mark_ce_used_same_name&quot;</span>);
<a name="l00185"></a>00185     }
<a name="l00186"></a>00186     <span class="keywordflow">for</span> (pos = -pos - 1; pos &lt; index-&gt;<a class="code" href="structindex__state.html#a15b38cdd30ad2374bc12da429f39312f">cache_nr</a>; pos++) {
<a name="l00187"></a>00187         <span class="keyword">struct </span><a class="code" href="structcache__entry.html">cache_entry</a> *next = index-&gt;<a class="code" href="structindex__state.html#a8aa7a8aa984ec5a39ff2eee96412db07">cache</a>[pos];
<a name="l00188"></a>00188         <span class="keywordflow">if</span> (len != ce_namelen(next) ||
<a name="l00189"></a>00189             memcmp(ce-&gt;<a class="code" href="structcache__entry.html#a792e4ea24cb16c76abe3229651e414a0">name</a>, next-&gt;<a class="code" href="structcache__entry.html#a792e4ea24cb16c76abe3229651e414a0">name</a>, len))
<a name="l00190"></a>00190             <span class="keywordflow">break</span>;
<a name="l00191"></a>00191         add_entry(o, next, 0, 0);
<a name="l00192"></a>00192         mark_ce_used(next, o);
<a name="l00193"></a>00193     }
<a name="l00194"></a>00194 }
<a name="l00195"></a>00195 
<a name="l00196"></a>00196 <span class="keyword">static</span> <span class="keywordtype">int</span> unpack_index_entry(<span class="keyword">struct</span> <a class="code" href="structcache__entry.html">cache_entry</a> *ce,
<a name="l00197"></a>00197                               <span class="keyword">struct</span> <a class="code" href="structunpack__trees__options.html">unpack_trees_options</a> *o)
<a name="l00198"></a>00198 {
<a name="l00199"></a>00199     <span class="keyword">struct </span><a class="code" href="structcache__entry.html">cache_entry</a> *src[5] = { NULL };
<a name="l00200"></a>00200     <span class="keywordtype">int</span> ret;
<a name="l00201"></a>00201 
<a name="l00202"></a>00202     src[0] = ce;
<a name="l00203"></a>00203 
<a name="l00204"></a>00204     mark_ce_used(ce, o);
<a name="l00205"></a>00205     <span class="keywordflow">if</span> (<a class="code" href="index_8h.html#a0379c411a3dc56c2d5ac0b1fcce22ead">ce_stage</a>(ce)) {
<a name="l00206"></a>00206         <span class="keywordflow">if</span> (o-&gt;<a class="code" href="structunpack__trees__options.html#ae9ca31035bd0ccf93e132adf3fc15773">skip_unmerged</a>) {
<a name="l00207"></a>00207             add_entry(o, ce, 0, 0);
<a name="l00208"></a>00208             <span class="keywordflow">return</span> 0;
<a name="l00209"></a>00209         }
<a name="l00210"></a>00210     }
<a name="l00211"></a>00211     ret = call_unpack_fn(src, o);
<a name="l00212"></a>00212     <span class="keywordflow">if</span> (<a class="code" href="index_8h.html#a0379c411a3dc56c2d5ac0b1fcce22ead">ce_stage</a>(ce))
<a name="l00213"></a>00213         mark_ce_used_same_name(ce, o);
<a name="l00214"></a>00214     <span class="keywordflow">return</span> ret;
<a name="l00215"></a>00215 }
<a name="l00216"></a>00216 
<a name="l00217"></a>00217 <span class="keyword">static</span> <span class="keywordtype">int</span> find_cache_pos(<span class="keyword">struct</span> <a class="code" href="structtraverse__info.html">traverse_info</a> *, <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structname__entry.html">name_entry</a> *);
<a name="l00218"></a>00218 
<a name="l00219"></a>00219 <span class="keyword">static</span> <span class="keywordtype">void</span> restore_cache_bottom(<span class="keyword">struct</span> <a class="code" href="structtraverse__info.html">traverse_info</a> *info, <span class="keywordtype">int</span> bottom)
<a name="l00220"></a>00220 {
<a name="l00221"></a>00221     <span class="keyword">struct </span><a class="code" href="structunpack__trees__options.html">unpack_trees_options</a> *o = info-&gt;<a class="code" href="structtraverse__info.html#a5a00856984e92cdd07a1280f9cd014cc">data</a>;
<a name="l00222"></a>00222 
<a name="l00223"></a>00223     <span class="keywordflow">if</span> (o-&gt;<a class="code" href="structunpack__trees__options.html#a09662cb6d5c5edae259ce33f6a61c1d8">diff_index_cached</a>)
<a name="l00224"></a>00224         <span class="keywordflow">return</span>;
<a name="l00225"></a>00225     o-&gt;<a class="code" href="structunpack__trees__options.html#a0489ef1bdaa94d6ff0706167005ed557">cache_bottom</a> = bottom;
<a name="l00226"></a>00226 }
<a name="l00227"></a>00227 
<a name="l00228"></a>00228 <span class="keyword">static</span> <span class="keywordtype">int</span> switch_cache_bottom(<span class="keyword">struct</span> <a class="code" href="structtraverse__info.html">traverse_info</a> *info)
<a name="l00229"></a>00229 {
<a name="l00230"></a>00230     <span class="keyword">struct </span><a class="code" href="structunpack__trees__options.html">unpack_trees_options</a> *o = info-&gt;<a class="code" href="structtraverse__info.html#a5a00856984e92cdd07a1280f9cd014cc">data</a>;
<a name="l00231"></a>00231     <span class="keywordtype">int</span> ret, pos;
<a name="l00232"></a>00232 
<a name="l00233"></a>00233     <span class="keywordflow">if</span> (o-&gt;<a class="code" href="structunpack__trees__options.html#a09662cb6d5c5edae259ce33f6a61c1d8">diff_index_cached</a>)
<a name="l00234"></a>00234         <span class="keywordflow">return</span> 0;
<a name="l00235"></a>00235     ret = o-&gt;<a class="code" href="structunpack__trees__options.html#a0489ef1bdaa94d6ff0706167005ed557">cache_bottom</a>;
<a name="l00236"></a>00236     pos = find_cache_pos(info-&gt;<a class="code" href="structtraverse__info.html#a5120169e1a4537ea030a6678946f49d7">prev</a>, &amp;info-&gt;<a class="code" href="structtraverse__info.html#aefb696a69eda6c240a75459c74bac992">name</a>);
<a name="l00237"></a>00237 
<a name="l00238"></a>00238     <span class="keywordflow">if</span> (pos &lt; -1)
<a name="l00239"></a>00239         o-&gt;<a class="code" href="structunpack__trees__options.html#a0489ef1bdaa94d6ff0706167005ed557">cache_bottom</a> = -2 - pos;
<a name="l00240"></a>00240     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (pos &lt; 0)
<a name="l00241"></a>00241         o-&gt;<a class="code" href="structunpack__trees__options.html#a0489ef1bdaa94d6ff0706167005ed557">cache_bottom</a> = o-&gt;<a class="code" href="structunpack__trees__options.html#a5781bfdf9479b84caf218a475e48476c">src_index</a>-&gt;<a class="code" href="structindex__state.html#a15b38cdd30ad2374bc12da429f39312f">cache_nr</a>;
<a name="l00242"></a>00242     <span class="keywordflow">return</span> ret;
<a name="l00243"></a>00243 }
<a name="l00244"></a>00244 
<a name="l00245"></a>00245 <span class="keyword">static</span> <span class="keywordtype">int</span> traverse_trees_recursive(<span class="keywordtype">int</span> n, <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> dirmask, <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> df_conflicts, <span class="keyword">struct</span> <a class="code" href="structname__entry.html">name_entry</a> *names, <span class="keyword">struct</span> <a class="code" href="structtraverse__info.html">traverse_info</a> *info)
<a name="l00246"></a>00246 {
<a name="l00247"></a>00247     <span class="keywordtype">int</span> i, ret, bottom;
<a name="l00248"></a>00248     <span class="keyword">struct </span><a class="code" href="structtree__desc.html">tree_desc</a> t[<a class="code" href="unpack-trees_8h.html#a7b7b3bceb59227ca330062cfda0932b7">MAX_UNPACK_TREES</a>];
<a name="l00249"></a>00249     <span class="keyword">struct </span><a class="code" href="structtraverse__info.html">traverse_info</a> newinfo;
<a name="l00250"></a>00250     <span class="keyword">struct </span><a class="code" href="structname__entry.html">name_entry</a> *p;
<a name="l00251"></a>00251     <span class="keyword">struct </span><a class="code" href="structunpack__trees__options.html">unpack_trees_options</a> *o = info-&gt;<a class="code" href="structtraverse__info.html#a5a00856984e92cdd07a1280f9cd014cc">data</a>;
<a name="l00252"></a>00252 
<a name="l00253"></a>00253     p = names;
<a name="l00254"></a>00254     <span class="keywordflow">while</span> (!p-&gt;<a class="code" href="structname__entry.html#a93ce445bc11d5d8176740a471694956d">mode</a>)
<a name="l00255"></a>00255         p++;
<a name="l00256"></a>00256 
<a name="l00257"></a>00257     newinfo = *info;
<a name="l00258"></a>00258     newinfo.<a class="code" href="structtraverse__info.html#a5120169e1a4537ea030a6678946f49d7">prev</a> = info;
<a name="l00259"></a>00259     newinfo.<a class="code" href="structtraverse__info.html#aefb696a69eda6c240a75459c74bac992">name</a> = *p;
<a name="l00260"></a>00260     newinfo.<a class="code" href="structname__entry.html#a8fdfe078253d3da4d1dec166cde6b959">pathlen</a> += p-&gt;<a class="code" href="structname__entry.html#a8fdfe078253d3da4d1dec166cde6b959">pathlen</a> + 1;
<a name="l00261"></a>00261     newinfo.conflicts |= df_conflicts;
<a name="l00262"></a>00262 
<a name="l00263"></a>00263     <span class="keywordflow">for</span> (i = 0; i &lt; n; i++, dirmask &gt;&gt;= 1) {
<a name="l00264"></a>00264         <span class="keywordtype">char</span> root_id[41];
<a name="l00265"></a>00265         <span class="keywordflow">if</span> (dirmask &amp; 1) {
<a name="l00266"></a>00266             <a class="code" href="seafile_2lib_2utils_8c.html#ae947b53110fc0132e83445d76ddded09">rawdata_to_hex</a>(names[i].<a class="code" href="index_8h.html#a96e76167c968d38441e90ee0488ee4aa">sha1</a>, root_id, 20);
<a name="l00267"></a>00267             <a class="code" href="seaf-tree-walk_8c.html#a7b310abaeb185b8918eb2a9fc843e097">fill_tree_descriptor</a>(o-&gt;<a class="code" href="structunpack__trees__options.html#a7270e145ba04fb2e7ba054a3af66d98c">repo_id</a>, o-&gt;<a class="code" href="structunpack__trees__options.html#a62f5e734252135d55f83a54015e1a4c6">version</a>, t+i, root_id);
<a name="l00268"></a>00268         } <span class="keywordflow">else</span> {
<a name="l00269"></a>00269             <a class="code" href="seaf-tree-walk_8c.html#a7b310abaeb185b8918eb2a9fc843e097">fill_tree_descriptor</a>(o-&gt;<a class="code" href="structunpack__trees__options.html#a7270e145ba04fb2e7ba054a3af66d98c">repo_id</a>, o-&gt;<a class="code" href="structunpack__trees__options.html#a62f5e734252135d55f83a54015e1a4c6">version</a>, t+i, NULL);
<a name="l00270"></a>00270         }
<a name="l00271"></a>00271     }
<a name="l00272"></a>00272 
<a name="l00273"></a>00273     bottom = switch_cache_bottom(&amp;newinfo);
<a name="l00274"></a>00274     ret = <a class="code" href="seaf-tree-walk_8c.html#a7d985aeab97fb8c4c5fecaede41fcc29">traverse_trees</a>(n, t, &amp;newinfo);
<a name="l00275"></a>00275     restore_cache_bottom(&amp;newinfo, bottom);
<a name="l00276"></a>00276 
<a name="l00277"></a>00277     <span class="keywordflow">for</span> (i = 0; i &lt; n; ++i) {
<a name="l00278"></a>00278         tree_desc_free (&amp;t[i]);
<a name="l00279"></a>00279     }
<a name="l00280"></a>00280 
<a name="l00281"></a>00281     <span class="keywordflow">return</span> ret;
<a name="l00282"></a>00282 }
<a name="l00283"></a>00283 
<a name="l00284"></a>00284 <span class="comment">/*</span>
<a name="l00285"></a>00285 <span class="comment"> * Compare the traverse-path to the cache entry without actually</span>
<a name="l00286"></a>00286 <span class="comment"> * having to generate the textual representation of the traverse</span>
<a name="l00287"></a>00287 <span class="comment"> * path.</span>
<a name="l00288"></a>00288 <span class="comment"> *</span>
<a name="l00289"></a>00289 <span class="comment"> * NOTE! This *only* compares up to the size of the traverse path</span>
<a name="l00290"></a>00290 <span class="comment"> * itself - the caller needs to do the final check for the cache</span>
<a name="l00291"></a>00291 <span class="comment"> * entry having more data at the end!</span>
<a name="l00292"></a>00292 <span class="comment"> */</span>
<a name="l00293"></a>00293 <span class="keyword">static</span> <span class="keywordtype">int</span> do_compare_entry(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structcache__entry.html">cache_entry</a> *ce, <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structtraverse__info.html">traverse_info</a> *info, <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structname__entry.html">name_entry</a> *n)
<a name="l00294"></a>00294 {
<a name="l00295"></a>00295     <span class="keywordtype">int</span> len, pathlen, ce_len;
<a name="l00296"></a>00296     <span class="keyword">const</span> <span class="keywordtype">char</span> *ce_name;
<a name="l00297"></a>00297 
<a name="l00298"></a>00298     <span class="keywordflow">if</span> (info-&gt;<a class="code" href="structtraverse__info.html#a5120169e1a4537ea030a6678946f49d7">prev</a>) {
<a name="l00299"></a>00299         <span class="keywordtype">int</span> cmp = do_compare_entry(ce, info-&gt;<a class="code" href="structtraverse__info.html#a5120169e1a4537ea030a6678946f49d7">prev</a>, &amp;info-&gt;<a class="code" href="structtraverse__info.html#aefb696a69eda6c240a75459c74bac992">name</a>);
<a name="l00300"></a>00300         <span class="keywordflow">if</span> (cmp)
<a name="l00301"></a>00301             <span class="keywordflow">return</span> cmp;
<a name="l00302"></a>00302     }
<a name="l00303"></a>00303     pathlen = info-&gt;<a class="code" href="structtraverse__info.html#a28b33c08bde690884ab425a6c5f71c00">pathlen</a>;
<a name="l00304"></a>00304     ce_len = ce_namelen(ce);
<a name="l00305"></a>00305 
<a name="l00306"></a>00306     <span class="comment">/* If ce_len &lt; pathlen then we must have previously hit &quot;name == directory&quot; entry */</span>
<a name="l00307"></a>00307     <span class="keywordflow">if</span> (ce_len &lt; pathlen)
<a name="l00308"></a>00308         <span class="keywordflow">return</span> -1;
<a name="l00309"></a>00309 
<a name="l00310"></a>00310     ce_len -= pathlen;
<a name="l00311"></a>00311     ce_name = ce-&gt;<a class="code" href="structcache__entry.html#a792e4ea24cb16c76abe3229651e414a0">name</a> + pathlen;
<a name="l00312"></a>00312 
<a name="l00313"></a>00313     len = n-&gt;<a class="code" href="structname__entry.html#a8fdfe078253d3da4d1dec166cde6b959">pathlen</a>;
<a name="l00314"></a>00314     <span class="keywordflow">return</span> <a class="code" href="index_8c.html#a8a3589fc007481a8224103522e189254">df_name_compare</a>(ce_name, ce_len, S_IFREG, n-&gt;<a class="code" href="structname__entry.html#ac754df9378b3ff12b9458127ff461554">path</a>, len, n-&gt;<a class="code" href="structname__entry.html#a93ce445bc11d5d8176740a471694956d">mode</a>);
<a name="l00315"></a>00315 }
<a name="l00316"></a>00316 
<a name="l00317"></a>00317 <span class="keyword">static</span> <span class="keywordtype">int</span> compare_entry(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structcache__entry.html">cache_entry</a> *ce, <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structtraverse__info.html">traverse_info</a> *info, <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structname__entry.html">name_entry</a> *n)
<a name="l00318"></a>00318 {
<a name="l00319"></a>00319     <span class="keywordtype">int</span> cmp = do_compare_entry(ce, info, n);
<a name="l00320"></a>00320     <span class="keywordflow">if</span> (cmp)
<a name="l00321"></a>00321         <span class="keywordflow">return</span> cmp;
<a name="l00322"></a>00322 
<a name="l00323"></a>00323     <span class="comment">/*</span>
<a name="l00324"></a>00324 <span class="comment">     * Even if the beginning compared identically, the ce should</span>
<a name="l00325"></a>00325 <span class="comment">     * compare as bigger than a directory leading up to it!</span>
<a name="l00326"></a>00326 <span class="comment">     */</span>
<a name="l00327"></a>00327     <span class="keywordflow">return</span> ce_namelen(ce) &gt; traverse_path_len(info, n);
<a name="l00328"></a>00328 }
<a name="l00329"></a>00329 
<a name="l00330"></a>00330 <span class="keyword">static</span> <span class="keywordtype">int</span> ce_in_traverse_path(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structcache__entry.html">cache_entry</a> *ce,
<a name="l00331"></a>00331                                <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structtraverse__info.html">traverse_info</a> *info)
<a name="l00332"></a>00332 {
<a name="l00333"></a>00333     <span class="keywordflow">if</span> (!info-&gt;<a class="code" href="structtraverse__info.html#a5120169e1a4537ea030a6678946f49d7">prev</a>)
<a name="l00334"></a>00334         <span class="keywordflow">return</span> 1;
<a name="l00335"></a>00335     <span class="keywordflow">if</span> (do_compare_entry(ce, info-&gt;<a class="code" href="structtraverse__info.html#a5120169e1a4537ea030a6678946f49d7">prev</a>, &amp;info-&gt;<a class="code" href="structtraverse__info.html#aefb696a69eda6c240a75459c74bac992">name</a>))
<a name="l00336"></a>00336         <span class="keywordflow">return</span> 0;
<a name="l00337"></a>00337     <span class="comment">/*</span>
<a name="l00338"></a>00338 <span class="comment">     * If ce (blob) is the same name as the path (which is a tree</span>
<a name="l00339"></a>00339 <span class="comment">     * we will be descending into), it won&#39;t be inside it.</span>
<a name="l00340"></a>00340 <span class="comment">     */</span>
<a name="l00341"></a>00341     <span class="keywordflow">return</span> (info-&gt;<a class="code" href="structtraverse__info.html#a28b33c08bde690884ab425a6c5f71c00">pathlen</a> &lt; ce_namelen(ce));
<a name="l00342"></a>00342 }
<a name="l00343"></a>00343 
<a name="l00344"></a>00344 <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structcache__entry.html">cache_entry</a> *create_ce_entry(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structtraverse__info.html">traverse_info</a> *info, <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structname__entry.html">name_entry</a> *n, <span class="keywordtype">int</span> stage)
<a name="l00345"></a>00345 {
<a name="l00346"></a>00346     <span class="keywordtype">int</span> len = traverse_path_len(info, n);
<a name="l00347"></a>00347     <span class="keyword">struct </span><a class="code" href="structcache__entry.html">cache_entry</a> *ce = calloc(1, <a class="code" href="index_8h.html#a07a18158c879287d1606ceec992ba702">cache_entry_size</a>(len));
<a name="l00348"></a>00348 
<a name="l00349"></a>00349     ce-&gt;<a class="code" href="structcache__entry.html#a5fcbcc4e7265ae8150f136380ed92c05">ce_mode</a> = create_ce_mode(n-&gt;<a class="code" href="structname__entry.html#a93ce445bc11d5d8176740a471694956d">mode</a>);
<a name="l00350"></a>00350     ce-&gt;<a class="code" href="structcache__entry.html#a4dab14fd813a1bb6b67352674ff4afb2">ce_flags</a> = create_ce_flags(len, stage);
<a name="l00351"></a>00351     hashcpy(ce-&gt;<a class="code" href="structcache__entry.html#a119ab5c5e9db495e6e5f8d301f01421c">sha1</a>, n-&gt;<a class="code" href="structname__entry.html#a8716a0cb25a4dc790df6690b4e503998">sha1</a>);
<a name="l00352"></a>00352     <a class="code" href="seaf-tree-walk_8c.html#a5503e227d51aa565c864181791f06f59">make_traverse_path</a>(ce-&gt;<a class="code" href="structcache__entry.html#a792e4ea24cb16c76abe3229651e414a0">name</a>, info, n);
<a name="l00353"></a>00353     ce-&gt;<a class="code" href="structcache__entry.html#a786aa5bc6234542fe202023bcf721afd">modifier</a> = g_strdup(n-&gt;<a class="code" href="structname__entry.html#ac0641595e66b6e338b23206335f91dfa">modifier</a>);
<a name="l00354"></a>00354     ce-&gt;<a class="code" href="structcache__entry.html#a1c66f1f4e7773a56010e7ec64bd38a95">ce_mtime</a>.<a class="code" href="structcache__time64.html#ae37877c7f3995f5a44a4a9fd7bb91d46">sec</a> = n-&gt;<a class="code" href="structname__entry.html#a55179363aec360b4b716b60a658efcb6">mtime</a>;
<a name="l00355"></a>00355 
<a name="l00356"></a>00356     <span class="keywordflow">return</span> ce;
<a name="l00357"></a>00357 }
<a name="l00358"></a>00358 
<a name="l00359"></a>00359 <span class="keyword">static</span> <span class="keywordtype">int</span> unpack_nondirectories(<span class="keywordtype">int</span> n, <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> mask,
<a name="l00360"></a>00360                                  <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> dirmask,
<a name="l00361"></a>00361                                  <span class="keyword">struct</span> <a class="code" href="structcache__entry.html">cache_entry</a> **src,
<a name="l00362"></a>00362                                  <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structname__entry.html">name_entry</a> *names,
<a name="l00363"></a>00363                                  <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structtraverse__info.html">traverse_info</a> *info)
<a name="l00364"></a>00364 {
<a name="l00365"></a>00365     <span class="keywordtype">int</span> i;
<a name="l00366"></a>00366     <span class="keyword">struct </span><a class="code" href="structunpack__trees__options.html">unpack_trees_options</a> *o = info-&gt;<a class="code" href="structtraverse__info.html#a5a00856984e92cdd07a1280f9cd014cc">data</a>;
<a name="l00367"></a>00367     <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> conflicts;
<a name="l00368"></a>00368 
<a name="l00369"></a>00369     <span class="comment">/* Do we have *only* directories? Nothing to do */</span>
<a name="l00370"></a>00370     <span class="keywordflow">if</span> (mask == dirmask &amp;&amp; !src[0])
<a name="l00371"></a>00371         <span class="keywordflow">return</span> 0;
<a name="l00372"></a>00372 
<a name="l00373"></a>00373     conflicts = info-&gt;<a class="code" href="structtraverse__info.html#ab4c8d1b27fc0d2e2a0d1487045e52e81">conflicts</a>;
<a name="l00374"></a>00374     <span class="keywordflow">if</span> (o-&gt;<a class="code" href="structunpack__trees__options.html#a3173b72b67869712cae670d071a73d44">merge</a>)
<a name="l00375"></a>00375         conflicts &gt;&gt;= 1;
<a name="l00376"></a>00376     conflicts |= dirmask;
<a name="l00377"></a>00377 
<a name="l00378"></a>00378     <span class="comment">/*</span>
<a name="l00379"></a>00379 <span class="comment">     * Ok, we&#39;ve filled in up to any potential index entry in src[0],</span>
<a name="l00380"></a>00380 <span class="comment">     * now do the rest.</span>
<a name="l00381"></a>00381 <span class="comment">     */</span>
<a name="l00382"></a>00382     <span class="keywordflow">for</span> (i = 0; i &lt; n; i++) {
<a name="l00383"></a>00383         <span class="keywordtype">int</span> stage;
<a name="l00384"></a>00384         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> bit = 1ul &lt;&lt; i;
<a name="l00385"></a>00385         <span class="keywordflow">if</span> (conflicts &amp; bit) {
<a name="l00386"></a>00386             src[i + o-&gt;<a class="code" href="structunpack__trees__options.html#a3173b72b67869712cae670d071a73d44">merge</a>] = o-&gt;<a class="code" href="structunpack__trees__options.html#a509025e0763badd0c5ab5240aa7a10fc">df_conflict_entry</a>;
<a name="l00387"></a>00387             <span class="keywordflow">continue</span>;
<a name="l00388"></a>00388         }
<a name="l00389"></a>00389         <span class="keywordflow">if</span> (!(mask &amp; bit))
<a name="l00390"></a>00390             <span class="keywordflow">continue</span>;
<a name="l00391"></a>00391         <span class="keywordflow">if</span> (!o-&gt;<a class="code" href="structunpack__trees__options.html#a3173b72b67869712cae670d071a73d44">merge</a>)
<a name="l00392"></a>00392             stage = 0;
<a name="l00393"></a>00393         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (i + 1 &lt; o-&gt;<a class="code" href="structunpack__trees__options.html#ac3c76fcf0737031ee5783304d59c4865">head_idx</a>)
<a name="l00394"></a>00394             stage = 1;
<a name="l00395"></a>00395         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (i + 1 &gt; o-&gt;<a class="code" href="structunpack__trees__options.html#ac3c76fcf0737031ee5783304d59c4865">head_idx</a>)
<a name="l00396"></a>00396             stage = 3;
<a name="l00397"></a>00397         <span class="keywordflow">else</span>
<a name="l00398"></a>00398             stage = 2;
<a name="l00399"></a>00399         src[i + o-&gt;<a class="code" href="structunpack__trees__options.html#a3173b72b67869712cae670d071a73d44">merge</a>] = create_ce_entry(info, names + i, stage);
<a name="l00400"></a>00400     }
<a name="l00401"></a>00401 
<a name="l00402"></a>00402     <span class="keywordflow">if</span> (o-&gt;<a class="code" href="structunpack__trees__options.html#a3173b72b67869712cae670d071a73d44">merge</a>) {
<a name="l00403"></a>00403         <span class="keywordtype">int</span> ret = call_unpack_fn(src, o);
<a name="l00404"></a>00404         <span class="keywordflow">for</span> (i = 1; i &lt;= n; i++)
<a name="l00405"></a>00405             <span class="keywordflow">if</span> (src[i] &amp;&amp; src[i] != o-&gt;<a class="code" href="structunpack__trees__options.html#a509025e0763badd0c5ab5240aa7a10fc">df_conflict_entry</a>) 
<a name="l00406"></a>00406                 <a class="code" href="index_8c.html#a156a4ea461fcf14e0b73755b02e7e7d1">cache_entry_free</a>(src[i]);
<a name="l00407"></a>00407         <span class="keywordflow">return</span> ret;
<a name="l00408"></a>00408     }
<a name="l00409"></a>00409 
<a name="l00410"></a>00410     <span class="keywordflow">for</span> (i = 0; i &lt; n; i++)
<a name="l00411"></a>00411         <span class="keywordflow">if</span> (src[i] &amp;&amp; src[i] != o-&gt;<a class="code" href="structunpack__trees__options.html#a509025e0763badd0c5ab5240aa7a10fc">df_conflict_entry</a>)
<a name="l00412"></a>00412             add_entry(o, src[i], 0, 0);
<a name="l00413"></a>00413     <span class="keywordflow">return</span> 0;
<a name="l00414"></a>00414 }
<a name="l00415"></a>00415 
<a name="l00416"></a>00416 <span class="comment">/* NEEDSWORK: give this a better name and share with tree-walk.c */</span>
<a name="l00417"></a>00417 <span class="keyword">static</span> <span class="keywordtype">int</span> name_compare(<span class="keyword">const</span> <span class="keywordtype">char</span> *a, <span class="keywordtype">int</span> a_len,
<a name="l00418"></a>00418                         <span class="keyword">const</span> <span class="keywordtype">char</span> *b, <span class="keywordtype">int</span> b_len)
<a name="l00419"></a>00419 {
<a name="l00420"></a>00420     <span class="keywordtype">int</span> len = (a_len &lt; b_len) ? a_len : b_len;
<a name="l00421"></a>00421     <span class="keywordtype">int</span> cmp = memcmp(a, b, len);
<a name="l00422"></a>00422     <span class="keywordflow">if</span> (cmp)
<a name="l00423"></a>00423         <span class="keywordflow">return</span> cmp;
<a name="l00424"></a>00424     <span class="keywordflow">return</span> (a_len - b_len);
<a name="l00425"></a>00425 }
<a name="l00426"></a>00426 
<a name="l00427"></a>00427 <span class="comment">/*</span>
<a name="l00428"></a>00428 <span class="comment"> * The tree traversal is looking at name p.  If we have a matching entry,</span>
<a name="l00429"></a>00429 <span class="comment"> * return it.  If name p is a directory in the index, do not return</span>
<a name="l00430"></a>00430 <span class="comment"> * anything, as we will want to match it when the traversal descends into</span>
<a name="l00431"></a>00431 <span class="comment"> * the directory.</span>
<a name="l00432"></a>00432 <span class="comment"> */</span>
<a name="l00433"></a>00433 <span class="keyword">static</span> <span class="keywordtype">int</span> find_cache_pos(<span class="keyword">struct</span> <a class="code" href="structtraverse__info.html">traverse_info</a> *info,
<a name="l00434"></a>00434                           <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structname__entry.html">name_entry</a> *p)
<a name="l00435"></a>00435 {
<a name="l00436"></a>00436     <span class="keywordtype">int</span> pos;
<a name="l00437"></a>00437     <span class="keyword">struct </span><a class="code" href="structunpack__trees__options.html">unpack_trees_options</a> *o = info-&gt;<a class="code" href="structtraverse__info.html#a5a00856984e92cdd07a1280f9cd014cc">data</a>;
<a name="l00438"></a>00438     <span class="keyword">struct </span><a class="code" href="structindex__state.html">index_state</a> *index = o-&gt;<a class="code" href="structunpack__trees__options.html#a5781bfdf9479b84caf218a475e48476c">src_index</a>;
<a name="l00439"></a>00439     <span class="keywordtype">int</span> pfxlen = info-&gt;<a class="code" href="structtraverse__info.html#a28b33c08bde690884ab425a6c5f71c00">pathlen</a>;
<a name="l00440"></a>00440     <span class="keywordtype">int</span> p_len = p-&gt;<a class="code" href="structname__entry.html#a8fdfe078253d3da4d1dec166cde6b959">pathlen</a>;
<a name="l00441"></a>00441 
<a name="l00442"></a>00442     <span class="keywordflow">for</span> (pos = o-&gt;<a class="code" href="structunpack__trees__options.html#a0489ef1bdaa94d6ff0706167005ed557">cache_bottom</a>; pos &lt; index-&gt;cache_nr; pos++) {
<a name="l00443"></a>00443         <span class="keyword">struct </span><a class="code" href="structcache__entry.html">cache_entry</a> *ce = index-&gt;<a class="code" href="structindex__state.html#a8aa7a8aa984ec5a39ff2eee96412db07">cache</a>[pos];
<a name="l00444"></a>00444         <span class="keyword">const</span> <span class="keywordtype">char</span> *ce_name, *ce_slash;
<a name="l00445"></a>00445         <span class="keywordtype">int</span> cmp, ce_len;
<a name="l00446"></a>00446 
<a name="l00447"></a>00447         <span class="keywordflow">if</span> (ce-&gt;<a class="code" href="structcache__entry.html#a4dab14fd813a1bb6b67352674ff4afb2">ce_flags</a> &amp; <a class="code" href="index_8h.html#ab9f9391faf6b3de1d55d71cb07417d0e">CE_UNPACKED</a>) {
<a name="l00448"></a>00448             <span class="comment">/*</span>
<a name="l00449"></a>00449 <span class="comment">             * cache_bottom entry is already unpacked, so</span>
<a name="l00450"></a>00450 <span class="comment">             * we can never match it; don&#39;t check it</span>
<a name="l00451"></a>00451 <span class="comment">             * again.</span>
<a name="l00452"></a>00452 <span class="comment">             */</span>
<a name="l00453"></a>00453             <span class="keywordflow">if</span> (pos == o-&gt;<a class="code" href="structunpack__trees__options.html#a0489ef1bdaa94d6ff0706167005ed557">cache_bottom</a>)
<a name="l00454"></a>00454                 ++o-&gt;<a class="code" href="structunpack__trees__options.html#a0489ef1bdaa94d6ff0706167005ed557">cache_bottom</a>;
<a name="l00455"></a>00455             <span class="keywordflow">continue</span>;
<a name="l00456"></a>00456         }
<a name="l00457"></a>00457         <span class="keywordflow">if</span> (!ce_in_traverse_path(ce, info))
<a name="l00458"></a>00458             <span class="keywordflow">continue</span>;
<a name="l00459"></a>00459         ce_name = ce-&gt;<a class="code" href="structcache__entry.html#a792e4ea24cb16c76abe3229651e414a0">name</a> + pfxlen;
<a name="l00460"></a>00460         ce_slash = strchr(ce_name, <span class="charliteral">&#39;/&#39;</span>);
<a name="l00461"></a>00461         <span class="keywordflow">if</span> (ce_slash)
<a name="l00462"></a>00462             ce_len = ce_slash - ce_name;
<a name="l00463"></a>00463         <span class="keywordflow">else</span>
<a name="l00464"></a>00464             ce_len = ce_namelen(ce) - pfxlen;
<a name="l00465"></a>00465         cmp = name_compare(p-&gt;<a class="code" href="structname__entry.html#ac754df9378b3ff12b9458127ff461554">path</a>, p_len, ce_name, ce_len);
<a name="l00466"></a>00466         <span class="comment">/*</span>
<a name="l00467"></a>00467 <span class="comment">         * Exact match; if we have a directory we need to</span>
<a name="l00468"></a>00468 <span class="comment">         * delay returning it.</span>
<a name="l00469"></a>00469 <span class="comment">         */</span>
<a name="l00470"></a>00470         <span class="keywordflow">if</span> (!cmp)
<a name="l00471"></a>00471             <span class="keywordflow">return</span> ce_slash ? -2 - pos : pos;
<a name="l00472"></a>00472         <span class="keywordflow">if</span> (0 &lt; cmp)
<a name="l00473"></a>00473             <span class="keywordflow">continue</span>; <span class="comment">/* keep looking */</span>
<a name="l00474"></a>00474         <span class="comment">/*</span>
<a name="l00475"></a>00475 <span class="comment">         * ce_name sorts after p-&gt;path; could it be that we</span>
<a name="l00476"></a>00476 <span class="comment">         * have files under p-&gt;path directory in the index?</span>
<a name="l00477"></a>00477 <span class="comment">         * E.g.  ce_name == &quot;t-i&quot;, and p-&gt;path == &quot;t&quot;; we may</span>
<a name="l00478"></a>00478 <span class="comment">         * have &quot;t/a&quot; in the index.</span>
<a name="l00479"></a>00479 <span class="comment">         */</span>
<a name="l00480"></a>00480         <span class="keywordflow">if</span> (p_len &lt; ce_len &amp;&amp; !memcmp(ce_name, p-&gt;<a class="code" href="structname__entry.html#ac754df9378b3ff12b9458127ff461554">path</a>, p_len) &amp;&amp;
<a name="l00481"></a>00481             ce_name[p_len] &lt; <span class="charliteral">&#39;/&#39;</span>)
<a name="l00482"></a>00482             <span class="keywordflow">continue</span>; <span class="comment">/* keep looking */</span>
<a name="l00483"></a>00483         <span class="keywordflow">break</span>;
<a name="l00484"></a>00484     }
<a name="l00485"></a>00485     <span class="keywordflow">return</span> -1;
<a name="l00486"></a>00486 }
<a name="l00487"></a>00487 
<a name="l00488"></a>00488 <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structcache__entry.html">cache_entry</a> *find_cache_entry(<span class="keyword">struct</span> <a class="code" href="structtraverse__info.html">traverse_info</a> *info,
<a name="l00489"></a>00489                                             <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structname__entry.html">name_entry</a> *p)
<a name="l00490"></a>00490 {
<a name="l00491"></a>00491     <span class="keywordtype">int</span> pos = find_cache_pos(info, p);
<a name="l00492"></a>00492     <span class="keyword">struct </span><a class="code" href="structunpack__trees__options.html">unpack_trees_options</a> *o = info-&gt;<a class="code" href="structtraverse__info.html#a5a00856984e92cdd07a1280f9cd014cc">data</a>;
<a name="l00493"></a>00493 
<a name="l00494"></a>00494     <span class="keywordflow">if</span> (0 &lt;= pos)
<a name="l00495"></a>00495         <span class="keywordflow">return</span> o-&gt;<a class="code" href="structunpack__trees__options.html#a5781bfdf9479b84caf218a475e48476c">src_index</a>-&gt;<a class="code" href="structindex__state.html#a8aa7a8aa984ec5a39ff2eee96412db07">cache</a>[pos];
<a name="l00496"></a>00496     <span class="keywordflow">else</span>
<a name="l00497"></a>00497         <span class="keywordflow">return</span> NULL;
<a name="l00498"></a>00498 }
<a name="l00499"></a>00499 
<a name="l00500"></a>00500 <span class="keyword">static</span> <span class="keywordtype">void</span> debug_path(<span class="keyword">struct</span> <a class="code" href="structtraverse__info.html">traverse_info</a> *info)
<a name="l00501"></a>00501 {
<a name="l00502"></a>00502     <span class="keywordflow">if</span> (info-&gt;<a class="code" href="structtraverse__info.html#a5120169e1a4537ea030a6678946f49d7">prev</a>) {
<a name="l00503"></a>00503         debug_path(info-&gt;<a class="code" href="structtraverse__info.html#a5120169e1a4537ea030a6678946f49d7">prev</a>);
<a name="l00504"></a>00504         <span class="keywordflow">if</span> (*info-&gt;<a class="code" href="structtraverse__info.html#a5120169e1a4537ea030a6678946f49d7">prev</a>-&gt;<a class="code" href="structtraverse__info.html#aefb696a69eda6c240a75459c74bac992">name</a>.<a class="code" href="structname__entry.html#ac754df9378b3ff12b9458127ff461554">path</a>)
<a name="l00505"></a>00505             putchar(<span class="charliteral">&#39;/&#39;</span>);
<a name="l00506"></a>00506     }
<a name="l00507"></a>00507     printf(<span class="stringliteral">&quot;%s&quot;</span>, info-&gt;<a class="code" href="structtraverse__info.html#aefb696a69eda6c240a75459c74bac992">name</a>.<a class="code" href="structname__entry.html#ac754df9378b3ff12b9458127ff461554">path</a>);
<a name="l00508"></a>00508 }
<a name="l00509"></a>00509 
<a name="l00510"></a>00510 <span class="keyword">static</span> <span class="keywordtype">void</span> debug_name_entry(<span class="keywordtype">int</span> i, <span class="keyword">struct</span> <a class="code" href="structname__entry.html">name_entry</a> *n)
<a name="l00511"></a>00511 {
<a name="l00512"></a>00512     printf(<span class="stringliteral">&quot;ent#%d %06o %s\n&quot;</span>, i,
<a name="l00513"></a>00513            n-&gt;<a class="code" href="structname__entry.html#ac754df9378b3ff12b9458127ff461554">path</a> ? n-&gt;<a class="code" href="structname__entry.html#a93ce445bc11d5d8176740a471694956d">mode</a> : 0,
<a name="l00514"></a>00514            n-&gt;<a class="code" href="structname__entry.html#ac754df9378b3ff12b9458127ff461554">path</a> ? n-&gt;<a class="code" href="structname__entry.html#ac754df9378b3ff12b9458127ff461554">path</a> : <span class="stringliteral">&quot;(missing)&quot;</span>);
<a name="l00515"></a>00515 }
<a name="l00516"></a>00516 
<a name="l00517"></a>00517 <span class="keyword">static</span> <span class="keywordtype">void</span> debug_unpack_callback(<span class="keywordtype">int</span> n,
<a name="l00518"></a>00518                                   <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> mask,
<a name="l00519"></a>00519                                   <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> dirmask,
<a name="l00520"></a>00520                                   <span class="keyword">struct</span> <a class="code" href="structname__entry.html">name_entry</a> *names,
<a name="l00521"></a>00521                                   <span class="keyword">struct</span> <a class="code" href="structtraverse__info.html">traverse_info</a> *info)
<a name="l00522"></a>00522 {
<a name="l00523"></a>00523     <span class="keywordtype">int</span> i;
<a name="l00524"></a>00524     printf(<span class="stringliteral">&quot;* unpack mask %lu, dirmask %lu, cnt %d &quot;</span>,
<a name="l00525"></a>00525            mask, dirmask, n);
<a name="l00526"></a>00526     debug_path(info);
<a name="l00527"></a>00527     putchar(<span class="charliteral">&#39;\n&#39;</span>);
<a name="l00528"></a>00528     <span class="keywordflow">for</span> (i = 0; i &lt; n; i++)
<a name="l00529"></a>00529         debug_name_entry(i, names + i);
<a name="l00530"></a>00530 }
<a name="l00531"></a>00531 
<a name="l00532"></a>00532 <span class="keyword">static</span> <span class="keywordtype">int</span> unpack_callback(<span class="keywordtype">int</span> n, <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> mask, <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> dirmask, <span class="keyword">struct</span> <a class="code" href="structname__entry.html">name_entry</a> *names, <span class="keyword">struct</span> <a class="code" href="structtraverse__info.html">traverse_info</a> *info)
<a name="l00533"></a>00533 {
<a name="l00534"></a>00534     <span class="keyword">struct </span><a class="code" href="structcache__entry.html">cache_entry</a> *src[<a class="code" href="unpack-trees_8h.html#a7b7b3bceb59227ca330062cfda0932b7">MAX_UNPACK_TREES</a> + 1] = { NULL, };
<a name="l00535"></a>00535     <span class="keyword">struct </span><a class="code" href="structunpack__trees__options.html">unpack_trees_options</a> *o = info-&gt;<a class="code" href="structtraverse__info.html#a5a00856984e92cdd07a1280f9cd014cc">data</a>;
<a name="l00536"></a>00536     <span class="keyword">const</span> <span class="keyword">struct </span><a class="code" href="structname__entry.html">name_entry</a> *p = names;
<a name="l00537"></a>00537 
<a name="l00538"></a>00538     <span class="comment">/* Find first entry with a real name (we could use &quot;mask&quot; too) */</span>
<a name="l00539"></a>00539     <span class="keywordflow">while</span> (!p-&gt;<a class="code" href="structname__entry.html#a93ce445bc11d5d8176740a471694956d">mode</a>)
<a name="l00540"></a>00540         p++;
<a name="l00541"></a>00541 
<a name="l00542"></a>00542     <span class="keywordflow">if</span> (o-&gt;<a class="code" href="structunpack__trees__options.html#a984371549b0a800bbd8fd72e1255f764">debug_unpack</a>)
<a name="l00543"></a>00543         debug_unpack_callback(n, mask, dirmask, names, info);
<a name="l00544"></a>00544 
<a name="l00545"></a>00545     <span class="comment">/* Are we supposed to look at the index too? */</span>
<a name="l00546"></a>00546     <span class="keywordflow">if</span> (o-&gt;<a class="code" href="structunpack__trees__options.html#a3173b72b67869712cae670d071a73d44">merge</a>) {
<a name="l00547"></a>00547         <span class="keywordflow">while</span> (1) {
<a name="l00548"></a>00548             <span class="keywordtype">int</span> cmp;
<a name="l00549"></a>00549             <span class="keyword">struct </span><a class="code" href="structcache__entry.html">cache_entry</a> *ce;
<a name="l00550"></a>00550 
<a name="l00551"></a>00551             <span class="keywordflow">if</span> (o-&gt;<a class="code" href="structunpack__trees__options.html#a09662cb6d5c5edae259ce33f6a61c1d8">diff_index_cached</a>)
<a name="l00552"></a>00552                 ce = next_cache_entry(o);
<a name="l00553"></a>00553             <span class="keywordflow">else</span>
<a name="l00554"></a>00554                 ce = find_cache_entry(info, p);
<a name="l00555"></a>00555 
<a name="l00556"></a>00556             <span class="keywordflow">if</span> (!ce)
<a name="l00557"></a>00557                 <span class="keywordflow">break</span>;
<a name="l00558"></a>00558             cmp = compare_entry(ce, info, p);
<a name="l00559"></a>00559             <span class="keywordflow">if</span> (cmp &lt; 0) {
<a name="l00560"></a>00560                 <span class="keywordflow">if</span> (unpack_index_entry(ce, o) &lt; 0)
<a name="l00561"></a>00561                     <span class="keywordflow">return</span> -1;
<a name="l00562"></a>00562                 <span class="keywordflow">continue</span>;
<a name="l00563"></a>00563             }
<a name="l00564"></a>00564             <span class="keywordflow">if</span> (!cmp) {
<a name="l00565"></a>00565                 <span class="keywordflow">if</span> (<a class="code" href="index_8h.html#a0379c411a3dc56c2d5ac0b1fcce22ead">ce_stage</a>(ce)) {
<a name="l00566"></a>00566                     <span class="comment">/*</span>
<a name="l00567"></a>00567 <span class="comment">                     * If we skip unmerged index</span>
<a name="l00568"></a>00568 <span class="comment">                     * entries, we&#39;ll skip this</span>
<a name="l00569"></a>00569 <span class="comment">                     * entry *and* the tree</span>
<a name="l00570"></a>00570 <span class="comment">                     * entries associated with it!</span>
<a name="l00571"></a>00571 <span class="comment">                     */</span>
<a name="l00572"></a>00572                     <span class="keywordflow">if</span> (o-&gt;<a class="code" href="structunpack__trees__options.html#ae9ca31035bd0ccf93e132adf3fc15773">skip_unmerged</a>) {
<a name="l00573"></a>00573                         add_same_unmerged(ce, o);
<a name="l00574"></a>00574                         <span class="keywordflow">return</span> mask;
<a name="l00575"></a>00575                     }
<a name="l00576"></a>00576                 }
<a name="l00577"></a>00577                 src[0] = ce;
<a name="l00578"></a>00578             }
<a name="l00579"></a>00579             <span class="keywordflow">break</span>;
<a name="l00580"></a>00580         }
<a name="l00581"></a>00581     }
<a name="l00582"></a>00582 
<a name="l00583"></a>00583     <span class="keywordflow">if</span> (unpack_nondirectories(n, mask, dirmask, src, names, info) &lt; 0)
<a name="l00584"></a>00584         <span class="keywordflow">return</span> -1;
<a name="l00585"></a>00585 
<a name="l00586"></a>00586     <span class="keywordflow">if</span> (src[0]) {
<a name="l00587"></a>00587         <span class="keywordflow">if</span> (<a class="code" href="index_8h.html#a0379c411a3dc56c2d5ac0b1fcce22ead">ce_stage</a>(src[0]))
<a name="l00588"></a>00588             mark_ce_used_same_name(src[0], o);
<a name="l00589"></a>00589         <span class="keywordflow">else</span>
<a name="l00590"></a>00590             mark_ce_used(src[0], o);
<a name="l00591"></a>00591     }
<a name="l00592"></a>00592 
<a name="l00593"></a>00593     <span class="comment">/* Now handle any directories.. */</span>
<a name="l00594"></a>00594     <span class="keywordflow">if</span> (dirmask) {
<a name="l00595"></a>00595         <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> conflicts = mask &amp; ~dirmask;
<a name="l00596"></a>00596         <span class="keywordflow">if</span> (o-&gt;<a class="code" href="structunpack__trees__options.html#a3173b72b67869712cae670d071a73d44">merge</a>) {
<a name="l00597"></a>00597             conflicts &lt;&lt;= 1;
<a name="l00598"></a>00598             <span class="keywordflow">if</span> (src[0])
<a name="l00599"></a>00599                 conflicts |= 1;
<a name="l00600"></a>00600         }
<a name="l00601"></a>00601 
<a name="l00602"></a>00602         <span class="comment">/*</span>
<a name="l00603"></a>00603 <span class="comment">         * This is an optimization that relies on cache tree.</span>
<a name="l00604"></a>00604 <span class="comment">         * Skip it for now.</span>
<a name="l00605"></a>00605 <span class="comment">         */</span>
<a name="l00606"></a>00606 <span class="preprocessor">#if 0</span>
<a name="l00607"></a>00607 <span class="preprocessor"></span>        <span class="comment">/* special case: &quot;diff-index --cached&quot; looking at a tree */</span>
<a name="l00608"></a>00608         <span class="keywordflow">if</span> (o-&gt;<a class="code" href="structunpack__trees__options.html#a09662cb6d5c5edae259ce33f6a61c1d8">diff_index_cached</a> &amp;&amp;
<a name="l00609"></a>00609             n == 1 &amp;&amp; dirmask == 1 &amp;&amp; S_ISDIR(names-&gt;<a class="code" href="structname__entry.html#a93ce445bc11d5d8176740a471694956d">mode</a>)) {
<a name="l00610"></a>00610             <span class="keywordtype">int</span> matches;
<a name="l00611"></a>00611             matches = cache_tree_matches_traversal(o-&gt;<a class="code" href="structunpack__trees__options.html#a5781bfdf9479b84caf218a475e48476c">src_index</a>-&gt;cache_tree,
<a name="l00612"></a>00612                                                    names, info);
<a name="l00613"></a>00613             <span class="comment">/*</span>
<a name="l00614"></a>00614 <span class="comment">             * Everything under the name matches; skip the</span>
<a name="l00615"></a>00615 <span class="comment">             * entire hierarchy.  diff_index_cached codepath</span>
<a name="l00616"></a>00616 <span class="comment">             * special cases D/F conflicts in such a way that</span>
<a name="l00617"></a>00617 <span class="comment">             * it does not do any look-ahead, so this is safe.</span>
<a name="l00618"></a>00618 <span class="comment">             */</span>
<a name="l00619"></a>00619             <span class="keywordflow">if</span> (matches) {
<a name="l00620"></a>00620                 o-&gt;<a class="code" href="structunpack__trees__options.html#a0489ef1bdaa94d6ff0706167005ed557">cache_bottom</a> += matches;
<a name="l00621"></a>00621                 <span class="keywordflow">return</span> mask;
<a name="l00622"></a>00622             }
<a name="l00623"></a>00623         }
<a name="l00624"></a>00624 <span class="preprocessor">#endif</span>
<a name="l00625"></a>00625 <span class="preprocessor"></span>
<a name="l00626"></a>00626         <span class="keywordflow">if</span> (traverse_trees_recursive(n, dirmask, conflicts,
<a name="l00627"></a>00627                                      names, info) &lt; 0)
<a name="l00628"></a>00628             <span class="keywordflow">return</span> -1;
<a name="l00629"></a>00629         <span class="keywordflow">return</span> mask;
<a name="l00630"></a>00630     }
<a name="l00631"></a>00631 
<a name="l00632"></a>00632     <span class="keywordflow">return</span> mask;
<a name="l00633"></a>00633 }
<a name="l00634"></a>00634 
<a name="l00635"></a>00635 <span class="keyword">static</span> <span class="keywordtype">void</span> setup_traverse_info(<span class="keyword">struct</span> <a class="code" href="structtraverse__info.html">traverse_info</a> *info, <span class="keyword">const</span> <span class="keywordtype">char</span> *base)
<a name="l00636"></a>00636 {
<a name="l00637"></a>00637     <span class="keywordtype">int</span> pathlen = strlen(base);
<a name="l00638"></a>00638     <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structtraverse__info.html">traverse_info</a> dummy;
<a name="l00639"></a>00639 
<a name="l00640"></a>00640     memset(info, 0, <span class="keyword">sizeof</span>(*info));
<a name="l00641"></a>00641     <span class="keywordflow">if</span> (pathlen &amp;&amp; base[pathlen-1] == <span class="charliteral">&#39;/&#39;</span>)
<a name="l00642"></a>00642         pathlen--;
<a name="l00643"></a>00643     info-&gt;<a class="code" href="structtraverse__info.html#a28b33c08bde690884ab425a6c5f71c00">pathlen</a> = pathlen ? pathlen + 1 : 0;
<a name="l00644"></a>00644     info-&gt;<a class="code" href="structtraverse__info.html#aefb696a69eda6c240a75459c74bac992">name</a>.<a class="code" href="structname__entry.html#ac754df9378b3ff12b9458127ff461554">path</a> = base;
<a name="l00645"></a>00645     <span class="comment">/* info-&gt;name.sha1 = NULL; */</span>
<a name="l00646"></a>00646     <span class="keywordflow">if</span> (pathlen)
<a name="l00647"></a>00647         info-&gt;<a class="code" href="structtraverse__info.html#a5120169e1a4537ea030a6678946f49d7">prev</a> = &amp;dummy;
<a name="l00648"></a>00648 }
<a name="l00649"></a>00649 
<a name="l00650"></a><a class="code" href="unpack-trees_8h.html#a1a4c235391bb5c3b6448a70e627a5101">00650</a> <span class="keywordtype">int</span> <a class="code" href="unpack-trees_8c.html#a5bfe365644fb33537027e988fb891e08">unpack_trees</a>(<span class="keywordtype">unsigned</span> len, <span class="keyword">struct</span> <a class="code" href="structtree__desc.html">tree_desc</a> *t, <span class="keyword">struct</span> <a class="code" href="structunpack__trees__options.html">unpack_trees_options</a> *o)
<a name="l00651"></a>00651 {
<a name="l00652"></a>00652     <span class="keywordtype">int</span> ret = 0;
<a name="l00653"></a>00653     <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structcache__entry.html">cache_entry</a> *dfc;
<a name="l00654"></a>00654 
<a name="l00655"></a>00655     memset(&amp;o-&gt;<a class="code" href="structunpack__trees__options.html#a091d6e59892b9009809e45dfb38c24da">result</a>, 0, <span class="keyword">sizeof</span>(o-&gt;<a class="code" href="structunpack__trees__options.html#a091d6e59892b9009809e45dfb38c24da">result</a>));
<a name="l00656"></a>00656     o-&gt;<a class="code" href="structunpack__trees__options.html#a091d6e59892b9009809e45dfb38c24da">result</a>.<a class="code" href="structindex__state.html#a013bd6f4d9c68a7b25db32c15d29c7e2">initialized</a> = 1;
<a name="l00657"></a>00657     o-&gt;<a class="code" href="structunpack__trees__options.html#a091d6e59892b9009809e45dfb38c24da">result</a>.<a class="code" href="structindex__state.html#a0fb0d6a2dabae448b68f04e75ffc1612">version</a> = o-&gt;<a class="code" href="structunpack__trees__options.html#a5781bfdf9479b84caf218a475e48476c">src_index</a>-&gt;<a class="code" href="structindex__state.html#a0fb0d6a2dabae448b68f04e75ffc1612">version</a>;
<a name="l00658"></a>00658     o-&gt;<a class="code" href="structunpack__trees__options.html#a091d6e59892b9009809e45dfb38c24da">result</a>.<a class="code" href="structindex__state.html#ac5f843973ed4eba3c6370ae193ac97a9">has_modifier</a> = o-&gt;<a class="code" href="structunpack__trees__options.html#a5781bfdf9479b84caf218a475e48476c">src_index</a>-&gt;<a class="code" href="structindex__state.html#ac5f843973ed4eba3c6370ae193ac97a9">has_modifier</a>;
<a name="l00659"></a>00659     o-&gt;<a class="code" href="structunpack__trees__options.html#a091d6e59892b9009809e45dfb38c24da">result</a>.<a class="code" href="structindex__state.html#aba21746d004309949f3af631aced813a">timestamp</a>.<a class="code" href="structcache__time.html#ad79ea7590f31a5cc560ab4809d31562d">sec</a> = o-&gt;<a class="code" href="structunpack__trees__options.html#a5781bfdf9479b84caf218a475e48476c">src_index</a>-&gt;<a class="code" href="structindex__state.html#aba21746d004309949f3af631aced813a">timestamp</a>.<a class="code" href="structcache__time.html#ad79ea7590f31a5cc560ab4809d31562d">sec</a>;
<a name="l00660"></a>00660     o-&gt;<a class="code" href="structunpack__trees__options.html#a091d6e59892b9009809e45dfb38c24da">result</a>.<a class="code" href="structindex__state.html#aba21746d004309949f3af631aced813a">timestamp</a>.<a class="code" href="structcache__time.html#acb016b82c22470ffc173985cd88d1389">nsec</a> = o-&gt;<a class="code" href="structunpack__trees__options.html#a5781bfdf9479b84caf218a475e48476c">src_index</a>-&gt;<a class="code" href="structindex__state.html#aba21746d004309949f3af631aced813a">timestamp</a>.<a class="code" href="structcache__time.html#acb016b82c22470ffc173985cd88d1389">nsec</a>;
<a name="l00661"></a>00661     o-&gt;<a class="code" href="structunpack__trees__options.html#a284fdf8bd0576d2999e1e199e1131346">merge_size</a> = len;
<a name="l00662"></a>00662     <a class="code" href="index_8c.html#a1bcae1e686ad516d8b562a214c9e2cd8">mark_all_ce_unused</a>(o-&gt;<a class="code" href="structunpack__trees__options.html#a5781bfdf9479b84caf218a475e48476c">src_index</a>);
<a name="l00663"></a>00663 
<a name="l00664"></a>00664     <span class="keywordflow">if</span> (!dfc)
<a name="l00665"></a>00665         dfc = calloc(1, <a class="code" href="index_8h.html#a07a18158c879287d1606ceec992ba702">cache_entry_size</a>(0));
<a name="l00666"></a>00666     o-&gt;<a class="code" href="structunpack__trees__options.html#a509025e0763badd0c5ab5240aa7a10fc">df_conflict_entry</a> = dfc;
<a name="l00667"></a>00667 
<a name="l00668"></a>00668     <span class="keywordflow">if</span> (len) {
<a name="l00669"></a>00669         <span class="keyword">struct </span><a class="code" href="structtraverse__info.html">traverse_info</a> info;
<a name="l00670"></a>00670 
<a name="l00671"></a>00671         setup_traverse_info(&amp;info, <span class="stringliteral">&quot;&quot;</span>);
<a name="l00672"></a>00672         info.<a class="code" href="structtraverse__info.html#a417b71fb5d2b39bf49478bce3759de57">fn</a> = unpack_callback;
<a name="l00673"></a>00673         info.<a class="code" href="structtraverse__info.html#a5a00856984e92cdd07a1280f9cd014cc">data</a> = o;
<a name="l00674"></a>00674         info.<a class="code" href="structtraverse__info.html#a07d252c658236b198d122f32593bfcee">show_all_errors</a> = o-&gt;<a class="code" href="structunpack__trees__options.html#aa7533a743ff33a599d0c5d1100754fcf">show_all_errors</a>;
<a name="l00675"></a>00675 
<a name="l00676"></a>00676         <span class="keywordflow">if</span> (<a class="code" href="seaf-tree-walk_8c.html#a7d985aeab97fb8c4c5fecaede41fcc29">traverse_trees</a>(len, t, &amp;info) &lt; 0)
<a name="l00677"></a>00677             <span class="keywordflow">goto</span> return_failed;
<a name="l00678"></a>00678     }
<a name="l00679"></a>00679 
<a name="l00680"></a>00680     <span class="comment">/* Any left-over entries in the index? */</span>
<a name="l00681"></a>00681     <span class="keywordflow">if</span> (o-&gt;<a class="code" href="structunpack__trees__options.html#a3173b72b67869712cae670d071a73d44">merge</a>) {
<a name="l00682"></a>00682         <span class="keywordflow">while</span> (1) {
<a name="l00683"></a>00683             <span class="keyword">struct </span><a class="code" href="structcache__entry.html">cache_entry</a> *ce = next_cache_entry(o);
<a name="l00684"></a>00684             <span class="keywordflow">if</span> (!ce)
<a name="l00685"></a>00685                 <span class="keywordflow">break</span>;
<a name="l00686"></a>00686             <span class="keywordflow">if</span> (unpack_index_entry(ce, o) &lt; 0)
<a name="l00687"></a>00687                 <span class="keywordflow">goto</span> return_failed;
<a name="l00688"></a>00688         }
<a name="l00689"></a>00689     }
<a name="l00690"></a>00690     <a class="code" href="index_8c.html#a1bcae1e686ad516d8b562a214c9e2cd8">mark_all_ce_unused</a>(o-&gt;<a class="code" href="structunpack__trees__options.html#a5781bfdf9479b84caf218a475e48476c">src_index</a>);
<a name="l00691"></a>00691 
<a name="l00692"></a>00692     <span class="keywordflow">if</span> (o-&gt;<a class="code" href="structunpack__trees__options.html#a8ce95a4dc6e80d2f4307043931095d7a">trivial_merges_only</a> &amp;&amp; o-&gt;<a class="code" href="structunpack__trees__options.html#a8b7cd690b47d941150a44a40164370bb">nontrivial_merge</a>) {
<a name="l00693"></a>00693         ret = -1;
<a name="l00694"></a>00694     }
<a name="l00695"></a>00695 
<a name="l00696"></a>00696     <span class="comment">/* o-&gt;src_index = NULL; */</span>
<a name="l00697"></a>00697     <span class="comment">/* ret = check_updates(o) ? (-2) : 0; */</span>
<a name="l00698"></a>00698     <span class="comment">/* if (o-&gt;dst_index) */</span>
<a name="l00699"></a>00699     <span class="comment">/*      *o-&gt;dst_index = o-&gt;result; */</span>
<a name="l00700"></a>00700 
<a name="l00701"></a>00701 done:
<a name="l00702"></a>00702     <span class="keywordflow">return</span> ret;
<a name="l00703"></a>00703 
<a name="l00704"></a>00704 return_failed:
<a name="l00705"></a>00705     <span class="comment">/* if (o-&gt;show_all_errors) */</span>
<a name="l00706"></a>00706     <span class="comment">/*      display_error_msgs(o); */</span>
<a name="l00707"></a>00707     <a class="code" href="index_8c.html#a1bcae1e686ad516d8b562a214c9e2cd8">mark_all_ce_unused</a>(o-&gt;<a class="code" href="structunpack__trees__options.html#a5781bfdf9479b84caf218a475e48476c">src_index</a>);
<a name="l00708"></a>00708     ret = -1;
<a name="l00709"></a>00709     <span class="keywordflow">goto</span> done;
<a name="l00710"></a>00710 }
<a name="l00711"></a>00711 
<a name="l00712"></a>00712 <span class="comment">/* Here come the merge functions */</span>
<a name="l00713"></a>00713 
<a name="l00714"></a>00714 <span class="keyword">static</span> <span class="keywordtype">int</span> reject_merge(<span class="keyword">struct</span> <a class="code" href="structcache__entry.html">cache_entry</a> *ce, <span class="keyword">struct</span> <a class="code" href="structunpack__trees__options.html">unpack_trees_options</a> *o)
<a name="l00715"></a>00715 {
<a name="l00716"></a>00716     <span class="keywordflow">return</span> add_rejected_path(o, <a class="code" href="unpack-trees_8h.html#ad2203a7733606ab3a15e195914f9d90dab6c8d49b5333d4ff78172a7c2a3d4b4d">ERROR_WOULD_OVERWRITE</a>, ce-&gt;<a class="code" href="structcache__entry.html#a792e4ea24cb16c76abe3229651e414a0">name</a>);
<a name="l00717"></a>00717 }
<a name="l00718"></a>00718 
<a name="l00719"></a>00719 <span class="keyword">static</span> <span class="keywordtype">int</span> same(<span class="keyword">struct</span> <a class="code" href="structcache__entry.html">cache_entry</a> *a, <span class="keyword">struct</span> <a class="code" href="structcache__entry.html">cache_entry</a> *b)
<a name="l00720"></a>00720 {
<a name="l00721"></a>00721     <span class="keywordflow">if</span> (!!a != !!b)
<a name="l00722"></a>00722         <span class="keywordflow">return</span> 0;
<a name="l00723"></a>00723     <span class="keywordflow">if</span> (!a &amp;&amp; !b)
<a name="l00724"></a>00724         <span class="keywordflow">return</span> 1;
<a name="l00725"></a>00725     <span class="keywordflow">if</span> ((a-&gt;<a class="code" href="structcache__entry.html#a4dab14fd813a1bb6b67352674ff4afb2">ce_flags</a> | b-&gt;<a class="code" href="structcache__entry.html#a4dab14fd813a1bb6b67352674ff4afb2">ce_flags</a>) &amp; <a class="code" href="index_8h.html#ae8aa611804959bb2ae74143429242dca">CE_CONFLICTED</a>)
<a name="l00726"></a>00726         <span class="keywordflow">return</span> 0;
<a name="l00727"></a>00727     <span class="keywordflow">return</span> a-&gt;<a class="code" href="structcache__entry.html#a5fcbcc4e7265ae8150f136380ed92c05">ce_mode</a> == b-&gt;<a class="code" href="structcache__entry.html#a5fcbcc4e7265ae8150f136380ed92c05">ce_mode</a> &amp;&amp;
<a name="l00728"></a>00728         !hashcmp(a-&gt;<a class="code" href="structcache__entry.html#a119ab5c5e9db495e6e5f8d301f01421c">sha1</a>, b-&gt;<a class="code" href="structcache__entry.html#a119ab5c5e9db495e6e5f8d301f01421c">sha1</a>);
<a name="l00729"></a>00729 }
<a name="l00730"></a>00730 
<a name="l00731"></a>00731 
<a name="l00732"></a>00732 <span class="comment">/*</span>
<a name="l00733"></a>00733 <span class="comment"> * When a CE gets turned into an unmerged entry, we</span>
<a name="l00734"></a>00734 <span class="comment"> * want it to be up-to-date</span>
<a name="l00735"></a>00735 <span class="comment"> */</span>
<a name="l00736"></a>00736 <span class="keyword">static</span> <span class="keywordtype">int</span> verify_uptodate_1(<span class="keyword">struct</span> <a class="code" href="structcache__entry.html">cache_entry</a> *ce,
<a name="l00737"></a>00737                              <span class="keyword">struct</span> <a class="code" href="structunpack__trees__options.html">unpack_trees_options</a> *o,
<a name="l00738"></a>00738                              <span class="keyword">enum</span> <a class="code" href="unpack-trees_8h.html#ad2203a7733606ab3a15e195914f9d90d">unpack_trees_error_types</a> error_type)
<a name="l00739"></a>00739 {
<a name="l00740"></a>00740 <span class="preprocessor">#if 0</span>
<a name="l00741"></a>00741 <span class="preprocessor"></span>    <span class="keywordtype">char</span> full_path[<a class="code" href="seafile_2common_2common_8h.html#a169a119979344433b9e2a39e4e8e334a">SEAF_PATH_MAX</a>];
<a name="l00742"></a>00742     <a class="code" href="seafile_2lib_2utils_8h.html#a5b073bcbe1516b249924c3702002d32c">SeafStat</a> st;
<a name="l00743"></a>00743 
<a name="l00744"></a>00744     <span class="keywordflow">if</span> (o-&gt;<a class="code" href="structunpack__trees__options.html#ae90060fa67398829899da620ab4dee87">index_only</a> || (!((ce-&gt;<a class="code" href="structcache__entry.html#a4dab14fd813a1bb6b67352674ff4afb2">ce_flags</a> &amp; <a class="code" href="index_8h.html#a85680cf3653d1fd82efb449619733ea4">CE_VALID</a>) || <a class="code" href="index_8h.html#aa9cb581aaeefbbd01aa6c7997f44a5e4">ce_skip_worktree</a>(ce)) &amp;&amp; (o-&gt;<a class="code" href="structunpack__trees__options.html#a6f9827ec3a41ca2d74b88eb418ab44ef">reset</a> || <a class="code" href="index_8h.html#ad55a581e1adce0475f3b6e044e8b3411">ce_uptodate</a>(ce))))
<a name="l00745"></a>00745         <span class="keywordflow">return</span> 0;
<a name="l00746"></a>00746 
<a name="l00747"></a>00747     snprintf(full_path, <a class="code" href="seafile_2common_2common_8h.html#a169a119979344433b9e2a39e4e8e334a">SEAF_PATH_MAX</a>, <span class="stringliteral">&quot;%s/%s&quot;</span>, o-&gt;<a class="code" href="structunpack__trees__options.html#a4a9bd1ef1d5e87af93c7ddce399e6b5f">base</a>, ce-&gt;<a class="code" href="structcache__entry.html#a792e4ea24cb16c76abe3229651e414a0">name</a>);
<a name="l00748"></a>00748     <span class="keywordflow">if</span> (!<a class="code" href="seafile_2lib_2utils_8c.html#ab46893ad4a68049bcd80eac8dcc2e299">seaf_stat</a> (full_path, &amp;st)) {
<a name="l00749"></a>00749         <span class="keywordtype">unsigned</span> changed = <a class="code" href="index_8c.html#a2a76921da1fbb55b7b33983ca9e8edc4">ie_match_stat</a>(ce, &amp;st, <a class="code" href="index_8h.html#a3ecb29f06d046b6a99ed2148f91ae0c3">CE_MATCH_IGNORE_VALID</a>|<a class="code" href="index_8h.html#abd49280eba10dafd6f24cc3a6eab6313">CE_MATCH_IGNORE_SKIP_WORKTREE</a>);
<a name="l00750"></a>00750         <span class="keywordflow">if</span> (!changed)
<a name="l00751"></a>00751             <span class="keywordflow">return</span> 0;
<a name="l00752"></a>00752         <span class="comment">/*</span>
<a name="l00753"></a>00753 <span class="comment">         * NEEDSWORK: the current default policy is to allow</span>
<a name="l00754"></a>00754 <span class="comment">         * submodule to be out of sync wrt the supermodule</span>
<a name="l00755"></a>00755 <span class="comment">         * index.  This needs to be tightened later for</span>
<a name="l00756"></a>00756 <span class="comment">         * submodules that are marked to be automatically</span>
<a name="l00757"></a>00757 <span class="comment">         * checked out.</span>
<a name="l00758"></a>00758 <span class="comment">         */</span>
<a name="l00759"></a>00759         <span class="keywordflow">if</span> (<a class="code" href="index_8h.html#a63e538171307b264dd11b7685c94b9ac">S_ISGITLINK</a>(ce-&gt;<a class="code" href="structcache__entry.html#a5fcbcc4e7265ae8150f136380ed92c05">ce_mode</a>))
<a name="l00760"></a>00760             <span class="keywordflow">return</span> 0;
<a name="l00761"></a>00761         errno = 0;
<a name="l00762"></a>00762     }
<a name="l00763"></a>00763     <span class="keywordflow">if</span> (errno == ENOENT)
<a name="l00764"></a>00764         <span class="keywordflow">return</span> 0;
<a name="l00765"></a>00765     <span class="keywordflow">return</span> o-&gt;<a class="code" href="structunpack__trees__options.html#a41e304e12d552f063099ac1fb1e9a7f3">gently</a> ? -1 :
<a name="l00766"></a>00766         add_rejected_path(o, error_type, ce-&gt;<a class="code" href="structcache__entry.html#a792e4ea24cb16c76abe3229651e414a0">name</a>);
<a name="l00767"></a>00767 <span class="preprocessor">#endif</span>
<a name="l00768"></a>00768 <span class="preprocessor"></span>    <span class="keywordflow">return</span> 0;
<a name="l00769"></a>00769 }
<a name="l00770"></a>00770 
<a name="l00771"></a>00771 <span class="keyword">static</span> <span class="keywordtype">int</span> verify_uptodate(<span class="keyword">struct</span> <a class="code" href="structcache__entry.html">cache_entry</a> *ce,
<a name="l00772"></a>00772                            <span class="keyword">struct</span> <a class="code" href="structunpack__trees__options.html">unpack_trees_options</a> *o)
<a name="l00773"></a>00773 {
<a name="l00774"></a>00774     <span class="comment">/* if (!o-&gt;skip_sparse_checkout &amp;&amp; (ce-&gt;ce_flags &amp; CE_NEW_SKIP_WORKTREE)) */</span>
<a name="l00775"></a>00775     <span class="comment">/*      return 0; */</span>
<a name="l00776"></a>00776     <span class="keywordflow">return</span> verify_uptodate_1(ce, o, <a class="code" href="unpack-trees_8h.html#ad2203a7733606ab3a15e195914f9d90dae87c8aa5b0141daf32ea024bfea9c689">ERROR_NOT_UPTODATE_FILE</a>);
<a name="l00777"></a>00777 }
<a name="l00778"></a>00778 
<a name="l00779"></a>00779 <span class="keyword">static</span> <span class="keywordtype">void</span> invalidate_ce_path(<span class="keyword">struct</span> <a class="code" href="structcache__entry.html">cache_entry</a> *ce, <span class="keyword">struct</span> <a class="code" href="structunpack__trees__options.html">unpack_trees_options</a> *o)
<a name="l00780"></a>00780 {
<a name="l00781"></a>00781 <span class="preprocessor">#if 0</span>
<a name="l00782"></a>00782 <span class="preprocessor"></span>    <span class="keywordflow">if</span> (ce)
<a name="l00783"></a>00783         <a class="code" href="cache-tree_8h.html#a6b5668e76c5a046ab4eb54a36023581a">cache_tree_invalidate_path</a>(o-&gt;<a class="code" href="structunpack__trees__options.html#a5781bfdf9479b84caf218a475e48476c">src_index</a>-&gt;cache_tree, ce-&gt;<a class="code" href="structcache__entry.html#a792e4ea24cb16c76abe3229651e414a0">name</a>);
<a name="l00784"></a>00784 <span class="preprocessor">#endif</span>
<a name="l00785"></a>00785 <span class="preprocessor"></span>}
<a name="l00786"></a>00786 
<a name="l00787"></a>00787 <span class="preprocessor">#if 0</span>
<a name="l00788"></a>00788 <span class="preprocessor"></span><span class="comment">/*</span>
<a name="l00789"></a>00789 <span class="comment"> * Check that checking out ce-&gt;sha1 in subdir ce-&gt;name is not</span>
<a name="l00790"></a>00790 <span class="comment"> * going to overwrite any working files.</span>
<a name="l00791"></a>00791 <span class="comment"> *</span>
<a name="l00792"></a>00792 <span class="comment"> * Currently, git does not checkout subprojects during a superproject</span>
<a name="l00793"></a>00793 <span class="comment"> * checkout, so it is not going to overwrite anything.</span>
<a name="l00794"></a>00794 <span class="comment"> */</span>
<a name="l00795"></a>00795 <span class="keyword">static</span> <span class="keywordtype">int</span> verify_clean_submodule(<span class="keyword">struct</span> <a class="code" href="structcache__entry.html">cache_entry</a> *ce,
<a name="l00796"></a>00796                                   <span class="keyword">enum</span> <a class="code" href="unpack-trees_8h.html#ad2203a7733606ab3a15e195914f9d90d">unpack_trees_error_types</a> error_type,
<a name="l00797"></a>00797                                   <span class="keyword">struct</span> <a class="code" href="structunpack__trees__options.html">unpack_trees_options</a> *o)
<a name="l00798"></a>00798 {
<a name="l00799"></a>00799     <span class="keywordflow">return</span> 0;
<a name="l00800"></a>00800 }
<a name="l00801"></a>00801 
<a name="l00802"></a>00802 <span class="keyword">static</span> <span class="keywordtype">int</span> verify_clean_subdirectory(<span class="keyword">struct</span> <a class="code" href="structcache__entry.html">cache_entry</a> *ce,
<a name="l00803"></a>00803                                      <span class="keyword">enum</span> <a class="code" href="unpack-trees_8h.html#ad2203a7733606ab3a15e195914f9d90d">unpack_trees_error_types</a> error_type,
<a name="l00804"></a>00804                                      <span class="keyword">struct</span> <a class="code" href="structunpack__trees__options.html">unpack_trees_options</a> *o)
<a name="l00805"></a>00805 {
<a name="l00806"></a>00806     <span class="comment">/*</span>
<a name="l00807"></a>00807 <span class="comment">     * we are about to extract &quot;ce-&gt;name&quot;; we would not want to lose</span>
<a name="l00808"></a>00808 <span class="comment">     * anything in the existing directory there.</span>
<a name="l00809"></a>00809 <span class="comment">     */</span>
<a name="l00810"></a>00810     <span class="keywordtype">int</span> namelen;
<a name="l00811"></a>00811     <span class="keywordtype">int</span> i;
<a name="l00812"></a>00812     <span class="keyword">struct </span><a class="code" href="structdir__struct.html">dir_struct</a> d;
<a name="l00813"></a>00813     <span class="keywordtype">char</span> *pathbuf;
<a name="l00814"></a>00814     <span class="keywordtype">int</span> cnt = 0;
<a name="l00815"></a>00815     <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> <a class="code" href="index_8h.html#a96e76167c968d38441e90ee0488ee4aa">sha1</a>[20];
<a name="l00816"></a>00816 
<a name="l00817"></a>00817     <span class="comment">/*</span>
<a name="l00818"></a>00818 <span class="comment">     * First let&#39;s make sure we do not have a local modification</span>
<a name="l00819"></a>00819 <span class="comment">     * in that directory.</span>
<a name="l00820"></a>00820 <span class="comment">     */</span>
<a name="l00821"></a>00821     namelen = strlen(ce-&gt;<a class="code" href="structcache__entry.html#a792e4ea24cb16c76abe3229651e414a0">name</a>);
<a name="l00822"></a>00822     <span class="keywordflow">for</span> (i = locate_in_src_index(ce, o);
<a name="l00823"></a>00823          i &lt; o-&gt;<a class="code" href="structunpack__trees__options.html#a5781bfdf9479b84caf218a475e48476c">src_index</a>-&gt;<a class="code" href="structindex__state.html#a15b38cdd30ad2374bc12da429f39312f">cache_nr</a>;
<a name="l00824"></a>00824          i++) {
<a name="l00825"></a>00825         <span class="keyword">struct </span><a class="code" href="structcache__entry.html">cache_entry</a> *ce2 = o-&gt;<a class="code" href="structunpack__trees__options.html#a5781bfdf9479b84caf218a475e48476c">src_index</a>-&gt;<a class="code" href="structindex__state.html#a8aa7a8aa984ec5a39ff2eee96412db07">cache</a>[i];
<a name="l00826"></a>00826         <span class="keywordtype">int</span> len = ce_namelen(ce2);
<a name="l00827"></a>00827         <span class="keywordflow">if</span> (len &lt; namelen ||
<a name="l00828"></a>00828             strncmp(ce-&gt;<a class="code" href="structcache__entry.html#a792e4ea24cb16c76abe3229651e414a0">name</a>, ce2-&gt;<a class="code" href="structcache__entry.html#a792e4ea24cb16c76abe3229651e414a0">name</a>, namelen) ||
<a name="l00829"></a>00829             ce2-&gt;<a class="code" href="structcache__entry.html#a792e4ea24cb16c76abe3229651e414a0">name</a>[namelen] != <span class="charliteral">&#39;/&#39;</span>)
<a name="l00830"></a>00830             <span class="keywordflow">break</span>;
<a name="l00831"></a>00831         <span class="comment">/*</span>
<a name="l00832"></a>00832 <span class="comment">         * ce2-&gt;name is an entry in the subdirectory to be</span>
<a name="l00833"></a>00833 <span class="comment">         * removed.</span>
<a name="l00834"></a>00834 <span class="comment">         */</span>
<a name="l00835"></a>00835         <span class="keywordflow">if</span> (!<a class="code" href="index_8h.html#a0379c411a3dc56c2d5ac0b1fcce22ead">ce_stage</a>(ce2)) {
<a name="l00836"></a>00836             <span class="keywordflow">if</span> (verify_uptodate(ce2, o))
<a name="l00837"></a>00837                 <span class="keywordflow">return</span> -1;
<a name="l00838"></a>00838             add_entry(o, ce2, <a class="code" href="index_8h.html#aa5ee599d9d7af67f19dba204ce9030c0">CE_REMOVE</a>, 0);
<a name="l00839"></a>00839             mark_ce_used(ce2, o);
<a name="l00840"></a>00840         }
<a name="l00841"></a>00841         cnt++;
<a name="l00842"></a>00842     }
<a name="l00843"></a>00843 
<a name="l00844"></a>00844     <span class="comment">/*</span>
<a name="l00845"></a>00845 <span class="comment">     * Then we need to make sure that we do not lose a locally</span>
<a name="l00846"></a>00846 <span class="comment">     * present file that is not ignored.</span>
<a name="l00847"></a>00847 <span class="comment">     */</span>
<a name="l00848"></a>00848     pathbuf = malloc(namelen + 2);
<a name="l00849"></a>00849     memcpy(pathbuf, ce-&gt;<a class="code" href="structcache__entry.html#a792e4ea24cb16c76abe3229651e414a0">name</a>, namelen);
<a name="l00850"></a>00850     strcpy(pathbuf+namelen, <span class="stringliteral">&quot;/&quot;</span>);
<a name="l00851"></a>00851 
<a name="l00852"></a>00852     memset(&amp;d, 0, <span class="keyword">sizeof</span>(d));
<a name="l00853"></a>00853     i = read_directory(&amp;d, pathbuf, namelen+1, NULL);
<a name="l00854"></a>00854     <span class="keywordflow">if</span> (i)
<a name="l00855"></a>00855         <span class="keywordflow">return</span> o-&gt;<a class="code" href="structunpack__trees__options.html#a41e304e12d552f063099ac1fb1e9a7f3">gently</a> ? -1 :
<a name="l00856"></a>00856             add_rejected_path(o, <a class="code" href="unpack-trees_8h.html#ad2203a7733606ab3a15e195914f9d90da3974899a705023ef22065bf0e98c399b">ERROR_NOT_UPTODATE_DIR</a>, ce-&gt;<a class="code" href="structcache__entry.html#a792e4ea24cb16c76abe3229651e414a0">name</a>);
<a name="l00857"></a>00857     free(pathbuf);
<a name="l00858"></a>00858     <span class="keywordflow">return</span> cnt;
<a name="l00859"></a>00859 }
<a name="l00860"></a>00860 
<a name="l00861"></a>00861 <span class="keyword">static</span> <span class="keywordtype">int</span> check_ok_to_remove(<span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code" href="index_8h.html#a2a7f851274ec18e17d38114c39b8511a">name</a>, <span class="keywordtype">int</span> len, <span class="keywordtype">int</span> dtype,
<a name="l00862"></a>00862                               <span class="keyword">struct</span> <a class="code" href="structcache__entry.html">cache_entry</a> *ce, <a class="code" href="seafile_2lib_2utils_8h.html#a5b073bcbe1516b249924c3702002d32c">SeafStat</a> *st,
<a name="l00863"></a>00863                               <span class="keyword">enum</span> <a class="code" href="unpack-trees_8h.html#ad2203a7733606ab3a15e195914f9d90d">unpack_trees_error_types</a> error_type,
<a name="l00864"></a>00864                               <span class="keyword">struct</span> <a class="code" href="structunpack__trees__options.html">unpack_trees_options</a> *o)
<a name="l00865"></a>00865 {
<a name="l00866"></a>00866     <span class="keyword">struct </span><a class="code" href="structcache__entry.html">cache_entry</a> *result;
<a name="l00867"></a>00867 
<a name="l00868"></a>00868     <span class="keywordflow">if</span> (S_ISDIR(st-&gt;st_mode)) {
<a name="l00869"></a>00869         <span class="comment">/*</span>
<a name="l00870"></a>00870 <span class="comment">         * We are checking out path &quot;foo&quot; and</span>
<a name="l00871"></a>00871 <span class="comment">         * found &quot;foo/.&quot; in the working tree.</span>
<a name="l00872"></a>00872 <span class="comment">         * This is tricky -- if we have modified</span>
<a name="l00873"></a>00873 <span class="comment">         * files that are in &quot;foo/&quot; we would lose</span>
<a name="l00874"></a>00874 <span class="comment">         * them.</span>
<a name="l00875"></a>00875 <span class="comment">         */</span>
<a name="l00876"></a>00876         <span class="keywordflow">if</span> (verify_clean_subdirectory(ce, error_type, o) &lt; 0)
<a name="l00877"></a>00877             <span class="keywordflow">return</span> -1;
<a name="l00878"></a>00878         <span class="keywordflow">return</span> 0;
<a name="l00879"></a>00879     }
<a name="l00880"></a>00880 
<a name="l00881"></a>00881     <span class="comment">/*</span>
<a name="l00882"></a>00882 <span class="comment">     * The previous round may already have decided to</span>
<a name="l00883"></a>00883 <span class="comment">     * delete this path, which is in a subdirectory that</span>
<a name="l00884"></a>00884 <span class="comment">     * is being replaced with a blob.</span>
<a name="l00885"></a>00885 <span class="comment">     */</span>
<a name="l00886"></a>00886     result = <a class="code" href="index_8c.html#a3931a94c55aad8bf8267f179ae846711">index_name_exists</a>(&amp;o-&gt;<a class="code" href="structunpack__trees__options.html#a091d6e59892b9009809e45dfb38c24da">result</a>, name, len, 0);
<a name="l00887"></a>00887     <span class="keywordflow">if</span> (result) {
<a name="l00888"></a>00888         <span class="keywordflow">if</span> (result-&gt;<a class="code" href="structcache__entry.html#a4dab14fd813a1bb6b67352674ff4afb2">ce_flags</a> &amp; <a class="code" href="index_8h.html#aa5ee599d9d7af67f19dba204ce9030c0">CE_REMOVE</a>)
<a name="l00889"></a>00889             <span class="keywordflow">return</span> 0;
<a name="l00890"></a>00890     }
<a name="l00891"></a>00891 
<a name="l00892"></a>00892     <span class="keywordflow">return</span> o-&gt;<a class="code" href="structunpack__trees__options.html#a41e304e12d552f063099ac1fb1e9a7f3">gently</a> ? -1 :
<a name="l00893"></a>00893         add_rejected_path(o, error_type, name);
<a name="l00894"></a>00894 }
<a name="l00895"></a>00895 <span class="preprocessor">#endif</span>
<a name="l00896"></a>00896 <span class="preprocessor"></span>
<a name="l00897"></a>00897 <span class="comment">/*</span>
<a name="l00898"></a>00898 <span class="comment"> * We do not want to remove or overwrite a working tree file that</span>
<a name="l00899"></a>00899 <span class="comment"> * is not tracked, unless it is ignored.</span>
<a name="l00900"></a>00900 <span class="comment"> */</span>
<a name="l00901"></a>00901 <span class="keyword">static</span> <span class="keywordtype">int</span> verify_absent_1(<span class="keyword">struct</span> <a class="code" href="structcache__entry.html">cache_entry</a> *ce,
<a name="l00902"></a>00902                            <span class="keyword">enum</span> <a class="code" href="unpack-trees_8h.html#ad2203a7733606ab3a15e195914f9d90d">unpack_trees_error_types</a> error_type,
<a name="l00903"></a>00903                            <span class="keyword">struct</span> <a class="code" href="structunpack__trees__options.html">unpack_trees_options</a> *o)
<a name="l00904"></a>00904 {
<a name="l00905"></a>00905 <span class="preprocessor">#if 0</span>
<a name="l00906"></a>00906 <span class="preprocessor"></span>    <span class="keywordtype">char</span> full_path[<a class="code" href="seafile_2common_2common_8h.html#a169a119979344433b9e2a39e4e8e334a">SEAF_PATH_MAX</a>];
<a name="l00907"></a>00907     <a class="code" href="seafile_2lib_2utils_8h.html#a5b073bcbe1516b249924c3702002d32c">SeafStat</a> st;
<a name="l00908"></a>00908 
<a name="l00909"></a>00909     <span class="keywordflow">if</span> (o-&gt;<a class="code" href="structunpack__trees__options.html#ae90060fa67398829899da620ab4dee87">index_only</a> || o-&gt;<a class="code" href="structunpack__trees__options.html#a6f9827ec3a41ca2d74b88eb418ab44ef">reset</a> || !o-&gt;<a class="code" href="structunpack__trees__options.html#a41b55dd4c6ef32c4938cc1b53936aacf">update</a>)
<a name="l00910"></a>00910         <span class="keywordflow">return</span> 0;
<a name="l00911"></a>00911 
<a name="l00912"></a>00912     snprintf (full_path, <a class="code" href="seafile_2common_2common_8h.html#a169a119979344433b9e2a39e4e8e334a">SEAF_PATH_MAX</a>, <span class="stringliteral">&quot;%s/%s&quot;</span>, o-&gt;<a class="code" href="structunpack__trees__options.html#a4a9bd1ef1d5e87af93c7ddce399e6b5f">base</a>, ce-&gt;<a class="code" href="structcache__entry.html#a792e4ea24cb16c76abe3229651e414a0">name</a>);
<a name="l00913"></a>00913     <span class="keywordflow">if</span> (!<a class="code" href="seafile_2lib_2utils_8c.html#ab46893ad4a68049bcd80eac8dcc2e299">seaf_stat</a> (full_path, &amp;st) &amp;&amp; S_ISREG(st.st_mode))
<a name="l00914"></a>00914         <span class="keywordflow">return</span> o-&gt;<a class="code" href="structunpack__trees__options.html#a41e304e12d552f063099ac1fb1e9a7f3">gently</a> ? -1:
<a name="l00915"></a>00915             add_rejected_path(o, error_type, ce-&gt;<a class="code" href="structcache__entry.html#a792e4ea24cb16c76abe3229651e414a0">name</a>);
<a name="l00916"></a>00916     <span class="comment">/* return check_ok_to_remove(ce-&gt;name, ce_namelen(ce), */</span>
<a name="l00917"></a>00917     <span class="comment">/*              ce_to_dtype(ce), ce, &amp;st, */</span>
<a name="l00918"></a>00918     <span class="comment">/*              error_type, o); */</span>
<a name="l00919"></a>00919 <span class="preprocessor">#endif</span>
<a name="l00920"></a>00920 <span class="preprocessor"></span>    <span class="keywordflow">return</span> 0;
<a name="l00921"></a>00921 }
<a name="l00922"></a>00922 
<a name="l00923"></a>00923 <span class="keyword">static</span> <span class="keywordtype">int</span> verify_absent(<span class="keyword">struct</span> <a class="code" href="structcache__entry.html">cache_entry</a> *ce,
<a name="l00924"></a>00924                          <span class="keyword">enum</span> <a class="code" href="unpack-trees_8h.html#ad2203a7733606ab3a15e195914f9d90d">unpack_trees_error_types</a> error_type,
<a name="l00925"></a>00925                          <span class="keyword">struct</span> <a class="code" href="structunpack__trees__options.html">unpack_trees_options</a> *o)
<a name="l00926"></a>00926 {
<a name="l00927"></a>00927     <span class="comment">/* if (!o-&gt;skip_sparse_checkout &amp;&amp; (ce-&gt;ce_flags &amp; CE_NEW_SKIP_WORKTREE)) */</span>
<a name="l00928"></a>00928     <span class="comment">/*      return 0; */</span>
<a name="l00929"></a>00929     <span class="keywordflow">return</span> verify_absent_1(ce, error_type, o);
<a name="l00930"></a>00930 }
<a name="l00931"></a>00931 
<a name="l00932"></a>00932 <span class="keyword">static</span> <span class="keywordtype">int</span> merged_entry(<span class="keyword">struct</span> <a class="code" href="structcache__entry.html">cache_entry</a> *merge, <span class="keyword">struct</span> <a class="code" href="structcache__entry.html">cache_entry</a> *old,
<a name="l00933"></a>00933                         <span class="keyword">struct</span> <a class="code" href="structunpack__trees__options.html">unpack_trees_options</a> *o)
<a name="l00934"></a>00934 {
<a name="l00935"></a>00935     <span class="keywordtype">int</span> update = <a class="code" href="index_8h.html#a1d46becf22e28d6f8bffa8ee949acb45">CE_UPDATE</a>;
<a name="l00936"></a>00936 
<a name="l00937"></a>00937     <span class="keywordflow">if</span> (!old) {
<a name="l00938"></a>00938         <span class="comment">/*</span>
<a name="l00939"></a>00939 <span class="comment">         * New index entries. In sparse checkout, the following</span>
<a name="l00940"></a>00940 <span class="comment">         * verify_absent() will be delayed until after</span>
<a name="l00941"></a>00941 <span class="comment">         * traverse_trees() finishes in unpack_trees(), then:</span>
<a name="l00942"></a>00942 <span class="comment">         *</span>
<a name="l00943"></a>00943 <span class="comment">         *  - CE_NEW_SKIP_WORKTREE will be computed correctly</span>
<a name="l00944"></a>00944 <span class="comment">         *  - verify_absent() be called again, this time with</span>
<a name="l00945"></a>00945 <span class="comment">         *    correct CE_NEW_SKIP_WORKTREE</span>
<a name="l00946"></a>00946 <span class="comment">         *</span>
<a name="l00947"></a>00947 <span class="comment">         * verify_absent() call here does nothing in sparse</span>
<a name="l00948"></a>00948 <span class="comment">         * checkout (i.e. o-&gt;skip_sparse_checkout == 0)</span>
<a name="l00949"></a>00949 <span class="comment">         */</span>
<a name="l00950"></a>00950         update |= <a class="code" href="index_8h.html#a586309b1feb22f9865dd8925c4a998b2">CE_ADDED</a>;
<a name="l00951"></a>00951         <span class="comment">/* merge-&gt;ce_flags |= CE_NEW_SKIP_WORKTREE; */</span>
<a name="l00952"></a>00952 
<a name="l00953"></a>00953         <span class="keywordflow">if</span> (verify_absent(merge, <a class="code" href="unpack-trees_8h.html#ad2203a7733606ab3a15e195914f9d90da1db238e6d4d9643e0682c61fbaff268f">ERROR_WOULD_LOSE_UNTRACKED_OVERWRITTEN</a>, o))
<a name="l00954"></a>00954             <span class="keywordflow">return</span> -1;
<a name="l00955"></a>00955         invalidate_ce_path(merge, o);
<a name="l00956"></a>00956     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (!(old-&gt;<a class="code" href="structcache__entry.html#a4dab14fd813a1bb6b67352674ff4afb2">ce_flags</a> &amp; <a class="code" href="index_8h.html#ae8aa611804959bb2ae74143429242dca">CE_CONFLICTED</a>)) {
<a name="l00957"></a>00957         <span class="comment">/*</span>
<a name="l00958"></a>00958 <span class="comment">         * See if we can re-use the old CE directly?</span>
<a name="l00959"></a>00959 <span class="comment">         * That way we get the uptodate stat info.</span>
<a name="l00960"></a>00960 <span class="comment">         *</span>
<a name="l00961"></a>00961 <span class="comment">         * This also removes the UPDATE flag on a match; otherwise</span>
<a name="l00962"></a>00962 <span class="comment">         * we will end up overwriting local changes in the work tree.</span>
<a name="l00963"></a>00963 <span class="comment">         */</span>
<a name="l00964"></a>00964         <span class="keywordflow">if</span> (same(old, merge)) {
<a name="l00965"></a>00965             copy_cache_entry(merge, old);
<a name="l00966"></a>00966             update = 0;
<a name="l00967"></a>00967         } <span class="keywordflow">else</span> {
<a name="l00968"></a>00968             <span class="keywordflow">if</span> (verify_uptodate(old, o))
<a name="l00969"></a>00969                 <span class="keywordflow">return</span> -1;
<a name="l00970"></a>00970             <span class="comment">/* Migrate old flags over */</span>
<a name="l00971"></a>00971             <span class="comment">/* update |= old-&gt;ce_flags &amp; (CE_SKIP_WORKTREE | CE_NEW_SKIP_WORKTREE); */</span>
<a name="l00972"></a>00972             invalidate_ce_path(old, o);
<a name="l00973"></a>00973         }
<a name="l00974"></a>00974     } <span class="keywordflow">else</span> {
<a name="l00975"></a>00975         <span class="comment">/*</span>
<a name="l00976"></a>00976 <span class="comment">         * Previously unmerged entry left as an existence</span>
<a name="l00977"></a>00977 <span class="comment">         * marker by read_index_unmerged();</span>
<a name="l00978"></a>00978 <span class="comment">         */</span>
<a name="l00979"></a>00979         invalidate_ce_path(old, o);
<a name="l00980"></a>00980     }
<a name="l00981"></a>00981 
<a name="l00982"></a>00982     <span class="comment">/* We need timestamp when checking out the file later. */</span>
<a name="l00983"></a>00983     <span class="keywordflow">if</span> (old) {
<a name="l00984"></a>00984         merge-&gt;<a class="code" href="structcache__entry.html#a75bbadf64b037b9a17fc1be53b1d1bea">current_mtime</a> = old-&gt;<a class="code" href="structcache__entry.html#a1c66f1f4e7773a56010e7ec64bd38a95">ce_mtime</a>.<a class="code" href="structcache__time64.html#ae37877c7f3995f5a44a4a9fd7bb91d46">sec</a>;
<a name="l00985"></a>00985     }
<a name="l00986"></a>00986 
<a name="l00987"></a>00987     add_entry(o, merge, update, <a class="code" href="index_8h.html#ae53d91d6dee84ef5e3793ab535ea01c0">CE_STAGEMASK</a>);
<a name="l00988"></a>00988     <span class="keywordflow">return</span> 1;
<a name="l00989"></a>00989 }
<a name="l00990"></a>00990 
<a name="l00991"></a>00991 <span class="keyword">static</span> <span class="keywordtype">int</span> deleted_entry(<span class="keyword">struct</span> <a class="code" href="structcache__entry.html">cache_entry</a> *ce, <span class="keyword">struct</span> <a class="code" href="structcache__entry.html">cache_entry</a> *old,
<a name="l00992"></a>00992                          <span class="keyword">struct</span> <a class="code" href="structunpack__trees__options.html">unpack_trees_options</a> *o)
<a name="l00993"></a>00993 {
<a name="l00994"></a>00994     <span class="comment">/* Did it exist in the index? */</span>
<a name="l00995"></a>00995     <span class="keywordflow">if</span> (!old) {
<a name="l00996"></a>00996         <span class="keywordflow">if</span> (verify_absent(ce, <a class="code" href="unpack-trees_8h.html#ad2203a7733606ab3a15e195914f9d90da4d8b523966bd36035e1d16c618720399">ERROR_WOULD_LOSE_UNTRACKED_REMOVED</a>, o))
<a name="l00997"></a>00997             <span class="keywordflow">return</span> -1;
<a name="l00998"></a>00998         <span class="keywordflow">return</span> 0;
<a name="l00999"></a>00999     }
<a name="l01000"></a>01000     <span class="keywordflow">if</span> (!(old-&gt;<a class="code" href="structcache__entry.html#a4dab14fd813a1bb6b67352674ff4afb2">ce_flags</a> &amp; <a class="code" href="index_8h.html#ae8aa611804959bb2ae74143429242dca">CE_CONFLICTED</a>) &amp;&amp; verify_uptodate(old, o))
<a name="l01001"></a>01001         <span class="keywordflow">return</span> -1;
<a name="l01002"></a>01002 
<a name="l01003"></a>01003     <span class="comment">/* We need timestamp when checking out the file later. */</span>
<a name="l01004"></a>01004     <span class="keywordflow">if</span> (old) {
<a name="l01005"></a>01005         ce-&gt;<a class="code" href="structcache__entry.html#a75bbadf64b037b9a17fc1be53b1d1bea">current_mtime</a> = old-&gt;<a class="code" href="structcache__entry.html#a1c66f1f4e7773a56010e7ec64bd38a95">ce_mtime</a>.<a class="code" href="structcache__time64.html#ae37877c7f3995f5a44a4a9fd7bb91d46">sec</a>;
<a name="l01006"></a>01006     }
<a name="l01007"></a>01007 
<a name="l01008"></a>01008     add_entry(o, ce, <a class="code" href="index_8h.html#aa5ee599d9d7af67f19dba204ce9030c0">CE_REMOVE</a>, <a class="code" href="index_8h.html#ae53d91d6dee84ef5e3793ab535ea01c0">CE_STAGEMASK</a>);
<a name="l01009"></a>01009     invalidate_ce_path(ce, o);
<a name="l01010"></a>01010     <span class="keywordflow">return</span> 1;
<a name="l01011"></a>01011 }
<a name="l01012"></a>01012 
<a name="l01013"></a>01013 <span class="keyword">static</span> <span class="keywordtype">int</span> keep_entry(<span class="keyword">struct</span> <a class="code" href="structcache__entry.html">cache_entry</a> *ce, <span class="keyword">struct</span> <a class="code" href="structunpack__trees__options.html">unpack_trees_options</a> *o)
<a name="l01014"></a>01014 {
<a name="l01015"></a>01015     add_entry(o, ce, 0, 0);
<a name="l01016"></a>01016     <span class="keywordflow">return</span> 1;
<a name="l01017"></a>01017 }
<a name="l01018"></a>01018 
<a name="l01019"></a>01019 <span class="preprocessor">#if DBRT_DEBUG</span>
<a name="l01020"></a>01020 <span class="preprocessor"></span><span class="keyword">static</span> <span class="keywordtype">void</span> show_stage_entry(FILE *o,
<a name="l01021"></a>01021                              <span class="keyword">const</span> <span class="keywordtype">char</span> *label, <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structcache__entry.html">cache_entry</a> *ce)
<a name="l01022"></a>01022 {
<a name="l01023"></a>01023     <span class="keywordflow">if</span> (!ce)
<a name="l01024"></a>01024         fprintf(o, <span class="stringliteral">&quot;%s (missing)\n&quot;</span>, label);
<a name="l01025"></a>01025     <span class="keywordflow">else</span>
<a name="l01026"></a>01026         fprintf(o, <span class="stringliteral">&quot;%s%06o %s %d\t%s\n&quot;</span>,
<a name="l01027"></a>01027                 label,
<a name="l01028"></a>01028                 ce-&gt;<a class="code" href="structcache__entry.html#a5fcbcc4e7265ae8150f136380ed92c05">ce_mode</a>,
<a name="l01029"></a>01029                 <a class="code" href="seafile_2lib_2utils_8h.html#add6d87c38909d280569fc0b360fd4d3e">sha1_to_hex</a>(ce-&gt;<a class="code" href="structcache__entry.html#a119ab5c5e9db495e6e5f8d301f01421c">sha1</a>),
<a name="l01030"></a>01030                 <a class="code" href="index_8h.html#a0379c411a3dc56c2d5ac0b1fcce22ead">ce_stage</a>(ce),
<a name="l01031"></a>01031                 ce-&gt;<a class="code" href="structcache__entry.html#a792e4ea24cb16c76abe3229651e414a0">name</a>);
<a name="l01032"></a>01032 }
<a name="l01033"></a>01033 <span class="preprocessor">#endif</span>
<a name="l01034"></a>01034 <span class="preprocessor"></span>
<a name="l01035"></a><a class="code" href="unpack-trees_8h.html#a6a3a9de82ab6c7def5eac0700ae1f312">01035</a> <span class="keywordtype">int</span> <a class="code" href="unpack-trees_8c.html#a6a3a9de82ab6c7def5eac0700ae1f312">threeway_merge</a>(<span class="keyword">struct</span> <a class="code" href="structcache__entry.html">cache_entry</a> **stages, <span class="keyword">struct</span> <a class="code" href="structunpack__trees__options.html">unpack_trees_options</a> *o)
<a name="l01036"></a>01036 {
<a name="l01037"></a>01037     <span class="keyword">struct </span><a class="code" href="structcache__entry.html">cache_entry</a> *index;
<a name="l01038"></a>01038     <span class="keyword">struct </span><a class="code" href="structcache__entry.html">cache_entry</a> *head;
<a name="l01039"></a>01039     <span class="keyword">struct </span><a class="code" href="structcache__entry.html">cache_entry</a> *remote = stages[o-&gt;<a class="code" href="structunpack__trees__options.html#ac3c76fcf0737031ee5783304d59c4865">head_idx</a> + 1];
<a name="l01040"></a>01040     <span class="keywordtype">int</span> count;
<a name="l01041"></a>01041     <span class="keywordtype">int</span> head_match = 0;
<a name="l01042"></a>01042     <span class="keywordtype">int</span> remote_match = 0;
<a name="l01043"></a>01043 
<a name="l01044"></a>01044     <span class="keywordtype">int</span> df_conflict_head = 0;
<a name="l01045"></a>01045     <span class="keywordtype">int</span> df_conflict_remote = 0;
<a name="l01046"></a>01046 
<a name="l01047"></a>01047     <span class="keywordtype">int</span> any_anc_missing = 0;
<a name="l01048"></a>01048     <span class="keywordtype">int</span> no_anc_exists = 1;
<a name="l01049"></a>01049     <span class="keywordtype">int</span> i;
<a name="l01050"></a>01050 
<a name="l01051"></a>01051     <span class="keywordflow">for</span> (i = 1; i &lt; o-&gt;<a class="code" href="structunpack__trees__options.html#ac3c76fcf0737031ee5783304d59c4865">head_idx</a>; i++) {
<a name="l01052"></a>01052         <span class="keywordflow">if</span> (!stages[i] || stages[i] == o-&gt;<a class="code" href="structunpack__trees__options.html#a509025e0763badd0c5ab5240aa7a10fc">df_conflict_entry</a>)
<a name="l01053"></a>01053             any_anc_missing = 1;
<a name="l01054"></a>01054         <span class="keywordflow">else</span>
<a name="l01055"></a>01055             no_anc_exists = 0;
<a name="l01056"></a>01056     }
<a name="l01057"></a>01057 
<a name="l01058"></a>01058     index = stages[0];
<a name="l01059"></a>01059     head = stages[o-&gt;<a class="code" href="structunpack__trees__options.html#ac3c76fcf0737031ee5783304d59c4865">head_idx</a>];
<a name="l01060"></a>01060 
<a name="l01061"></a>01061     <span class="keywordflow">if</span> (head == o-&gt;<a class="code" href="structunpack__trees__options.html#a509025e0763badd0c5ab5240aa7a10fc">df_conflict_entry</a>) {
<a name="l01062"></a>01062         df_conflict_head = 1;
<a name="l01063"></a>01063         head = NULL;
<a name="l01064"></a>01064     }
<a name="l01065"></a>01065 
<a name="l01066"></a>01066     <span class="keywordflow">if</span> (remote == o-&gt;<a class="code" href="structunpack__trees__options.html#a509025e0763badd0c5ab5240aa7a10fc">df_conflict_entry</a>) {
<a name="l01067"></a>01067         df_conflict_remote = 1;
<a name="l01068"></a>01068         remote = NULL;
<a name="l01069"></a>01069     }
<a name="l01070"></a>01070 
<a name="l01071"></a>01071     <span class="comment">/*</span>
<a name="l01072"></a>01072 <span class="comment">     * First, if there&#39;s a #16 situation, note that to prevent #13</span>
<a name="l01073"></a>01073 <span class="comment">     * and #14.</span>
<a name="l01074"></a>01074 <span class="comment">     */</span>
<a name="l01075"></a>01075     <span class="keywordflow">if</span> (!same(remote, head)) {
<a name="l01076"></a>01076         <span class="keywordflow">for</span> (i = 1; i &lt; o-&gt;<a class="code" href="structunpack__trees__options.html#ac3c76fcf0737031ee5783304d59c4865">head_idx</a>; i++) {
<a name="l01077"></a>01077             <span class="keywordflow">if</span> (same(stages[i], head)) {
<a name="l01078"></a>01078                 head_match = i;
<a name="l01079"></a>01079             }
<a name="l01080"></a>01080             <span class="keywordflow">if</span> (same(stages[i], remote)) {
<a name="l01081"></a>01081                 remote_match = i;
<a name="l01082"></a>01082             }
<a name="l01083"></a>01083         }
<a name="l01084"></a>01084     }
<a name="l01085"></a>01085 
<a name="l01086"></a>01086     <span class="comment">/*</span>
<a name="l01087"></a>01087 <span class="comment">     * We start with cases where the index is allowed to match</span>
<a name="l01088"></a>01088 <span class="comment">     * something other than the head: #14(ALT) and #2ALT, where it</span>
<a name="l01089"></a>01089 <span class="comment">     * is permitted to match the result instead.</span>
<a name="l01090"></a>01090 <span class="comment">     */</span>
<a name="l01091"></a>01091     <span class="comment">/* #14, #14ALT, #2ALT */</span>
<a name="l01092"></a>01092     <span class="keywordflow">if</span> (remote &amp;&amp; !df_conflict_head &amp;&amp; head_match &amp;&amp; !remote_match) {
<a name="l01093"></a>01093         <span class="comment">/* if (index &amp;&amp; !same(index, remote) &amp;&amp; !same(index, head)) */</span>
<a name="l01094"></a>01094         <span class="comment">/*     return o-&gt;gently ? -1 : reject_merge(index, o); */</span>
<a name="l01095"></a>01095         <span class="keywordflow">return</span> merged_entry(remote, index, o);
<a name="l01096"></a>01096     }
<a name="l01097"></a>01097     <span class="comment">/*</span>
<a name="l01098"></a>01098 <span class="comment">     * If we have an entry in the index cache, then we want to</span>
<a name="l01099"></a>01099 <span class="comment">     * make sure that it matches head.</span>
<a name="l01100"></a>01100 <span class="comment">     */</span>
<a name="l01101"></a>01101     <span class="comment">/* if (index &amp;&amp; !same(index, head)) */</span>
<a name="l01102"></a>01102     <span class="comment">/*     return o-&gt;gently ? -1 : reject_merge(index, o); */</span>
<a name="l01103"></a>01103 
<a name="l01104"></a>01104     <span class="keywordflow">if</span> (head) {
<a name="l01105"></a>01105         <span class="comment">/* #5ALT, #15 */</span>
<a name="l01106"></a>01106         <span class="keywordflow">if</span> (same(head, remote))
<a name="l01107"></a>01107             <span class="keywordflow">return</span> merged_entry(remote, index, o);
<a name="l01108"></a>01108         <span class="comment">/* #13, #3ALT */</span>
<a name="l01109"></a>01109         <span class="keywordflow">if</span> (!df_conflict_remote &amp;&amp; remote_match &amp;&amp; !head_match)
<a name="l01110"></a>01110             <span class="keywordflow">return</span> merged_entry(head, index, o);
<a name="l01111"></a>01111     }
<a name="l01112"></a>01112 
<a name="l01113"></a>01113     <span class="comment">/* #1 */</span>
<a name="l01114"></a>01114     <span class="keywordflow">if</span> (!head &amp;&amp; !remote &amp;&amp; any_anc_missing)
<a name="l01115"></a>01115         <span class="keywordflow">return</span> 0;
<a name="l01116"></a>01116 
<a name="l01117"></a>01117     <span class="comment">/*</span>
<a name="l01118"></a>01118 <span class="comment">     * Under the &quot;aggressive&quot; rule, we resolve mostly trivial</span>
<a name="l01119"></a>01119 <span class="comment">     * cases that we historically had git-merge-one-file resolve.</span>
<a name="l01120"></a>01120 <span class="comment">     */</span>
<a name="l01121"></a>01121     <span class="keywordflow">if</span> (o-&gt;<a class="code" href="structunpack__trees__options.html#a5995e2147c2e837d55f32a42fa64b582">aggressive</a>) {
<a name="l01122"></a>01122         <span class="keywordtype">int</span> head_deleted = !head;
<a name="l01123"></a>01123         <span class="keywordtype">int</span> remote_deleted = !remote;
<a name="l01124"></a>01124         <span class="keyword">struct </span><a class="code" href="structcache__entry.html">cache_entry</a> *ce = NULL;
<a name="l01125"></a>01125 
<a name="l01126"></a>01126         <span class="keywordflow">if</span> (index)
<a name="l01127"></a>01127             ce = index;
<a name="l01128"></a>01128         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (head)
<a name="l01129"></a>01129             ce = head;
<a name="l01130"></a>01130         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (remote)
<a name="l01131"></a>01131             ce = remote;
<a name="l01132"></a>01132         <span class="keywordflow">else</span> {
<a name="l01133"></a>01133             <span class="keywordflow">for</span> (i = 1; i &lt; o-&gt;<a class="code" href="structunpack__trees__options.html#ac3c76fcf0737031ee5783304d59c4865">head_idx</a>; i++) {
<a name="l01134"></a>01134                 <span class="keywordflow">if</span> (stages[i] &amp;&amp; stages[i] != o-&gt;<a class="code" href="structunpack__trees__options.html#a509025e0763badd0c5ab5240aa7a10fc">df_conflict_entry</a>) {
<a name="l01135"></a>01135                     ce = stages[i];
<a name="l01136"></a>01136                     <span class="keywordflow">break</span>;
<a name="l01137"></a>01137                 }
<a name="l01138"></a>01138             }
<a name="l01139"></a>01139         }
<a name="l01140"></a>01140 
<a name="l01141"></a>01141         <span class="comment">/*</span>
<a name="l01142"></a>01142 <span class="comment">         * Deleted in both.</span>
<a name="l01143"></a>01143 <span class="comment">         * Deleted in one and unchanged in the other.</span>
<a name="l01144"></a>01144 <span class="comment">         */</span>
<a name="l01145"></a>01145         <span class="keywordflow">if</span> ((head_deleted &amp;&amp; remote_deleted) ||
<a name="l01146"></a>01146             (head_deleted &amp;&amp; remote &amp;&amp; remote_match) ||
<a name="l01147"></a>01147             (remote_deleted &amp;&amp; head &amp;&amp; head_match)) {
<a name="l01148"></a>01148             <span class="keywordflow">if</span> (index)
<a name="l01149"></a>01149                 <span class="keywordflow">return</span> deleted_entry(index, index, o);
<a name="l01150"></a>01150             <span class="keywordflow">if</span> (ce &amp;&amp; !head_deleted) {
<a name="l01151"></a>01151                 <span class="keywordflow">if</span> (verify_absent(ce, <a class="code" href="unpack-trees_8h.html#ad2203a7733606ab3a15e195914f9d90da4d8b523966bd36035e1d16c618720399">ERROR_WOULD_LOSE_UNTRACKED_REMOVED</a>, o))
<a name="l01152"></a>01152                     <span class="keywordflow">return</span> -1;
<a name="l01153"></a>01153             }
<a name="l01154"></a>01154             <span class="keywordflow">return</span> 0;
<a name="l01155"></a>01155         }
<a name="l01156"></a>01156         <span class="comment">/*</span>
<a name="l01157"></a>01157 <span class="comment">         * Added in both, identically.</span>
<a name="l01158"></a>01158 <span class="comment">         */</span>
<a name="l01159"></a>01159         <span class="keywordflow">if</span> (no_anc_exists &amp;&amp; head &amp;&amp; remote &amp;&amp; same(head, remote))
<a name="l01160"></a>01160             <span class="keywordflow">return</span> merged_entry(head, index, o);
<a name="l01161"></a>01161 
<a name="l01162"></a>01162     }
<a name="l01163"></a>01163 
<a name="l01164"></a>01164     <span class="comment">/* Below are &quot;no merge&quot; cases, which require that the index be</span>
<a name="l01165"></a>01165 <span class="comment">     * up-to-date to avoid the files getting overwritten with</span>
<a name="l01166"></a>01166 <span class="comment">     * conflict resolution files.</span>
<a name="l01167"></a>01167 <span class="comment">     */</span>
<a name="l01168"></a>01168     <span class="keywordflow">if</span> (index) {
<a name="l01169"></a>01169         <span class="keywordflow">if</span> (verify_uptodate(index, o))
<a name="l01170"></a>01170             <span class="keywordflow">return</span> -1;
<a name="l01171"></a>01171     }
<a name="l01172"></a>01172 
<a name="l01173"></a>01173     o-&gt;<a class="code" href="structunpack__trees__options.html#a8b7cd690b47d941150a44a40164370bb">nontrivial_merge</a> = 1;
<a name="l01174"></a>01174 
<a name="l01175"></a>01175     <span class="comment">/* #2, #3, #4, #6, #7, #9, #10, #11. */</span>
<a name="l01176"></a>01176     count = 0;
<a name="l01177"></a>01177     <span class="keywordflow">if</span> (!head_match || !remote_match) {
<a name="l01178"></a>01178         <span class="keywordflow">for</span> (i = 1; i &lt; o-&gt;<a class="code" href="structunpack__trees__options.html#ac3c76fcf0737031ee5783304d59c4865">head_idx</a>; i++) {
<a name="l01179"></a>01179             <span class="keywordflow">if</span> (stages[i] &amp;&amp; stages[i] != o-&gt;<a class="code" href="structunpack__trees__options.html#a509025e0763badd0c5ab5240aa7a10fc">df_conflict_entry</a>) {
<a name="l01180"></a>01180                 keep_entry(stages[i], o);
<a name="l01181"></a>01181                 count++;
<a name="l01182"></a>01182                 <span class="keywordflow">break</span>;
<a name="l01183"></a>01183             }
<a name="l01184"></a>01184         }
<a name="l01185"></a>01185     }
<a name="l01186"></a>01186 <span class="preprocessor">#if DBRT_DEBUG</span>
<a name="l01187"></a>01187 <span class="preprocessor"></span>    <span class="keywordflow">else</span> {
<a name="l01188"></a>01188         fprintf(stderr, <span class="stringliteral">&quot;read-tree: warning #16 detected\n&quot;</span>);
<a name="l01189"></a>01189         show_stage_entry(stderr, <span class="stringliteral">&quot;head   &quot;</span>, stages[head_match]);
<a name="l01190"></a>01190         show_stage_entry(stderr, <span class="stringliteral">&quot;remote &quot;</span>, stages[remote_match]);
<a name="l01191"></a>01191     }
<a name="l01192"></a>01192 <span class="preprocessor">#endif</span>
<a name="l01193"></a>01193 <span class="preprocessor"></span>
<a name="l01194"></a>01194     <span class="comment">/* We need ctime and mtime of index to handle worktree conflict later. */</span>
<a name="l01195"></a>01195     <span class="keywordflow">if</span> (head &amp;&amp; index) {
<a name="l01196"></a>01196         head-&gt;<a class="code" href="structcache__entry.html#a75bbadf64b037b9a17fc1be53b1d1bea">current_mtime</a> = index-&gt;<a class="code" href="structcache__entry.html#a1c66f1f4e7773a56010e7ec64bd38a95">ce_mtime</a>.<a class="code" href="structcache__time64.html#ae37877c7f3995f5a44a4a9fd7bb91d46">sec</a>;
<a name="l01197"></a>01197     }
<a name="l01198"></a>01198 
<a name="l01199"></a>01199     <span class="keywordflow">if</span> (head) { count += keep_entry(head, o); }
<a name="l01200"></a>01200     <span class="keywordflow">if</span> (remote) { count += keep_entry(remote, o); }
<a name="l01201"></a>01201     <span class="keywordflow">return</span> count;
<a name="l01202"></a>01202 }
<a name="l01203"></a>01203 
<a name="l01204"></a>01204 <span class="comment">/*</span>
<a name="l01205"></a>01205 <span class="comment"> * Two-way merge.</span>
<a name="l01206"></a>01206 <span class="comment"> *</span>
<a name="l01207"></a>01207 <span class="comment"> * The rule is to &quot;carry forward&quot; what is in the index without losing</span>
<a name="l01208"></a>01208 <span class="comment"> * information across a &quot;fast-forward&quot;, favoring a successful merge</span>
<a name="l01209"></a>01209 <span class="comment"> * over a merge failure when it makes sense.  For details of the</span>
<a name="l01210"></a>01210 <span class="comment"> * &quot;carry forward&quot; rule, please see &lt;Documentation/git-read-tree.txt&gt;.</span>
<a name="l01211"></a>01211 <span class="comment"> *</span>
<a name="l01212"></a>01212 <span class="comment"> */</span>
<a name="l01213"></a><a class="code" href="unpack-trees_8h.html#a37f4950a59ff1ce85ed1bf91eeea7054">01213</a> <span class="keywordtype">int</span> <a class="code" href="unpack-trees_8c.html#a37f4950a59ff1ce85ed1bf91eeea7054">twoway_merge</a>(<span class="keyword">struct</span> <a class="code" href="structcache__entry.html">cache_entry</a> **src, <span class="keyword">struct</span> <a class="code" href="structunpack__trees__options.html">unpack_trees_options</a> *o)
<a name="l01214"></a>01214 {
<a name="l01215"></a>01215     <span class="keyword">struct </span><a class="code" href="structcache__entry.html">cache_entry</a> *current = src[0];
<a name="l01216"></a>01216     <span class="keyword">struct </span><a class="code" href="structcache__entry.html">cache_entry</a> *oldtree = src[1];
<a name="l01217"></a>01217     <span class="keyword">struct </span><a class="code" href="structcache__entry.html">cache_entry</a> *newtree = src[2];
<a name="l01218"></a>01218 
<a name="l01219"></a>01219     <span class="keywordflow">if</span> (o-&gt;<a class="code" href="structunpack__trees__options.html#a284fdf8bd0576d2999e1e199e1131346">merge_size</a> != 2) {
<a name="l01220"></a>01220         g_warning (<span class="stringliteral">&quot;Cannot do a twoway merge of %d trees&quot;</span>, o-&gt;<a class="code" href="structunpack__trees__options.html#a284fdf8bd0576d2999e1e199e1131346">merge_size</a>);
<a name="l01221"></a>01221         <span class="keywordflow">return</span> -1;
<a name="l01222"></a>01222     }
<a name="l01223"></a>01223 
<a name="l01224"></a>01224     <span class="keywordflow">if</span> (oldtree == o-&gt;<a class="code" href="structunpack__trees__options.html#a509025e0763badd0c5ab5240aa7a10fc">df_conflict_entry</a>)
<a name="l01225"></a>01225         oldtree = NULL;
<a name="l01226"></a>01226     <span class="keywordflow">if</span> (newtree == o-&gt;<a class="code" href="structunpack__trees__options.html#a509025e0763badd0c5ab5240aa7a10fc">df_conflict_entry</a>)
<a name="l01227"></a>01227         newtree = NULL;
<a name="l01228"></a>01228 
<a name="l01229"></a>01229     <span class="keywordflow">if</span> (current) {
<a name="l01230"></a>01230         <span class="keywordflow">if</span> ((!oldtree &amp;&amp; !newtree) || <span class="comment">/* 4 and 5 */</span>
<a name="l01231"></a>01231             (!oldtree &amp;&amp; newtree &amp;&amp;
<a name="l01232"></a>01232              same(current, newtree)) || <span class="comment">/* 6 and 7 */</span>
<a name="l01233"></a>01233             (oldtree &amp;&amp; newtree &amp;&amp;
<a name="l01234"></a>01234              same(oldtree, newtree)) || <span class="comment">/* 14 and 15 */</span>
<a name="l01235"></a>01235             (oldtree &amp;&amp; newtree &amp;&amp;
<a name="l01236"></a>01236              !same(oldtree, newtree) &amp;&amp; <span class="comment">/* 18 and 19 */</span>
<a name="l01237"></a>01237              same(current, newtree))) {
<a name="l01238"></a>01238             <span class="keywordflow">return</span> keep_entry(current, o);
<a name="l01239"></a>01239         }
<a name="l01240"></a>01240         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (oldtree &amp;&amp; !newtree &amp;&amp; same(current, oldtree)) {
<a name="l01241"></a>01241             <span class="comment">/* 10 or 11 */</span>
<a name="l01242"></a>01242             <span class="keywordflow">return</span> deleted_entry(oldtree, current, o);
<a name="l01243"></a>01243         }
<a name="l01244"></a>01244         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (oldtree &amp;&amp; newtree &amp;&amp;
<a name="l01245"></a>01245                  same(current, oldtree) &amp;&amp; !same(current, newtree)) {
<a name="l01246"></a>01246             <span class="comment">/* 20 or 21 */</span>
<a name="l01247"></a>01247             <span class="keywordflow">return</span> merged_entry(newtree, current, o);
<a name="l01248"></a>01248         }
<a name="l01249"></a>01249         <span class="keywordflow">else</span> {
<a name="l01250"></a>01250             <span class="comment">/* all other failures */</span>
<a name="l01251"></a>01251             <span class="keywordflow">if</span> (oldtree)
<a name="l01252"></a>01252                 <span class="keywordflow">return</span> o-&gt;<a class="code" href="structunpack__trees__options.html#a41e304e12d552f063099ac1fb1e9a7f3">gently</a> ? -1 : reject_merge(oldtree, o);
<a name="l01253"></a>01253             <span class="keywordflow">if</span> (current)
<a name="l01254"></a>01254                 <span class="keywordflow">return</span> o-&gt;<a class="code" href="structunpack__trees__options.html#a41e304e12d552f063099ac1fb1e9a7f3">gently</a> ? -1 : reject_merge(current, o);
<a name="l01255"></a>01255             <span class="keywordflow">if</span> (newtree)
<a name="l01256"></a>01256                 <span class="keywordflow">return</span> o-&gt;<a class="code" href="structunpack__trees__options.html#a41e304e12d552f063099ac1fb1e9a7f3">gently</a> ? -1 : reject_merge(newtree, o);
<a name="l01257"></a>01257             <span class="keywordflow">return</span> -1;
<a name="l01258"></a>01258         }
<a name="l01259"></a>01259     }
<a name="l01260"></a>01260     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (newtree) {
<a name="l01261"></a>01261         <span class="keywordflow">if</span> (oldtree &amp;&amp; !o-&gt;<a class="code" href="structunpack__trees__options.html#ab6aee2819c20555d29c0e7f18b4a3df3">initial_checkout</a>) {
<a name="l01262"></a>01262             <span class="comment">/*</span>
<a name="l01263"></a>01263 <span class="comment">             * deletion of the path was staged;</span>
<a name="l01264"></a>01264 <span class="comment">             */</span>
<a name="l01265"></a>01265             <span class="keywordflow">if</span> (same(oldtree, newtree))
<a name="l01266"></a>01266                 <span class="keywordflow">return</span> 1;
<a name="l01267"></a>01267             <span class="keywordflow">return</span> reject_merge(oldtree, o);
<a name="l01268"></a>01268         }
<a name="l01269"></a>01269         <span class="keywordflow">return</span> merged_entry(newtree, current, o);
<a name="l01270"></a>01270     }
<a name="l01271"></a>01271     <span class="keywordflow">return</span> deleted_entry(oldtree, current, o);
<a name="l01272"></a>01272 }
<a name="l01273"></a>01273 
<a name="l01274"></a>01274 <span class="comment">/*</span>
<a name="l01275"></a>01275 <span class="comment"> * One-way merge.</span>
<a name="l01276"></a>01276 <span class="comment"> *</span>
<a name="l01277"></a>01277 <span class="comment"> * The rule is:</span>
<a name="l01278"></a>01278 <span class="comment"> * - take the stat information from stage0, take the data from stage1</span>
<a name="l01279"></a>01279 <span class="comment"> */</span>
<a name="l01280"></a><a class="code" href="unpack-trees_8h.html#afc1a414641a3c7c31083a389fcfc5ec6">01280</a> <span class="keywordtype">int</span> <a class="code" href="unpack-trees_8c.html#afc1a414641a3c7c31083a389fcfc5ec6">oneway_merge</a>(<span class="keyword">struct</span> <a class="code" href="structcache__entry.html">cache_entry</a> **src, <span class="keyword">struct</span> <a class="code" href="structunpack__trees__options.html">unpack_trees_options</a> *o)
<a name="l01281"></a>01281 {
<a name="l01282"></a>01282     <span class="keyword">struct </span><a class="code" href="structcache__entry.html">cache_entry</a> *old = src[0];
<a name="l01283"></a>01283     <span class="keyword">struct </span><a class="code" href="structcache__entry.html">cache_entry</a> *a = src[1];
<a name="l01284"></a>01284 
<a name="l01285"></a>01285     <span class="keywordflow">if</span> (o-&gt;<a class="code" href="structunpack__trees__options.html#a284fdf8bd0576d2999e1e199e1131346">merge_size</a> != 1) {
<a name="l01286"></a>01286         g_warning(<span class="stringliteral">&quot;Cannot do a oneway merge of %d trees&quot;</span>,
<a name="l01287"></a>01287                   o-&gt;<a class="code" href="structunpack__trees__options.html#a284fdf8bd0576d2999e1e199e1131346">merge_size</a>);
<a name="l01288"></a>01288         <span class="keywordflow">return</span> -1;
<a name="l01289"></a>01289     }
<a name="l01290"></a>01290 
<a name="l01291"></a>01291     <span class="keywordflow">if</span> (!a || a == o-&gt;<a class="code" href="structunpack__trees__options.html#a509025e0763badd0c5ab5240aa7a10fc">df_conflict_entry</a>)
<a name="l01292"></a>01292         <span class="keywordflow">return</span> deleted_entry(old, old, o);
<a name="l01293"></a>01293 
<a name="l01294"></a>01294     <span class="keywordflow">if</span> (old &amp;&amp; same(old, a)) {
<a name="l01295"></a>01295         <span class="keywordtype">int</span> update = 0;
<a name="l01296"></a>01296         <span class="keywordflow">if</span> (o-&gt;<a class="code" href="structunpack__trees__options.html#a6f9827ec3a41ca2d74b88eb418ab44ef">reset</a> &amp;&amp; !<a class="code" href="index_8h.html#ad55a581e1adce0475f3b6e044e8b3411">ce_uptodate</a>(old) &amp;&amp; !<a class="code" href="index_8h.html#aa9cb581aaeefbbd01aa6c7997f44a5e4">ce_skip_worktree</a>(old)) {
<a name="l01297"></a>01297             <a class="code" href="seafile_2lib_2utils_8h.html#a5b073bcbe1516b249924c3702002d32c">SeafStat</a> st;
<a name="l01298"></a>01298             <span class="keywordtype">char</span> full_path[<a class="code" href="seafile_2common_2common_8h.html#a169a119979344433b9e2a39e4e8e334a">SEAF_PATH_MAX</a>];
<a name="l01299"></a>01299             snprintf (full_path, <a class="code" href="seafile_2common_2common_8h.html#a169a119979344433b9e2a39e4e8e334a">SEAF_PATH_MAX</a>, <span class="stringliteral">&quot;%s/%s&quot;</span>, o-&gt;<a class="code" href="structunpack__trees__options.html#a4a9bd1ef1d5e87af93c7ddce399e6b5f">base</a>, old-&gt;<a class="code" href="structcache__entry.html#a792e4ea24cb16c76abe3229651e414a0">name</a>);
<a name="l01300"></a>01300             <span class="keywordflow">if</span> (<a class="code" href="seafile_2lib_2utils_8c.html#ab46893ad4a68049bcd80eac8dcc2e299">seaf_stat</a> (full_path, &amp;st) ||
<a name="l01301"></a>01301                 <a class="code" href="index_8c.html#a2a76921da1fbb55b7b33983ca9e8edc4">ie_match_stat</a>(old, &amp;st, <a class="code" href="index_8h.html#a3ecb29f06d046b6a99ed2148f91ae0c3">CE_MATCH_IGNORE_VALID</a>|<a class="code" href="index_8h.html#abd49280eba10dafd6f24cc3a6eab6313">CE_MATCH_IGNORE_SKIP_WORKTREE</a>))
<a name="l01302"></a>01302                 update |= <a class="code" href="index_8h.html#a1d46becf22e28d6f8bffa8ee949acb45">CE_UPDATE</a>;
<a name="l01303"></a>01303         }
<a name="l01304"></a>01304         add_entry(o, old, update, 0);
<a name="l01305"></a>01305         <span class="keywordflow">return</span> 0;
<a name="l01306"></a>01306     }
<a name="l01307"></a>01307     <span class="keywordflow">return</span> merged_entry(a, old, o);
<a name="l01308"></a>01308 }
<a name="l01309"></a>01309 
<a name="l01310"></a>01310 <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">char</span> *unpack_errors[<a class="code" href="unpack-trees_8h.html#ad2203a7733606ab3a15e195914f9d90da2762d247410fe30bf9bee28b1091dc92">NB_UNPACK_TREES_ERROR_TYPES</a>] = {
<a name="l01311"></a>01311     <span class="comment">/* ERROR_WOULD_OVERWRITE */</span>
<a name="l01312"></a>01312     <span class="stringliteral">&quot;%s: Local changes would be overwritten. Cannot %s.\n&quot;</span>,
<a name="l01313"></a>01313 
<a name="l01314"></a>01314     <span class="comment">/* ERROR_NOT_UPTODATE_FILE */</span>
<a name="l01315"></a>01315     <span class="stringliteral">&quot;%s: Local changes would be overwritten. Cannot %s.\n&quot;</span>,
<a name="l01316"></a>01316 
<a name="l01317"></a>01317     <span class="comment">/* ERROR_NOT_UPTODATE_DIR */</span>
<a name="l01318"></a>01318     <span class="stringliteral">&quot;%s: Untracked files in this directory would be lost. Cannot %s.\n&quot;</span>,
<a name="l01319"></a>01319 
<a name="l01320"></a>01320     <span class="comment">/* ERROR_WOULD_LOSE_UNTRACKED_OVERWRITTEN */</span>
<a name="l01321"></a>01321     <span class="stringliteral">&quot;%s: This file is untracked and would be overwritten. Cannot %s.\n&quot;</span>,
<a name="l01322"></a>01322 
<a name="l01323"></a>01323     <span class="comment">/* ERROR_WOULD_LOSE_UNTRACKED_REMOVED */</span>
<a name="l01324"></a>01324     <span class="stringliteral">&quot;%s: This file is untracked and would be removed. Cannot %s.\n&quot;</span>,
<a name="l01325"></a>01325 };
<a name="l01326"></a>01326 
<a name="l01327"></a>01327 <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">char</span> *opr_str[<a class="code" href="unpack-trees_8h.html#abed82baf7f470b522273a3e37c24c600abae937684f866d26d4b9caa73260828e">N_OPR_TYPES</a>] = {
<a name="l01328"></a>01328     <span class="stringliteral">&quot;checkout&quot;</span>,
<a name="l01329"></a>01329     <span class="stringliteral">&quot;merge&quot;</span>,
<a name="l01330"></a>01330 };
<a name="l01331"></a>01331 
<a name="l01332"></a>01332 gboolean
<a name="l01333"></a><a class="code" href="unpack-trees_8h.html#a795a271a95b2bc0ef892ee87f48a0c62">01333</a> <a class="code" href="unpack-trees_8c.html#a795a271a95b2bc0ef892ee87f48a0c62">get_unpack_trees_error_msgs</a>(<span class="keyword">struct</span> <a class="code" href="structunpack__trees__options.html">unpack_trees_options</a> *o, GString *msgbuf, <span class="keywordtype">int</span> opr_type)
<a name="l01334"></a>01334 {
<a name="l01335"></a>01335     <span class="keywordtype">int</span> e;
<a name="l01336"></a>01336     gboolean has_error = FALSE;
<a name="l01337"></a>01337     <span class="keywordflow">for</span> (e = 0; e &lt; <a class="code" href="unpack-trees_8h.html#ad2203a7733606ab3a15e195914f9d90da2762d247410fe30bf9bee28b1091dc92">NB_UNPACK_TREES_ERROR_TYPES</a>; e++) {
<a name="l01338"></a>01338         GList *rejects = o-&gt;<a class="code" href="structunpack__trees__options.html#a423e136b07515c8f4736a23e74334b64">unpack_rejects</a>[e];
<a name="l01339"></a>01339         GList *rej;
<a name="l01340"></a>01340         <span class="keywordflow">if</span> (rejects) {
<a name="l01341"></a>01341             has_error = TRUE;
<a name="l01342"></a>01342             <span class="keywordflow">for</span> (rej = rejects; rej; rej = rej-&gt;next)
<a name="l01343"></a>01343                 g_string_append_printf (msgbuf,
<a name="l01344"></a>01344                                         unpack_errors[e],
<a name="l01345"></a>01345                                         (<span class="keywordtype">char</span> *) (rej-&gt;data),
<a name="l01346"></a>01346                                         opr_str[opr_type]);
<a name="l01347"></a>01347             <span class="comment">/*</span>
<a name="l01348"></a>01348 <span class="comment">             * Dont need to free strings in the list.</span>
<a name="l01349"></a>01349 <span class="comment">             * They&#39;re in ce-&gt;name, which will be freeed later.</span>
<a name="l01350"></a>01350 <span class="comment">             */</span>
<a name="l01351"></a>01351             <a class="code" href="seafile_2lib_2utils_8c.html#af85d9a3e4ab846a6eedfb509508367f2">string_list_free</a> (rejects);
<a name="l01352"></a>01352         }
<a name="l01353"></a>01353     }
<a name="l01354"></a>01354     <span class="keywordflow">return</span> has_error;
<a name="l01355"></a>01355 }
</pre></div></div><!-- contents -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>



<hr class="footer"/><address class="footer"><small>
Generated on Wed Aug 19 2015 03:28:55 for My Project by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.7.6.1
</small></address>

</body>
</html>

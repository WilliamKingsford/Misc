<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>My Project: seafile-4.1.2/common/processors/blocktx-common-impl-v2.h Source File</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />

<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>

</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">My Project
   
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.6.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>File&#160;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="headertitle">
<div class="title">seafile-4.1.2/common/processors/blocktx-common-impl-v2.h</div>  </div>
</div><!--header-->
<div class="contents">
<a href="blocktx-common-impl-v2_8h.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="preprocessor">#ifndef BLOCKTX_COMMON_IMPL_V2_H</span>
<a name="l00002"></a>00002 <span class="preprocessor"></span><span class="preprocessor">#define BLOCKTX_COMMON_IMPL_V2_H</span>
<a name="l00003"></a>00003 <span class="preprocessor"></span>
<a name="l00004"></a>00004 <span class="preprocessor">#include &quot;common.h&quot;</span>
<a name="l00005"></a>00005 <span class="preprocessor">#include &quot;utils.h&quot;</span>
<a name="l00006"></a>00006 
<a name="l00007"></a><a class="code" href="blocktx-common-impl-v2_8h.html#a05d1af42442c934b555896d3fe55c79e">00007</a> <span class="preprocessor">#define DEBUG_FLAG SEAFILE_DEBUG_TRANSFER</span>
<a name="l00008"></a>00008 <span class="preprocessor"></span><span class="preprocessor">#include &quot;log.h&quot;</span>
<a name="l00009"></a>00009 
<a name="l00010"></a><a class="code" href="blocktx-common-impl-v2_8h.html#a69df665dae8be77f3fceff8d0eaf6cf8">00010</a> <span class="preprocessor">#define SC_SEND_PORT    &quot;301&quot;</span>
<a name="l00011"></a><a class="code" href="blocktx-common-impl-v2_8h.html#a5d7c6432dc3c709a8b503e7ce446c5d2">00011</a> <span class="preprocessor"></span><span class="preprocessor">#define SS_SEND_PORT    &quot;PORT&quot;</span>
<a name="l00012"></a><a class="code" href="blocktx-common-impl-v2_8h.html#a363f56128af6e41c7980bd7b46fae7cf">00012</a> <span class="preprocessor"></span><span class="preprocessor">#define SC_GET_PORT     &quot;302&quot;</span>
<a name="l00013"></a><a class="code" href="blocktx-common-impl-v2_8h.html#a5783dd77ead790f0d719da714c4f2576">00013</a> <span class="preprocessor"></span><span class="preprocessor">#define SS_GET_PORT     &quot;GET PORT&quot;</span>
<a name="l00014"></a><a class="code" href="blocktx-common-impl-v2_8h.html#aee84de836cdb5887721db8f177cfb117">00014</a> <span class="preprocessor"></span><span class="preprocessor">#define SC_GET_BLOCK    &quot;303&quot;</span>
<a name="l00015"></a><a class="code" href="blocktx-common-impl-v2_8h.html#a6c2c667b16833b0a407261727f2b0101">00015</a> <span class="preprocessor"></span><span class="preprocessor">#define SS_GET_BLOCK    &quot;GET BLOCK&quot;</span>
<a name="l00016"></a><a class="code" href="blocktx-common-impl-v2_8h.html#a1e76bf080b96abf54e0b329e1b454b80">00016</a> <span class="preprocessor"></span><span class="preprocessor">#define SC_BBITMAP      &quot;304&quot;</span>
<a name="l00017"></a><a class="code" href="blocktx-common-impl-v2_8h.html#ab4442994005daa15a90ae1bbe9b99b3c">00017</a> <span class="preprocessor"></span><span class="preprocessor">#define SS_BBITMAP      &quot;BLOCK BITMAP&quot;</span>
<a name="l00018"></a><a class="code" href="blocktx-common-impl-v2_8h.html#a3ef8d319ec82846afe393cd25f486e04">00018</a> <span class="preprocessor"></span><span class="preprocessor">#define SC_ACK          &quot;305&quot;</span>
<a name="l00019"></a><a class="code" href="blocktx-common-impl-v2_8h.html#a2ee83a4763ec415554312d3491efd37a">00019</a> <span class="preprocessor"></span><span class="preprocessor">#define SS_ACK          &quot;BLOCK OK&quot;</span>
<a name="l00020"></a><a class="code" href="blocktx-common-impl-v2_8h.html#aac96b613eae9d781c96a831650184da9">00020</a> <span class="preprocessor"></span><span class="preprocessor">#define SC_BLOCKLIST    &quot;306&quot;</span>
<a name="l00021"></a><a class="code" href="blocktx-common-impl-v2_8h.html#a9604fd6d73c5d1a1ab626428d1ba56c5">00021</a> <span class="preprocessor"></span><span class="preprocessor">#define SS_BLOCKLIST    &quot;BLOCK LIST&quot;</span>
<a name="l00022"></a>00022 <span class="preprocessor"></span>
<a name="l00023"></a><a class="code" href="blocktx-common-impl-v2_8h.html#a3e56a915cdab239602118f9d6f94a1cf">00023</a> <span class="preprocessor">#define SC_BAD_BLK_REQ      &quot;405&quot;</span>
<a name="l00024"></a><a class="code" href="blocktx-common-impl-v2_8h.html#afec0ac8c2b9aafcd9beae52700e16a35">00024</a> <span class="preprocessor"></span><span class="preprocessor">#define SS_BAD_BLK_REQ      &quot;BAD BLOCK REQUEST&quot;</span>
<a name="l00025"></a><a class="code" href="blocktx-common-impl-v2_8h.html#ae6e5353da95fe7379aced8dd7395aafd">00025</a> <span class="preprocessor"></span><span class="preprocessor">#define SC_BAD_BL           &quot;408&quot;</span>
<a name="l00026"></a><a class="code" href="blocktx-common-impl-v2_8h.html#aaa37f98a5ba3ee19a308d125ba4c7499">00026</a> <span class="preprocessor"></span><span class="preprocessor">#define SS_BAD_BL           &quot;BAD BLOCK LIST&quot;</span>
<a name="l00027"></a>00027 <span class="preprocessor"></span>
<a name="l00028"></a><a class="code" href="blocktx-common-impl-v2_8h.html#ae2d2427c805cbaf0c0e98e4c3db1f75e">00028</a> <span class="preprocessor">#define SC_ACCESS_DENIED &quot;410&quot;</span>
<a name="l00029"></a><a class="code" href="blocktx-common-impl-v2_8h.html#a47c784aa27857759dc4d18a579d0046c">00029</a> <span class="preprocessor"></span><span class="preprocessor">#define SS_ACCESS_DENIED &quot;Access denied&quot;</span>
<a name="l00030"></a>00030 <span class="preprocessor"></span>
<a name="l00031"></a><a class="code" href="blocktx-common-impl-v2_8h.html#a455b010f8eb4daaf25446b668dcde8a6">00031</a> <span class="preprocessor">#define MAX_BL_LEN 1024</span>
<a name="l00032"></a><a class="code" href="blocktx-common-impl-v2_8h.html#a722507cf2472bd985d296aa202057d42">00032</a> <span class="preprocessor"></span><span class="preprocessor">#define IO_BUF_LEN 1024</span>
<a name="l00033"></a><a class="code" href="blocktx-common-impl-v2_8h.html#a1c46953a017f054a3e69c50ff8c834a8">00033</a> <span class="preprocessor"></span><span class="preprocessor">#define DEFAULT_SNDBUF_SIZE (1 &lt;&lt; 16) </span><span class="comment">/* 64KB */</span>
<a name="l00034"></a><a class="code" href="blocktx-common-impl-v2_8h.html#afc78b14454633dfa065c5038f03fe3d2">00034</a> <span class="preprocessor">#define DEFAULT_RCVBUF_SIZE (1 &lt;&lt; 16) </span><span class="comment">/* 64KB */</span>
<a name="l00035"></a><a class="code" href="blocktx-common-impl-v2_8h.html#a44257c425d2f3b28f78f1f0f048c3307">00035</a> <span class="preprocessor">#define ENC_BLOCK_SIZE 16</span>
<a name="l00036"></a><a class="code" href="blocktx-common-impl-v2_8h.html#ac59acf70f92ce9820ee44a1e6ed09f61">00036</a> <span class="preprocessor"></span><span class="preprocessor">#define TOKEN_TIMEOUT 180</span>
<a name="l00037"></a><a class="code" href="blocktx-common-impl-v2_8h.html#a6d8ea342c6a0c6abf6f7b3e673fe5471">00037</a> <span class="preprocessor"></span><span class="preprocessor">#define BLOCKTX_TIMEOUT 30</span>
<a name="l00038"></a>00038 <span class="preprocessor"></span>
<a name="l00039"></a><a class="code" href="structBlockRequest.html">00039</a> <span class="keyword">typedef</span> <span class="keyword">struct </span>{
<a name="l00040"></a><a class="code" href="structBlockRequest.html#a68f36717ac413a3522736ddf12b13525">00040</a>     <span class="keywordtype">int</span>     <a class="code" href="structBlockRequest.html#a68f36717ac413a3522736ddf12b13525">block_idx</a>;
<a name="l00041"></a><a class="code" href="structBlockRequest.html#a9cef60a157f2585990d7e63cd18d2cd9">00041</a>     <span class="keywordtype">char</span>    <a class="code" href="block-tx-utils_8h.html#a2d616e1f81d11995c8b388444be651ef">block_id</a>[41];
<a name="l00042"></a>00042 } <a class="code" href="structBlockRequest.html">BlockRequest</a>;
<a name="l00043"></a>00043 
<a name="l00044"></a><a class="code" href="structBlockResponse.html">00044</a> <span class="keyword">typedef</span> <span class="keyword">struct </span>{
<a name="l00045"></a><a class="code" href="structBlockResponse.html#a9bed44ac39f24aee8f7c3bc4d420294b">00045</a>     <span class="keywordtype">int</span>      <a class="code" href="structBlockResponse.html#a9bed44ac39f24aee8f7c3bc4d420294b">block_idx</a>;
<a name="l00046"></a><a class="code" href="structBlockResponse.html#a93b428f2e84bfaf9831bcaf04e17ed0e">00046</a>     <span class="keywordtype">int</span>      <a class="code" href="structBlockResponse.html#a93b428f2e84bfaf9831bcaf04e17ed0e">tx_bytes</a>;
<a name="l00047"></a><a class="code" href="structBlockResponse.html#ae9ac60617bf0a6de6a6b2be345e2066e">00047</a>     <span class="keywordtype">int</span>      <a class="code" href="structBlockResponse.html#ae9ac60617bf0a6de6a6b2be345e2066e">tx_time</a>;
<a name="l00048"></a><a class="code" href="structBlockResponse.html#a6680e4eb1ec37d64b1519f00a4a28392">00048</a>     <span class="keywordtype">char</span>     <a class="code" href="block-tx-utils_8h.html#a2d616e1f81d11995c8b388444be651ef">block_id</a>[41];
<a name="l00049"></a>00049 } <a class="code" href="structBlockResponse.html">BlockResponse</a>;
<a name="l00050"></a>00050 
<a name="l00051"></a><a class="code" href="struct____attribute____.html">00051</a> <span class="keyword">typedef</span> <span class="keyword">struct </span>{
<a name="l00052"></a><a class="code" href="struct____attribute____.html#a43ec510a79d318e490db48ad1ab980d2">00052</a>     uint32_t <a class="code" href="struct____attribute____.html#a43ec510a79d318e490db48ad1ab980d2">block_size</a>;
<a name="l00053"></a><a class="code" href="struct____attribute____.html#a6ba6fd2afd54a8d331c2682f050ff88e">00053</a>     uint32_t <a class="code" href="struct____attribute____.html#a6ba6fd2afd54a8d331c2682f050ff88e">block_idx</a>;
<a name="l00054"></a><a class="code" href="struct____attribute____.html#a2cdef1811df54688927feb8013b4f263">00054</a>     <span class="keywordtype">char</span>     <a class="code" href="block-tx-utils_8h.html#a2d616e1f81d11995c8b388444be651ef">block_id</a>[41];
<a name="l00055"></a>00055 } <a class="code" href="fs-mgr_8h.html#ac5bca675b55e4df0a33e4e87cdbf8996">__attribute__</a>((__packed__)) BlockPacket;
<a name="l00056"></a>00056 
<a name="l00057"></a><a class="code" href="structBLInfo.html">00057</a> typedef struct <a class="code" href="structBLInfo.html">BLInfo</a> {
<a name="l00058"></a><a class="code" href="structBLInfo.html#ad4796950d31aa956f57cebc6f9c095fa">00058</a>     <span class="keywordtype">char</span> *<a class="code" href="structBLInfo.html#ad4796950d31aa956f57cebc6f9c095fa">block_list</a>;
<a name="l00059"></a><a class="code" href="structBLInfo.html#ac5dd9911ffc9cf662ce7d1a8ff730266">00059</a>     <span class="keywordtype">int</span> <a class="code" href="structBLInfo.html#ac5dd9911ffc9cf662ce7d1a8ff730266">n_blocks</a>;
<a name="l00060"></a>00060 } <a class="code" href="blocktx-common-impl-v2_8h.html#a07c373ebd5bc2d53ed81424368a1339c">BLInfo</a>;
<a name="l00061"></a>00061 
<a name="l00062"></a><a class="code" href="blocktx-common-impl-v2_8h.html#a5d1975e203ce6f822538d556409ccf6a">00062</a> <span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code" href="structThreadData.html">ThreadData</a> <a class="code" href="structThreadData.html">ThreadData</a>;
<a name="l00063"></a>00063 
<a name="l00064"></a>00064 <span class="comment">/* function called when receiving event from transfer thread via pipe. */</span>
<a name="l00065"></a><a class="code" href="blocktx-common-impl-v2_8h.html#a2854239b0fe40aa776f80f7d9310e3ff">00065</a> <span class="keyword">typedef</span> void (*<a class="code" href="blocktx-common-impl-v2_8h.html#a2854239b0fe40aa776f80f7d9310e3ff">ThreadEventHandler</a>) (<a class="code" href="structCEvent.html">CEvent</a> *event, <span class="keywordtype">void</span> *vprocessor);
<a name="l00066"></a><a class="code" href="blocktx-common-impl-v2_8h.html#a8bf6eed8c3ed35a8939c062dda33bf0a">00066</a> <span class="keyword">typedef</span> int  (*<a class="code" href="blocktx-common-impl-v2_8h.html#a8bf6eed8c3ed35a8939c062dda33bf0a">TransferFunc</a>) (<a class="code" href="structThreadData.html">ThreadData</a> *tdata);
<a name="l00067"></a>00067 
<a name="l00068"></a><a class="code" href="structThreadData.html">00068</a> <span class="keyword">struct </span><a class="code" href="structThreadData.html">ThreadData</a> {
<a name="l00069"></a><a class="code" href="structThreadData.html#ac65327e0bcbe789433dd3b272cdb226a">00069</a>     <span class="keywordtype">int</span>                  <a class="code" href="structThreadData.html#ac65327e0bcbe789433dd3b272cdb226a">ref_count</a>;
<a name="l00070"></a>00070 
<a name="l00071"></a><a class="code" href="structThreadData.html#accb5430140f9b5b9139c395b7279c604">00071</a>     <a class="code" href="struct__CcnetPeer.html">CcnetPeer</a>           *<a class="code" href="structThreadData.html#accb5430140f9b5b9139c395b7279c604">peer</a>;
<a name="l00072"></a>00072     <span class="comment">/* Never dereference this processor in the worker thread */</span>
<a name="l00073"></a><a class="code" href="structThreadData.html#a4d788ba804c065e35978c0a8d2d88daa">00073</a>     <a class="code" href="struct__CcnetProcessor.html">CcnetProcessor</a>      *<a class="code" href="structThreadData.html#a4d788ba804c065e35978c0a8d2d88daa">processor</a>;
<a name="l00074"></a>00074 <span class="preprocessor">#if defined SENDBLOCK_PROC || defined GETBLOCK_PROC</span>
<a name="l00075"></a>00075 <span class="preprocessor"></span>    <a class="code" href="struct__TransferTask.html">TransferTask</a>        *task;
<a name="l00076"></a>00076 <span class="preprocessor">#endif</span>
<a name="l00077"></a><a class="code" href="structThreadData.html#aa92f35671104d9f3c2bc60fc5a15adfd">00077</a> <span class="preprocessor"></span>    uint32_t             <a class="code" href="structThreadData.html#aa92f35671104d9f3c2bc60fc5a15adfd">cevent_id</a>;
<a name="l00078"></a><a class="code" href="structThreadData.html#a661392febd30e97efaa1ed18ce77f08a">00078</a>     <a class="code" href="seafile-4_81_82_2lib_2utils_8h.html#ac5d9c8feaea3e66b35fbc3195a97a699">ccnet_pipe_t</a>         <a class="code" href="structThreadData.html#a661392febd30e97efaa1ed18ce77f08a">task_pipe</a>[2];
<a name="l00079"></a><a class="code" href="structThreadData.html#adfba38dfc5a126bf475273dd244848fd">00079</a>     <span class="keywordtype">int</span>                  <a class="code" href="structThreadData.html#adfba38dfc5a126bf475273dd244848fd">port</a>;
<a name="l00080"></a><a class="code" href="structThreadData.html#af62c31466a162c9a0197778da78477ae">00080</a>     evutil_socket_t      <a class="code" href="structThreadData.html#af62c31466a162c9a0197778da78477ae">data_fd</a>;
<a name="l00081"></a>00081 
<a name="l00082"></a><a class="code" href="structThreadData.html#a63980e9374513d2266aa1952afe40352">00082</a>     gboolean             <a class="code" href="structThreadData.html#a63980e9374513d2266aa1952afe40352">encrypt_channel</a>;
<a name="l00083"></a><a class="code" href="structThreadData.html#a70caefc1d38db9a3c9e27e05926fe95a">00083</a>     <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>        <a class="code" href="structThreadData.html#a70caefc1d38db9a3c9e27e05926fe95a">key</a>[<a class="code" href="blocktx-common-impl-v2_8h.html#a44257c425d2f3b28f78f1f0f048c3307">ENC_BLOCK_SIZE</a>];
<a name="l00084"></a><a class="code" href="structThreadData.html#ab523fa00c2e8edacb3415eb235444719">00084</a>     <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>        <a class="code" href="structThreadData.html#ab523fa00c2e8edacb3415eb235444719">iv</a>[<a class="code" href="blocktx-common-impl-v2_8h.html#a44257c425d2f3b28f78f1f0f048c3307">ENC_BLOCK_SIZE</a>];
<a name="l00085"></a>00085 
<a name="l00086"></a><a class="code" href="structThreadData.html#a02d6dca5e8a071c080b95299e9cc54af">00086</a>     gboolean             <a class="code" href="structThreadData.html#a02d6dca5e8a071c080b95299e9cc54af">processor_done</a>;
<a name="l00087"></a><a class="code" href="structThreadData.html#aefb5ab8272276bd942950a4780773cdf">00087</a>     <span class="keywordtype">char</span>                *<a class="code" href="structThreadData.html#aefb5ab8272276bd942950a4780773cdf">token</a>;
<a name="l00088"></a><a class="code" href="structThreadData.html#a2af444f30f1d00bd762fb2f5f2dd2930">00088</a>     <a class="code" href="blocktx-common-impl-v2_8h.html#a8bf6eed8c3ed35a8939c062dda33bf0a">TransferFunc</a>         <a class="code" href="structThreadData.html#a2af444f30f1d00bd762fb2f5f2dd2930">transfer_func</a>;
<a name="l00089"></a><a class="code" href="structThreadData.html#a2e8c4bf0bc10240ae1fa4db655356a7d">00089</a>     <span class="keywordtype">int</span>                  <a class="code" href="structThreadData.html#a2e8c4bf0bc10240ae1fa4db655356a7d">thread_ret</a>;
<a name="l00090"></a>00090 
<a name="l00091"></a>00091     <span class="comment">/* Use this state instead of processor-&gt;state, since</span>
<a name="l00092"></a>00092 <span class="comment">     * both the main thread and the worker thread need to</span>
<a name="l00093"></a>00093 <span class="comment">     * access it.</span>
<a name="l00094"></a>00094 <span class="comment">     */</span>
<a name="l00095"></a><a class="code" href="structThreadData.html#a3ff1006f44c3e35b2750f5e792751b99">00095</a>     <span class="keywordtype">int</span>                  <a class="code" href="structThreadData.html#a3ff1006f44c3e35b2750f5e792751b99">state</a>;
<a name="l00096"></a>00096 
<a name="l00097"></a>00097     <span class="comment">/* For checking block list. */</span>
<a name="l00098"></a><a class="code" href="structThreadData.html#ab48b75c727949f8d231096df1eea82a3">00098</a>     <a class="code" href="structBLInfo.html">BLInfo</a>              *<a class="code" href="structThreadData.html#ab48b75c727949f8d231096df1eea82a3">blinfo</a>;
<a name="l00099"></a><a class="code" href="structThreadData.html#aa4dbcc457646e548e7fa2a7abf574ddf">00099</a>     Bitfield             <a class="code" href="structThreadData.html#aa4dbcc457646e548e7fa2a7abf574ddf">bitmap</a>;
<a name="l00100"></a><a class="code" href="structThreadData.html#aee2731427928b31eab553cbc1b5e2c72">00100</a>     GQueue              *<a class="code" href="structThreadData.html#aee2731427928b31eab553cbc1b5e2c72">bl_queue</a>;
<a name="l00101"></a><a class="code" href="structThreadData.html#af9b1f92f18c54fab940148136003317e">00101</a>     gboolean             <a class="code" href="structThreadData.html#af9b1f92f18c54fab940148136003317e">checking_bl</a>;
<a name="l00102"></a>00102 
<a name="l00103"></a><a class="code" href="structThreadData.html#aa248e41d5e9ef522d91dab0591a8ab68">00103</a>     <span class="keywordtype">char</span>                 <a class="code" href="structThreadData.html#aa248e41d5e9ef522d91dab0591a8ab68">repo_id</a>[37];
<a name="l00104"></a>00104 };
<a name="l00105"></a>00105 
<a name="l00106"></a><a class="code" href="structBlockProcPriv.html">00106</a> <span class="keyword">typedef</span> <span class="keyword">struct </span>{
<a name="l00107"></a><a class="code" href="structBlockProcPriv.html#a4d10e347c7e900cdadb85709087a104b">00107</a>     <a class="code" href="structThreadData.html">ThreadData</a>      *<a class="code" href="structBlockProcPriv.html#a4d10e347c7e900cdadb85709087a104b">tdata</a>;
<a name="l00108"></a><a class="code" href="structBlockProcPriv.html#a8e887892b8cb5bade0a547a42946398c">00108</a>     <span class="keywordtype">int</span>              <a class="code" href="structBlockProcPriv.html#a8e887892b8cb5bade0a547a42946398c">bm_offset</a>;
<a name="l00109"></a><a class="code" href="structBlockProcPriv.html#a48f77247a92b7e3cd0953cf7c81bba02">00109</a>     GHashTable      *<a class="code" href="structBlockProcPriv.html#a48f77247a92b7e3cd0953cf7c81bba02">block_hash</a>;
<a name="l00110"></a><a class="code" href="structBlockProcPriv.html#a103ce29bbd69677258e54e54340c0b97">00110</a>     <span class="keywordtype">char</span>             repo_id[37];
<a name="l00111"></a>00111 } <a class="code" href="structBlockProcPriv.html">BlockProcPriv</a>;
<a name="l00112"></a>00112 
<a name="l00113"></a>00113 <span class="comment">/*</span>
<a name="l00114"></a>00114 <span class="comment"> * Common code for processor start and release_resource functions.</span>
<a name="l00115"></a>00115 <span class="comment"> */</span>
<a name="l00116"></a>00116 
<a name="l00117"></a>00117 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l00118"></a>00118 send_error (<a class="code" href="struct__CcnetProcessor.html">CcnetProcessor</a> *processor)
<a name="l00119"></a>00119 {
<a name="l00120"></a>00120     <span class="keywordflow">if</span> (<a class="code" href="include_2ccnet_2processor_8h.html#adde0b05b31360fa3ed6d95d4928d70fe">IS_SLAVE</a>(processor))
<a name="l00121"></a>00121         <a class="code" href="include_2ccnet_2processor_8h.html#a990a7c85ac8c9b5cb020391b10affe82">ccnet_processor_send_response</a> (processor, <a class="code" href="status-code_8h.html#ab05019e3f22dd474823754a02576e258">SC_SHUTDOWN</a>, <a class="code" href="status-code_8h.html#a34269b8dfaf8666bbee7cef87fdf973b">SS_SHUTDOWN</a>,
<a name="l00122"></a>00122                                        NULL, 0);
<a name="l00123"></a>00123     <span class="keywordflow">else</span>
<a name="l00124"></a>00124         <a class="code" href="include_2ccnet_2processor_8h.html#a5358a9392f5e9235cec39e141fea81dc">ccnet_processor_send_update</a> (processor, <a class="code" href="status-code_8h.html#ab05019e3f22dd474823754a02576e258">SC_SHUTDOWN</a>, <a class="code" href="status-code_8h.html#a34269b8dfaf8666bbee7cef87fdf973b">SS_SHUTDOWN</a>,
<a name="l00125"></a>00125                                      NULL, 0);
<a name="l00126"></a>00126 }
<a name="l00127"></a>00127 
<a name="l00128"></a>00128 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l00129"></a>00129 thread_data_ref (<a class="code" href="structThreadData.html">ThreadData</a> *tdata)
<a name="l00130"></a>00130 {
<a name="l00131"></a>00131     ++(tdata-&gt;<a class="code" href="structThreadData.html#ac65327e0bcbe789433dd3b272cdb226a">ref_count</a>);
<a name="l00132"></a>00132 }
<a name="l00133"></a>00133 
<a name="l00134"></a>00134 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l00135"></a>00135 thread_data_unref (<a class="code" href="structThreadData.html">ThreadData</a> *tdata)
<a name="l00136"></a>00136 {
<a name="l00137"></a>00137     <span class="keywordflow">if</span> (!tdata)
<a name="l00138"></a>00138         <span class="keywordflow">return</span>;
<a name="l00139"></a>00139 
<a name="l00140"></a>00140     <span class="keywordflow">if</span> (--(tdata-&gt;<a class="code" href="structThreadData.html#ac65327e0bcbe789433dd3b272cdb226a">ref_count</a>) &lt;= 0) {
<a name="l00141"></a>00141         <span class="keywordflow">if</span> (tdata-&gt;<a class="code" href="structThreadData.html#aee2731427928b31eab553cbc1b5e2c72">bl_queue</a>)
<a name="l00142"></a>00142             g_queue_free (tdata-&gt;<a class="code" href="structThreadData.html#aee2731427928b31eab553cbc1b5e2c72">bl_queue</a>);
<a name="l00143"></a>00143         g_free (tdata-&gt;<a class="code" href="structThreadData.html#aefb5ab8272276bd942950a4780773cdf">token</a>);
<a name="l00144"></a>00144         g_free (tdata);
<a name="l00145"></a>00145     }
<a name="l00146"></a>00146 }
<a name="l00147"></a>00147 
<a name="l00148"></a>00148 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l00149"></a>00149 prepare_thread_data (<a class="code" href="struct__CcnetProcessor.html">CcnetProcessor</a> *processor,
<a name="l00150"></a>00150                      <a class="code" href="blocktx-common-impl-v2_8h.html#a8bf6eed8c3ed35a8939c062dda33bf0a">TransferFunc</a> tranfer_func,
<a name="l00151"></a>00151                      <a class="code" href="blocktx-common-impl-v2_8h.html#a2854239b0fe40aa776f80f7d9310e3ff">ThreadEventHandler</a> handler,
<a name="l00152"></a>00152                      <span class="keyword">const</span> <span class="keywordtype">char</span> *repo_id)
<a name="l00153"></a>00153 {
<a name="l00154"></a>00154     <a class="code" href="putblock-proc_8c.html#a52bd1fa7793027a7386a1b3d55b3bceb">USE_PRIV</a>;
<a name="l00155"></a>00155 
<a name="l00156"></a>00156     <a class="code" href="monitor-tool_8c.html#a694b59386a408403dbb70994ed5beaa1">priv</a>-&gt;tdata = g_new0 (<a class="code" href="structThreadData.html">ThreadData</a>, 1);
<a name="l00157"></a>00157     thread_data_ref (<a class="code" href="monitor-tool_8c.html#a694b59386a408403dbb70994ed5beaa1">priv</a>-&gt;tdata);
<a name="l00158"></a>00158 
<a name="l00159"></a>00159     <a class="code" href="monitor-tool_8c.html#a694b59386a408403dbb70994ed5beaa1">priv</a>-&gt;tdata-&gt;task_pipe[0] = -1;
<a name="l00160"></a>00160     <a class="code" href="monitor-tool_8c.html#a694b59386a408403dbb70994ed5beaa1">priv</a>-&gt;tdata-&gt;task_pipe[1] = -1;
<a name="l00161"></a>00161     <a class="code" href="monitor-tool_8c.html#a694b59386a408403dbb70994ed5beaa1">priv</a>-&gt;tdata-&gt;transfer_func = tranfer_func;
<a name="l00162"></a>00162     <a class="code" href="monitor-tool_8c.html#a694b59386a408403dbb70994ed5beaa1">priv</a>-&gt;tdata-&gt;processor = processor;
<a name="l00163"></a>00163     memcpy (<a class="code" href="monitor-tool_8c.html#a694b59386a408403dbb70994ed5beaa1">priv</a>-&gt;tdata-&gt;repo_id, repo_id, 36);
<a name="l00164"></a>00164 
<a name="l00165"></a>00165     <a class="code" href="monitor-tool_8c.html#a694b59386a408403dbb70994ed5beaa1">priv</a>-&gt;tdata-&gt;cevent_id = <a class="code" href="cevent_8h.html#a2f0a51bf288caadf31944a151462e78c">cevent_manager_register</a> (<a class="code" href="seaf-daemon_8c.html#ae66636d1834d105bd51d89ff01acfe15">seaf</a>-&gt;<a class="code" href="struct__SeafileSession.html#a7321aeb5c752d434ccb1b94bec6c9624">ev_mgr</a>,
<a name="l00166"></a>00166                                                       handler,
<a name="l00167"></a>00167                                                       processor);
<a name="l00168"></a>00168 }
<a name="l00169"></a>00169 
<a name="l00170"></a>00170 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l00171"></a>00171 release_thread (<a class="code" href="struct__CcnetProcessor.html">CcnetProcessor</a> *processor)
<a name="l00172"></a>00172 {
<a name="l00173"></a>00173     <a class="code" href="putblock-proc_8c.html#a52bd1fa7793027a7386a1b3d55b3bceb">USE_PRIV</a>;
<a name="l00174"></a>00174 
<a name="l00175"></a>00175     <span class="keywordflow">if</span> (<a class="code" href="monitor-tool_8c.html#a694b59386a408403dbb70994ed5beaa1">priv</a>-&gt;tdata) {
<a name="l00176"></a>00176         <span class="comment">/* The read end will be closed by worker thread. */</span>
<a name="l00177"></a>00177         <span class="keywordflow">if</span> (<a class="code" href="monitor-tool_8c.html#a694b59386a408403dbb70994ed5beaa1">priv</a>-&gt;tdata-&gt;task_pipe[1] &gt;= 0)
<a name="l00178"></a>00178             <a class="code" href="seafile-4_81_82_2lib_2utils_8h.html#a597da6cd8fcd52017eb622068a9538dc">pipeclose</a> (<a class="code" href="monitor-tool_8c.html#a694b59386a408403dbb70994ed5beaa1">priv</a>-&gt;tdata-&gt;task_pipe[1]);
<a name="l00179"></a>00179 
<a name="l00180"></a>00180         <a class="code" href="monitor-tool_8c.html#a694b59386a408403dbb70994ed5beaa1">priv</a>-&gt;tdata-&gt;processor_done = TRUE;
<a name="l00181"></a>00181         <a class="code" href="cevent_8h.html#a6c327d083f4acaa433a62184d8a2cd58">cevent_manager_unregister</a> (<a class="code" href="seaf-daemon_8c.html#ae66636d1834d105bd51d89ff01acfe15">seaf</a>-&gt;<a class="code" href="struct__SeafileSession.html#a7321aeb5c752d434ccb1b94bec6c9624">ev_mgr</a>, <a class="code" href="monitor-tool_8c.html#a694b59386a408403dbb70994ed5beaa1">priv</a>-&gt;tdata-&gt;cevent_id);
<a name="l00182"></a>00182 
<a name="l00183"></a>00183         thread_data_unref (<a class="code" href="monitor-tool_8c.html#a694b59386a408403dbb70994ed5beaa1">priv</a>-&gt;tdata);
<a name="l00184"></a>00184     }
<a name="l00185"></a>00185 }
<a name="l00186"></a>00186 
<a name="l00187"></a>00187 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l00188"></a>00188 thread_done (<span class="keywordtype">void</span> *vtdata)
<a name="l00189"></a>00189 {
<a name="l00190"></a>00190     <a class="code" href="structThreadData.html">ThreadData</a> *tdata = vtdata;
<a name="l00191"></a>00191 
<a name="l00192"></a>00192     <span class="comment">/* When the worker thread returns, the processor may have been</span>
<a name="l00193"></a>00193 <span class="comment">     * released. tdata-&gt;processor_done will be set to TRUE in</span>
<a name="l00194"></a>00194 <span class="comment">     * release_resource().</span>
<a name="l00195"></a>00195 <span class="comment">     *</span>
<a name="l00196"></a>00196 <span class="comment">     * Note: thread_done() and release_thread() are both called</span>
<a name="l00197"></a>00197 <span class="comment">     * in main thread, so there are only two cases:</span>
<a name="l00198"></a>00198 <span class="comment">     * 1) thread_done() is called before release_resource(), then release_thread()</span>
<a name="l00199"></a>00199 <span class="comment">     *    is called within thread_done()</span>
<a name="l00200"></a>00200 <span class="comment">     * 2) release_thread() is called before thread_done(), then tdata-&gt;processor_done</span>
<a name="l00201"></a>00201 <span class="comment">     *    is set.</span>
<a name="l00202"></a>00202 <span class="comment">     */</span>
<a name="l00203"></a>00203     <span class="keywordflow">if</span> (!tdata-&gt;<a class="code" href="structThreadData.html#a02d6dca5e8a071c080b95299e9cc54af">processor_done</a>) {
<a name="l00204"></a>00204         seaf_debug (<span class="stringliteral">&quot;Processor is not released. Release it now.\n&quot;</span>);
<a name="l00205"></a>00205         <span class="keywordflow">if</span> (tdata-&gt;<a class="code" href="structThreadData.html#a2e8c4bf0bc10240ae1fa4db655356a7d">thread_ret</a> == 0) {
<a name="l00206"></a>00206             <a class="code" href="include_2ccnet_2processor_8h.html#a562f3a09215f5220c957bc24d60f7929">ccnet_processor_done</a> (tdata-&gt;<a class="code" href="structThreadData.html#a4d788ba804c065e35978c0a8d2d88daa">processor</a>, TRUE);
<a name="l00207"></a>00207         } <span class="keywordflow">else</span> {
<a name="l00208"></a>00208             send_error (tdata-&gt;<a class="code" href="structThreadData.html#a4d788ba804c065e35978c0a8d2d88daa">processor</a>);
<a name="l00209"></a>00209             <a class="code" href="include_2ccnet_2processor_8h.html#a562f3a09215f5220c957bc24d60f7929">ccnet_processor_done</a> (tdata-&gt;<a class="code" href="structThreadData.html#a4d788ba804c065e35978c0a8d2d88daa">processor</a>, FALSE);
<a name="l00210"></a>00210         }
<a name="l00211"></a>00211     }
<a name="l00212"></a>00212 
<a name="l00213"></a>00213     thread_data_unref (tdata);
<a name="l00214"></a>00214 }
<a name="l00215"></a>00215 
<a name="l00216"></a>00216 
<a name="l00217"></a>00217 <span class="comment">/*</span>
<a name="l00218"></a>00218 <span class="comment"> * Common code for block transfer.</span>
<a name="l00219"></a>00219 <span class="comment"> */</span>
<a name="l00220"></a>00220 
<a name="l00221"></a>00221 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l00222"></a>00222 send_block_rsp (<span class="keywordtype">int</span> cevent_id, <span class="keywordtype">int</span> block_idx, <span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code" href="block-tx-utils_8h.html#a2d616e1f81d11995c8b388444be651ef">block_id</a>,
<a name="l00223"></a>00223                 <span class="keywordtype">int</span> tx_bytes, <span class="keywordtype">int</span> tx_time)
<a name="l00224"></a>00224 {
<a name="l00225"></a>00225     <a class="code" href="structBlockResponse.html">BlockResponse</a> *blk_rsp = g_new0 (<a class="code" href="structBlockResponse.html">BlockResponse</a>, 1);
<a name="l00226"></a>00226     blk_rsp-&gt;<a class="code" href="structBlockResponse.html#a9bed44ac39f24aee8f7c3bc4d420294b">block_idx</a> = block_idx;
<a name="l00227"></a>00227     memcpy(blk_rsp-&gt;<a class="code" href="structBlockResponse.html#a6680e4eb1ec37d64b1519f00a4a28392">block_id</a>, block_id, 40);
<a name="l00228"></a>00228     blk_rsp-&gt;<a class="code" href="structBlockResponse.html#a6680e4eb1ec37d64b1519f00a4a28392">block_id</a>[40] = <span class="charliteral">&#39;\0&#39;</span>;
<a name="l00229"></a>00229     blk_rsp-&gt;<a class="code" href="structBlockResponse.html#a93b428f2e84bfaf9831bcaf04e17ed0e">tx_bytes</a> = tx_bytes;
<a name="l00230"></a>00230     blk_rsp-&gt;<a class="code" href="structBlockResponse.html#ae9ac60617bf0a6de6a6b2be345e2066e">tx_time</a> = tx_time;
<a name="l00231"></a>00231     <a class="code" href="cevent_8h.html#a585ea013fcbdc1f2303598e1a2d84f4d">cevent_manager_add_event</a> (<a class="code" href="seaf-daemon_8c.html#ae66636d1834d105bd51d89ff01acfe15">seaf</a>-&gt;<a class="code" href="struct__SeafileSession.html#a7321aeb5c752d434ccb1b94bec6c9624">ev_mgr</a>, 
<a name="l00232"></a>00232                               cevent_id,
<a name="l00233"></a>00233                               (<span class="keywordtype">void</span> *)blk_rsp);
<a name="l00234"></a>00234 }
<a name="l00235"></a>00235 
<a name="l00236"></a>00236 <span class="comment">/* Encryption utilities. */</span>
<a name="l00237"></a>00237 
<a name="l00238"></a>00238 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l00239"></a>00239 generate_encrypt_key (<a class="code" href="structThreadData.html">ThreadData</a> *tdata, <a class="code" href="struct__CcnetPeer.html">CcnetPeer</a> *peer)
<a name="l00240"></a>00240 {
<a name="l00241"></a>00241     EVP_BytesToKey (EVP_aes_256_cbc(), <span class="comment">/* cipher mode */</span>
<a name="l00242"></a>00242                     EVP_sha1(),        <span class="comment">/* message digest */</span>
<a name="l00243"></a>00243                     NULL,              <span class="comment">/* salt */</span>
<a name="l00244"></a>00244                     (<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>*)peer-&gt;<a class="code" href="struct__CcnetPeer.html#a4f6b6af18ae4e17a57fc25c5c1126229">session_key</a>,
<a name="l00245"></a>00245                     strlen(peer-&gt;<a class="code" href="struct__CcnetPeer.html#a4f6b6af18ae4e17a57fc25c5c1126229">session_key</a>),
<a name="l00246"></a>00246                     3,   <span class="comment">/* iteration times */</span>
<a name="l00247"></a>00247                     tdata-&gt;<a class="code" href="structThreadData.html#a70caefc1d38db9a3c9e27e05926fe95a">key</a>, <span class="comment">/* the derived key */</span>
<a name="l00248"></a>00248                     tdata-&gt;<a class="code" href="structThreadData.html#ab523fa00c2e8edacb3415eb235444719">iv</a>); <span class="comment">/* IV, initial vector */</span>
<a name="l00249"></a>00249 
<a name="l00250"></a>00250     tdata-&gt;<a class="code" href="structThreadData.html#a63980e9374513d2266aa1952afe40352">encrypt_channel</a> = TRUE;
<a name="l00251"></a>00251 }
<a name="l00252"></a>00252 
<a name="l00253"></a>00253 <span class="preprocessor">#if defined SENDBLOCK_PROC || defined PUTBLOCK_PROC</span>
<a name="l00254"></a>00254 <span class="preprocessor"></span>
<a name="l00255"></a>00255 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l00256"></a>00256 encrypt_init (EVP_CIPHER_CTX *ctx,
<a name="l00257"></a>00257               <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *key,
<a name="l00258"></a>00258               <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *iv)
<a name="l00259"></a>00259 {
<a name="l00260"></a>00260     <span class="keywordtype">int</span> ret;
<a name="l00261"></a>00261 
<a name="l00262"></a>00262     <span class="comment">/* Prepare CTX for encryption. */</span>
<a name="l00263"></a>00263     EVP_CIPHER_CTX_init (ctx);
<a name="l00264"></a>00264 
<a name="l00265"></a>00265     ret = EVP_EncryptInit_ex (ctx,
<a name="l00266"></a>00266                               EVP_aes_256_cbc(), <span class="comment">/* cipher mode */</span>
<a name="l00267"></a>00267                               NULL, <span class="comment">/* engine, NULL for default */</span>
<a name="l00268"></a>00268                               key,  <span class="comment">/* derived key */</span>
<a name="l00269"></a>00269                               iv);  <span class="comment">/* initial vector */</span>
<a name="l00270"></a>00270     <span class="keywordflow">if</span> (ret == 0)
<a name="l00271"></a>00271         <span class="keywordflow">return</span> -1;
<a name="l00272"></a>00272 
<a name="l00273"></a>00273     <span class="keywordflow">return</span> 0;
<a name="l00274"></a>00274 }
<a name="l00275"></a>00275 
<a name="l00276"></a>00276 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l00277"></a>00277 <a class="code" href="block-tx-utils_8c.html#a1e10866a0e3b693d203bcd73e4cb4036">send_encrypted_data</a> (EVP_CIPHER_CTX *ctx, <span class="keywordtype">int</span> sockfd,
<a name="l00278"></a>00278                      <span class="keyword">const</span> <span class="keywordtype">char</span> *buf, <span class="keywordtype">int</span> len, uint32_t remain)
<a name="l00279"></a>00279 {
<a name="l00280"></a>00280     <span class="keywordtype">char</span> out_buf[<a class="code" href="blocktx-common-impl-v2_8h.html#a722507cf2472bd985d296aa202057d42">IO_BUF_LEN</a> + <a class="code" href="blocktx-common-impl-v2_8h.html#a44257c425d2f3b28f78f1f0f048c3307">ENC_BLOCK_SIZE</a>];
<a name="l00281"></a>00281     <span class="keywordtype">int</span> out_len;
<a name="l00282"></a>00282 
<a name="l00283"></a>00283     <span class="keywordflow">if</span> (EVP_EncryptUpdate (ctx,
<a name="l00284"></a>00284                            (<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *)out_buf, &amp;out_len,
<a name="l00285"></a>00285                            (<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *)buf, len) == 0) {
<a name="l00286"></a>00286         seaf_warning (<span class="stringliteral">&quot;Failed to encrypt data.\n&quot;</span>);
<a name="l00287"></a>00287         <span class="keywordflow">return</span> -1;
<a name="l00288"></a>00288     }
<a name="l00289"></a>00289 
<a name="l00290"></a>00290     <span class="keywordflow">if</span> (<a class="code" href="seafile-4_81_82_2lib_2utils_8c.html#aa324f32349cf5a256d5bd7802ab87e84">sendn</a> (sockfd, out_buf, out_len) &lt; 0) {
<a name="l00291"></a>00291         seaf_warning (<span class="stringliteral">&quot;Failed to write data: %s.\n&quot;</span>,
<a name="l00292"></a>00292                       evutil_socket_error_to_string(EVUTIL_SOCKET_ERROR()));
<a name="l00293"></a>00293         <span class="keywordflow">return</span> -1;
<a name="l00294"></a>00294     }
<a name="l00295"></a>00295 
<a name="l00296"></a>00296     <span class="keywordflow">if</span> (remain == 0) {
<a name="l00297"></a>00297         <span class="keywordflow">if</span> (EVP_EncryptFinal_ex (ctx, (<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *)out_buf, &amp;out_len) == 0) {
<a name="l00298"></a>00298             seaf_warning (<span class="stringliteral">&quot;Failed to encrypt data.\n&quot;</span>);
<a name="l00299"></a>00299             <span class="keywordflow">return</span> -1;
<a name="l00300"></a>00300         }
<a name="l00301"></a>00301         <span class="keywordflow">if</span> (<a class="code" href="seafile-4_81_82_2lib_2utils_8c.html#aa324f32349cf5a256d5bd7802ab87e84">sendn</a> (sockfd, out_buf, out_len) &lt; 0) {
<a name="l00302"></a>00302             seaf_warning (<span class="stringliteral">&quot;Failed to write data: %s.\n&quot;</span>,
<a name="l00303"></a>00303                           evutil_socket_error_to_string(EVUTIL_SOCKET_ERROR()));
<a name="l00304"></a>00304             <span class="keywordflow">return</span> -1;
<a name="l00305"></a>00305         }
<a name="l00306"></a>00306     }
<a name="l00307"></a>00307 
<a name="l00308"></a>00308     <span class="keywordflow">return</span> 0;
<a name="l00309"></a>00309 }
<a name="l00310"></a>00310 
<a name="l00311"></a>00311 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l00312"></a>00312 send_block_packet (<a class="code" href="structThreadData.html">ThreadData</a> *tdata,
<a name="l00313"></a>00313                    <span class="keywordtype">int</span> block_idx,
<a name="l00314"></a>00314                    <span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code" href="block-tx-utils_8h.html#a2d616e1f81d11995c8b388444be651ef">block_id</a>,
<a name="l00315"></a>00315                    <a class="code" href="struct__BHandle.html">BlockHandle</a> *handle, 
<a name="l00316"></a>00316                    evutil_socket_t sockfd)
<a name="l00317"></a>00317 {
<a name="l00318"></a>00318     <a class="code" href="struct__SeafBlockManager.html">SeafBlockManager</a> *block_mgr = <a class="code" href="seaf-daemon_8c.html#ae66636d1834d105bd51d89ff01acfe15">seaf</a>-&gt;<a class="code" href="struct__SeafileSession.html#a4b29afaa0ca920084596a236c8460df2">block_mgr</a>;
<a name="l00319"></a>00319     <a class="code" href="struct__BMetadata.html">BlockMetadata</a> *md;
<a name="l00320"></a>00320     uint32_t <a class="code" href="index_8h.html#af931a8871310b4dad23f0f0b0f623560">size</a>, remain;
<a name="l00321"></a>00321     BlockPacket pkt;
<a name="l00322"></a>00322     <span class="keywordtype">char</span> buf[<a class="code" href="blocktx-common-impl-v2_8h.html#a722507cf2472bd985d296aa202057d42">IO_BUF_LEN</a>];
<a name="l00323"></a>00323     <span class="keywordtype">int</span> n;
<a name="l00324"></a>00324     <span class="keywordtype">int</span> ret = 0;
<a name="l00325"></a>00325     EVP_CIPHER_CTX ctx;
<a name="l00326"></a>00326 
<a name="l00327"></a>00327     md = <a class="code" href="block-mgr_8c.html#a9bdf910c00c029c4ffe358c994d1e4b2">seaf_block_manager_stat_block_by_handle</a> (block_mgr, handle);
<a name="l00328"></a>00328     <span class="keywordflow">if</span> (!md) {
<a name="l00329"></a>00329         seaf_warning (<span class="stringliteral">&quot;Failed to stat block %s.\n&quot;</span>, block_id);
<a name="l00330"></a>00330         <span class="keywordflow">return</span> -1;
<a name="l00331"></a>00331     }
<a name="l00332"></a>00332     size = md-&gt;<a class="code" href="struct__BMetadata.html#a7802358b1840abcb33aa8b3fd8f4cf58">size</a>;
<a name="l00333"></a>00333     g_free (md);
<a name="l00334"></a>00334 
<a name="l00335"></a>00335     remain = <a class="code" href="index_8h.html#af931a8871310b4dad23f0f0b0f623560">size</a>;
<a name="l00336"></a>00336     <span class="comment">/* Compute data size after encryption.</span>
<a name="l00337"></a>00337 <span class="comment">     * Block size is 16 bytes and AES always add one padding block.</span>
<a name="l00338"></a>00338 <span class="comment">     */</span>
<a name="l00339"></a>00339     <span class="keywordflow">if</span> (tdata-&gt;<a class="code" href="structThreadData.html#a63980e9374513d2266aa1952afe40352">encrypt_channel</a>) {
<a name="l00340"></a>00340         size = ((size &gt;&gt; 4) + 1) &lt;&lt; 4;
<a name="l00341"></a>00341         encrypt_init (&amp;ctx, tdata-&gt;<a class="code" href="structThreadData.html#a70caefc1d38db9a3c9e27e05926fe95a">key</a>, tdata-&gt;<a class="code" href="structThreadData.html#ab523fa00c2e8edacb3415eb235444719">iv</a>);
<a name="l00342"></a>00342     }
<a name="l00343"></a>00343 
<a name="l00344"></a>00344     pkt.block_size = htonl (size);
<a name="l00345"></a>00345     pkt.block_idx = htonl ((uint32_t) block_idx);
<a name="l00346"></a>00346     memcpy (pkt.block_id, block_id, 41);
<a name="l00347"></a>00347     <span class="keywordflow">if</span> (<a class="code" href="seafile-4_81_82_2lib_2utils_8c.html#aa324f32349cf5a256d5bd7802ab87e84">sendn</a> (sockfd, &amp;pkt, <span class="keyword">sizeof</span>(pkt)) &lt; 0) {
<a name="l00348"></a>00348         seaf_warning (<span class="stringliteral">&quot;Failed to write socket: %s.\n&quot;</span>, 
<a name="l00349"></a>00349                    evutil_socket_error_to_string(EVUTIL_SOCKET_ERROR()));
<a name="l00350"></a>00350         ret = -1;
<a name="l00351"></a>00351         <span class="keywordflow">goto</span> out;
<a name="l00352"></a>00352     }
<a name="l00353"></a>00353 
<a name="l00354"></a>00354     <span class="keywordflow">while</span> (1) {
<a name="l00355"></a>00355         n = <a class="code" href="block-mgr_8c.html#a3f01e48b64b37ab59ee9875a572e945a">seaf_block_manager_read_block</a> (block_mgr, handle, buf, <a class="code" href="blocktx-common-impl-v2_8h.html#a722507cf2472bd985d296aa202057d42">IO_BUF_LEN</a>);
<a name="l00356"></a>00356         <span class="keywordflow">if</span> (n &lt;= 0)
<a name="l00357"></a>00357             <span class="keywordflow">break</span>;
<a name="l00358"></a>00358         remain -= n;
<a name="l00359"></a>00359 
<a name="l00360"></a>00360         <span class="keywordflow">if</span> (tdata-&gt;<a class="code" href="structThreadData.html#a63980e9374513d2266aa1952afe40352">encrypt_channel</a>)
<a name="l00361"></a>00361             ret = <a class="code" href="block-tx-utils_8c.html#a1e10866a0e3b693d203bcd73e4cb4036">send_encrypted_data</a> (&amp;ctx, sockfd, buf, n, remain);
<a name="l00362"></a>00362         <span class="keywordflow">else</span>
<a name="l00363"></a>00363             ret = <a class="code" href="seafile-4_81_82_2lib_2utils_8c.html#aa324f32349cf5a256d5bd7802ab87e84">sendn</a> (sockfd, buf, n);
<a name="l00364"></a>00364 
<a name="l00365"></a>00365         <span class="keywordflow">if</span> (ret &lt; 0) {
<a name="l00366"></a>00366             seaf_warning (<span class="stringliteral">&quot;Failed to write block %s\n&quot;</span>, block_id);
<a name="l00367"></a>00367             <span class="keywordflow">goto</span> out;
<a name="l00368"></a>00368         }
<a name="l00369"></a>00369 <span class="preprocessor">#ifdef SENDBLOCK_PROC</span>
<a name="l00370"></a>00370 <span class="preprocessor"></span>        <span class="comment">/* Update global transferred bytes. */</span>
<a name="l00371"></a>00371         g_atomic_int_add (&amp;(tdata-&gt;task-&gt;tx_bytes), n);
<a name="l00372"></a>00372         g_atomic_int_add (&amp;(<a class="code" href="seaf-daemon_8c.html#ae66636d1834d105bd51d89ff01acfe15">seaf</a>-&gt;<a class="code" href="struct__SeafileSession.html#aa04a8214ef989d1e5d68799dc19cbf22">transfer_mgr</a>-&gt;sent_bytes), n);
<a name="l00373"></a>00373 
<a name="l00374"></a>00374         <span class="comment">/* If uploaded bytes exceeds the limit, wait until the counter</span>
<a name="l00375"></a>00375 <span class="comment">         * is reset. We check the counter every 100 milliseconds, so we</span>
<a name="l00376"></a>00376 <span class="comment">         * can waste up to 100 milliseconds without sending data after</span>
<a name="l00377"></a>00377 <span class="comment">         * the counter is reset.</span>
<a name="l00378"></a>00378 <span class="comment">         */</span>
<a name="l00379"></a>00379         <span class="keywordflow">while</span> (1) {
<a name="l00380"></a>00380             gint sent = g_atomic_int_get(&amp;(<a class="code" href="seaf-daemon_8c.html#ae66636d1834d105bd51d89ff01acfe15">seaf</a>-&gt;<a class="code" href="struct__SeafileSession.html#aa04a8214ef989d1e5d68799dc19cbf22">transfer_mgr</a>-&gt;sent_bytes));
<a name="l00381"></a>00381             <span class="keywordflow">if</span> (<a class="code" href="seaf-daemon_8c.html#ae66636d1834d105bd51d89ff01acfe15">seaf</a>-&gt;<a class="code" href="struct__SeafileSession.html#aa04a8214ef989d1e5d68799dc19cbf22">transfer_mgr</a>-&gt;upload_limit &gt; 0 &amp;&amp;
<a name="l00382"></a>00382                 sent &gt; <a class="code" href="seaf-daemon_8c.html#ae66636d1834d105bd51d89ff01acfe15">seaf</a>-&gt;<a class="code" href="struct__SeafileSession.html#aa04a8214ef989d1e5d68799dc19cbf22">transfer_mgr</a>-&gt;upload_limit)
<a name="l00383"></a>00383                 <span class="comment">/* 100 milliseconds */</span>
<a name="l00384"></a>00384                 g_usleep (100000);
<a name="l00385"></a>00385             <span class="keywordflow">else</span>
<a name="l00386"></a>00386                 <span class="keywordflow">break</span>;
<a name="l00387"></a>00387         }
<a name="l00388"></a>00388 <span class="preprocessor">#endif</span>
<a name="l00389"></a>00389 <span class="preprocessor"></span>    }
<a name="l00390"></a>00390     <span class="keywordflow">if</span> (n &lt; 0) {
<a name="l00391"></a>00391         seaf_warning (<span class="stringliteral">&quot;Failed to write block %s\n&quot;</span>, block_id);
<a name="l00392"></a>00392         ret = -1;
<a name="l00393"></a>00393         <span class="keywordflow">goto</span> out;
<a name="l00394"></a>00394     }
<a name="l00395"></a>00395 
<a name="l00396"></a>00396     send_block_rsp (tdata-&gt;<a class="code" href="structThreadData.html#aa92f35671104d9f3c2bc60fc5a15adfd">cevent_id</a>, block_idx, block_id, size, 0);
<a name="l00397"></a>00397 
<a name="l00398"></a>00398 
<a name="l00399"></a>00399 out:
<a name="l00400"></a>00400     <span class="keywordflow">if</span> (tdata-&gt;<a class="code" href="structThreadData.html#a63980e9374513d2266aa1952afe40352">encrypt_channel</a>)
<a name="l00401"></a>00401         EVP_CIPHER_CTX_cleanup (&amp;ctx);
<a name="l00402"></a>00402 
<a name="l00403"></a>00403     <span class="keywordflow">return</span> ret;
<a name="l00404"></a>00404 }
<a name="l00405"></a>00405 
<a name="l00406"></a>00406 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l00407"></a>00407 send_blocks (<a class="code" href="structThreadData.html">ThreadData</a> *tdata)
<a name="l00408"></a>00408 {
<a name="l00409"></a>00409     <a class="code" href="struct__SeafRepo.html">SeafRepo</a> *repo;
<a name="l00410"></a>00410     <span class="keywordtype">char</span> store_id[37];
<a name="l00411"></a>00411     <span class="keywordtype">int</span> repo_version;
<a name="l00412"></a>00412     <a class="code" href="struct__SeafBlockManager.html">SeafBlockManager</a> *block_mgr = <a class="code" href="seaf-daemon_8c.html#ae66636d1834d105bd51d89ff01acfe15">seaf</a>-&gt;<a class="code" href="struct__SeafileSession.html#a4b29afaa0ca920084596a236c8460df2">block_mgr</a>;
<a name="l00413"></a>00413     <a class="code" href="structBlockRequest.html">BlockRequest</a> blk_req;
<a name="l00414"></a>00414     <a class="code" href="struct__BHandle.html">BlockHandle</a> *handle;
<a name="l00415"></a>00415     <span class="keywordtype">int</span>         n;
<a name="l00416"></a>00416     <span class="keywordtype">int</span>         ret;
<a name="l00417"></a>00417     fd_set      fds;
<a name="l00418"></a>00418     <span class="keywordtype">int</span> max_fd = tdata-&gt;<a class="code" href="structThreadData.html#a661392febd30e97efaa1ed18ce77f08a">task_pipe</a>[0];
<a name="l00419"></a>00419     <span class="keyword">struct </span>timeval tv = { <a class="code" href="blocktx-common-impl-v2_8h.html#a6d8ea342c6a0c6abf6f7b3e673fe5471">BLOCKTX_TIMEOUT</a>, 0 };
<a name="l00420"></a>00420 
<a name="l00421"></a>00421     repo = <a class="code" href="daemon_2Backups_2repo-mgr_8c.html#af0276c036723560e3e8b9aa5529133d6">seaf_repo_manager_get_repo</a> (<a class="code" href="seaf-daemon_8c.html#ae66636d1834d105bd51d89ff01acfe15">seaf</a>-&gt;<a class="code" href="struct__SeafileSession.html#a08681eb4d012b49f2552a91f4ba494f7">repo_mgr</a>, tdata-&gt;<a class="code" href="structThreadData.html#aa248e41d5e9ef522d91dab0591a8ab68">repo_id</a>);
<a name="l00422"></a>00422     <span class="keywordflow">if</span> (!repo) {
<a name="l00423"></a>00423         seaf_warning (<span class="stringliteral">&quot;Failed to get repo %.8s.\n&quot;</span>, tdata-&gt;<a class="code" href="structThreadData.html#aa248e41d5e9ef522d91dab0591a8ab68">repo_id</a>);
<a name="l00424"></a>00424         <span class="keywordflow">return</span> -1;
<a name="l00425"></a>00425     }
<a name="l00426"></a>00426     memcpy (store_id, repo-&gt;<a class="code" href="struct__SeafRepo.html#a806d8d4c51581a0a06e7b675023178ae">store_id</a>, 36);
<a name="l00427"></a>00427     repo_version = repo-&gt;<a class="code" href="struct__SeafRepo.html#ab75d342176657e7504c5cddd5ca2c56a">version</a>;
<a name="l00428"></a>00428 
<a name="l00429"></a>00429 <span class="preprocessor">#ifdef PUTBLOCK_PROC</span>
<a name="l00430"></a>00430 <span class="preprocessor"></span>    <a class="code" href="fuse_2Backups_2repo-mgr_8c.html#af6bedb063685823d91f2a335c6882e07">seaf_repo_unref</a> (repo);
<a name="l00431"></a>00431 <span class="preprocessor">#endif</span>
<a name="l00432"></a>00432 <span class="preprocessor"></span>
<a name="l00433"></a>00433     <span class="keywordflow">while</span> (1) {
<a name="l00434"></a>00434         FD_ZERO (&amp;fds);
<a name="l00435"></a>00435         FD_SET (tdata-&gt;<a class="code" href="structThreadData.html#a661392febd30e97efaa1ed18ce77f08a">task_pipe</a>[0], &amp;fds);
<a name="l00436"></a>00436         tv.tv_sec = <a class="code" href="blocktx-common-impl-v2_8h.html#a6d8ea342c6a0c6abf6f7b3e673fe5471">BLOCKTX_TIMEOUT</a>;
<a name="l00437"></a>00437         tv.tv_usec = 0;
<a name="l00438"></a>00438 
<a name="l00439"></a>00439         n = select (max_fd + 1, &amp;fds, NULL, NULL, &amp;tv);
<a name="l00440"></a>00440         <span class="keywordflow">if</span> (n &lt; 0 &amp;&amp; errno == EINTR) {
<a name="l00441"></a>00441             <span class="keywordflow">continue</span>;
<a name="l00442"></a>00442         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (n &lt; 0) {
<a name="l00443"></a>00443             seaf_warning (<span class="stringliteral">&quot;select error: %s.\n&quot;</span>, strerror(errno));
<a name="l00444"></a>00444             <span class="keywordflow">return</span> -1;
<a name="l00445"></a>00445         }
<a name="l00446"></a>00446 
<a name="l00447"></a>00447 <span class="preprocessor">#ifdef PUTBLOCK_PROC</span>
<a name="l00448"></a>00448 <span class="preprocessor"></span>        <span class="keywordflow">if</span> (n == 0) {
<a name="l00449"></a>00449             seaf_warning (<span class="stringliteral">&quot;timeout before GET_BLOCK command arrives.\n&quot;</span>);
<a name="l00450"></a>00450             <span class="keywordflow">return</span> -1;
<a name="l00451"></a>00451         }
<a name="l00452"></a>00452 <span class="preprocessor">#endif</span>
<a name="l00453"></a>00453 <span class="preprocessor"></span>
<a name="l00454"></a>00454 <span class="preprocessor">#ifdef SENDBLOCK_PROC</span>
<a name="l00455"></a>00455 <span class="preprocessor"></span>        <span class="keywordflow">if</span> (n == 0)
<a name="l00456"></a>00456             <span class="keywordflow">continue</span>;
<a name="l00457"></a>00457 <span class="preprocessor">#endif</span>
<a name="l00458"></a>00458 <span class="preprocessor"></span>
<a name="l00459"></a>00459         n = <a class="code" href="seafile-4_81_82_2lib_2utils_8h.html#a0f3e434ccfa089b0ee658045a82dd2f2">pipereadn</a> (tdata-&gt;<a class="code" href="structThreadData.html#a661392febd30e97efaa1ed18ce77f08a">task_pipe</a>[0], &amp;blk_req, <span class="keyword">sizeof</span>(blk_req));
<a name="l00460"></a>00460         <span class="keywordflow">if</span> (n == 0) {
<a name="l00461"></a>00461             seaf_debug (<span class="stringliteral">&quot;Processor exited. Worker thread exits now.\n&quot;</span>);
<a name="l00462"></a>00462             <span class="keywordflow">return</span> -1;
<a name="l00463"></a>00463         }
<a name="l00464"></a>00464         <span class="keywordflow">if</span> (n != <span class="keyword">sizeof</span>(blk_req)) {
<a name="l00465"></a>00465             seaf_warning (<span class="stringliteral">&quot;read task pipe incorrect.\n&quot;</span>);
<a name="l00466"></a>00466             <span class="keywordflow">return</span> -1;
<a name="l00467"></a>00467         }
<a name="l00468"></a>00468 
<a name="l00469"></a>00469         handle = <a class="code" href="block-mgr_8c.html#a056c34bef84deef28712969643b00dbc">seaf_block_manager_open_block</a> (block_mgr,
<a name="l00470"></a>00470                                                 store_id, repo_version,
<a name="l00471"></a>00471                                                 blk_req.<a class="code" href="structBlockRequest.html#a9cef60a157f2585990d7e63cd18d2cd9">block_id</a>, <a class="code" href="block_8h.html#a99fb83031ce9923c84392b4e92f956b5a70a1891853a7e204617bdcf9adcfd4a5">BLOCK_READ</a>);
<a name="l00472"></a>00472         <span class="keywordflow">if</span> (!handle) {
<a name="l00473"></a>00473             seaf_warning (<span class="stringliteral">&quot;[send block] failed to open block %s.\n&quot;</span>, 
<a name="l00474"></a>00474                        blk_req.<a class="code" href="structBlockRequest.html#a9cef60a157f2585990d7e63cd18d2cd9">block_id</a>);
<a name="l00475"></a>00475             <span class="keywordflow">return</span> -1;
<a name="l00476"></a>00476         }
<a name="l00477"></a>00477 
<a name="l00478"></a>00478         ret = send_block_packet (tdata, blk_req.<a class="code" href="structBlockRequest.html#a68f36717ac413a3522736ddf12b13525">block_idx</a>, blk_req.<a class="code" href="structBlockRequest.html#a9cef60a157f2585990d7e63cd18d2cd9">block_id</a>, 
<a name="l00479"></a>00479                                  handle, tdata-&gt;<a class="code" href="structThreadData.html#af62c31466a162c9a0197778da78477ae">data_fd</a>);
<a name="l00480"></a>00480 
<a name="l00481"></a>00481         <a class="code" href="block-mgr_8c.html#aa78b63ce0fb941132f6db665de4966bc">seaf_block_manager_close_block</a> (block_mgr, handle);
<a name="l00482"></a>00482         <a class="code" href="block-mgr_8c.html#a61d32d9d0d064dea33a1e2e7008215c1">seaf_block_manager_block_handle_free</a> (block_mgr, handle);
<a name="l00483"></a>00483 
<a name="l00484"></a>00484         <span class="keywordflow">if</span> (ret &lt; 0)
<a name="l00485"></a>00485             <span class="keywordflow">return</span> -1;
<a name="l00486"></a>00486     }
<a name="l00487"></a>00487 
<a name="l00488"></a>00488     <span class="keywordflow">return</span> 0;
<a name="l00489"></a>00489 }
<a name="l00490"></a>00490 
<a name="l00491"></a>00491 <span class="preprocessor">#endif  </span><span class="comment">/* defined SENDBLOCK_PROC || defined PUTBLOCK_PROC */</span>
<a name="l00492"></a>00492 
<a name="l00493"></a>00493 <span class="preprocessor">#if defined GETBLOCK_PROC || defined RECVBLOCK_PROC</span>
<a name="l00494"></a>00494 <span class="preprocessor"></span>
<a name="l00495"></a>00495 <span class="keyword">enum</span> {
<a name="l00496"></a>00496     <a class="code" href="blocktx-common-impl_8h.html#adc29c2ff13d900c2f185ee95427fb06ca959f63413812c69cbaf8e7dff55c708f">RECV_STATE_HEADER</a>,
<a name="l00497"></a>00497     <a class="code" href="blocktx-common-impl_8h.html#adc29c2ff13d900c2f185ee95427fb06cac5babe15028b197b16414bb49e5daf61">RECV_STATE_BLOCK</a>,
<a name="l00498"></a>00498 };
<a name="l00499"></a>00499 
<a name="l00500"></a>00500 <span class="keyword">typedef</span> <span class="keyword">struct </span>{
<a name="l00501"></a>00501     <a class="code" href="structThreadData.html">ThreadData</a> *tdata;
<a name="l00502"></a>00502     <span class="keywordtype">int</span> state;
<a name="l00503"></a>00503     BlockPacket hdr;
<a name="l00504"></a>00504     <span class="keywordtype">int</span> remain;
<a name="l00505"></a>00505     <a class="code" href="struct__BHandle.html">BlockHandle</a> *handle;
<a name="l00506"></a>00506     uint32_t cevent_id;
<a name="l00507"></a>00507     EVP_CIPHER_CTX ctx;
<a name="l00508"></a>00508     gboolean enc_init;
<a name="l00509"></a>00509     <span class="keywordtype">char</span> store_id[37];
<a name="l00510"></a>00510     <span class="keywordtype">int</span> repo_version;
<a name="l00511"></a>00511 } <a class="code" href="upload-file_8c.html#a6bc3f3178a367af82bd5c24008c0a89e">RecvFSM</a>;
<a name="l00512"></a>00512 
<a name="l00513"></a>00513 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l00514"></a>00514 decrypt_init (EVP_CIPHER_CTX *ctx,
<a name="l00515"></a>00515               <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *key,
<a name="l00516"></a>00516               <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *iv)
<a name="l00517"></a>00517 {
<a name="l00518"></a>00518     <span class="keywordtype">int</span> ret;
<a name="l00519"></a>00519 
<a name="l00520"></a>00520     <span class="comment">/* Prepare CTX for decryption. */</span>
<a name="l00521"></a>00521     EVP_CIPHER_CTX_init (ctx);
<a name="l00522"></a>00522 
<a name="l00523"></a>00523     ret = EVP_DecryptInit_ex (ctx,
<a name="l00524"></a>00524                               EVP_aes_256_cbc(), <span class="comment">/* cipher mode */</span>
<a name="l00525"></a>00525                               NULL, <span class="comment">/* engine, NULL for default */</span>
<a name="l00526"></a>00526                               key,  <span class="comment">/* derived key */</span>
<a name="l00527"></a>00527                               iv);  <span class="comment">/* initial vector */</span>
<a name="l00528"></a>00528     <span class="keywordflow">if</span> (ret == 0)
<a name="l00529"></a>00529         <span class="keywordflow">return</span> -1;
<a name="l00530"></a>00530 
<a name="l00531"></a>00531     <span class="keywordflow">return</span> 0;
<a name="l00532"></a>00532 }
<a name="l00533"></a>00533 
<a name="l00534"></a>00534 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l00535"></a>00535 write_decrypted_data (<span class="keyword">const</span> <span class="keywordtype">char</span> *buf, <span class="keywordtype">int</span> len,
<a name="l00536"></a>00536                       <a class="code" href="structRecvFSM.html">RecvFSM</a> *fsm)
<a name="l00537"></a>00537 {
<a name="l00538"></a>00538     <span class="keywordtype">char</span> out_buf[<a class="code" href="blocktx-common-impl-v2_8h.html#a722507cf2472bd985d296aa202057d42">IO_BUF_LEN</a> + <a class="code" href="blocktx-common-impl-v2_8h.html#a44257c425d2f3b28f78f1f0f048c3307">ENC_BLOCK_SIZE</a>];
<a name="l00539"></a>00539     <span class="keywordtype">int</span> out_len;
<a name="l00540"></a>00540 
<a name="l00541"></a>00541     <span class="keywordflow">if</span> (EVP_DecryptUpdate (&amp;fsm-&gt;ctx,
<a name="l00542"></a>00542                            (<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *)out_buf, &amp;out_len,
<a name="l00543"></a>00543                            (<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *)buf, len) == 0) {
<a name="l00544"></a>00544         seaf_warning (<span class="stringliteral">&quot;Failed to decrypt data.\n&quot;</span>);
<a name="l00545"></a>00545         <span class="keywordflow">return</span> -1;
<a name="l00546"></a>00546     }
<a name="l00547"></a>00547 
<a name="l00548"></a>00548     <span class="keywordflow">if</span> (<a class="code" href="block-mgr_8c.html#a3a19508559060678dcdf1b2426b8ed99">seaf_block_manager_write_block</a> (<a class="code" href="seaf-daemon_8c.html#ae66636d1834d105bd51d89ff01acfe15">seaf</a>-&gt;<a class="code" href="struct__SeafileSession.html#a4b29afaa0ca920084596a236c8460df2">block_mgr</a>, fsm-&gt;<a class="code" href="structRecvFSM.html#a9b38d59482965864aa683384724258ba">handle</a>,
<a name="l00549"></a>00549                                         out_buf, out_len) &lt; 0) {
<a name="l00550"></a>00550         seaf_warning (<span class="stringliteral">&quot;Failed to write block %s.\n&quot;</span>, fsm-&gt;<a class="code" href="structRecvFSM.html#a03c333c28bdbb8a6497106f1788dec0d">hdr</a>.block_id);
<a name="l00551"></a>00551         <span class="keywordflow">return</span> -1;
<a name="l00552"></a>00552     }
<a name="l00553"></a>00553 
<a name="l00554"></a>00554     <span class="keywordflow">if</span> (fsm-&gt;<a class="code" href="structRecvFSM.html#a3304a6c7dccfb11a90164457e482e630">remain</a> == 0) {
<a name="l00555"></a>00555         <span class="keywordflow">if</span> (EVP_DecryptFinal_ex (&amp;fsm-&gt;ctx, (<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *)out_buf, &amp;out_len) == 0)
<a name="l00556"></a>00556         {
<a name="l00557"></a>00557             seaf_warning (<span class="stringliteral">&quot;Failed to decrypt data.\n&quot;</span>);
<a name="l00558"></a>00558             <span class="keywordflow">return</span> -1;
<a name="l00559"></a>00559         }
<a name="l00560"></a>00560 
<a name="l00561"></a>00561         <span class="keywordflow">if</span> (<a class="code" href="block-mgr_8c.html#a3a19508559060678dcdf1b2426b8ed99">seaf_block_manager_write_block</a> (<a class="code" href="seaf-daemon_8c.html#ae66636d1834d105bd51d89ff01acfe15">seaf</a>-&gt;<a class="code" href="struct__SeafileSession.html#a4b29afaa0ca920084596a236c8460df2">block_mgr</a>, fsm-&gt;<a class="code" href="structRecvFSM.html#a9b38d59482965864aa683384724258ba">handle</a>,
<a name="l00562"></a>00562                                             out_buf, out_len) &lt; 0) {
<a name="l00563"></a>00563             seaf_warning (<span class="stringliteral">&quot;Failed to write block %s.\n&quot;</span>, fsm-&gt;<a class="code" href="structRecvFSM.html#a03c333c28bdbb8a6497106f1788dec0d">hdr</a>.block_id);
<a name="l00564"></a>00564             <span class="keywordflow">return</span> -1;
<a name="l00565"></a>00565         }
<a name="l00566"></a>00566     }
<a name="l00567"></a>00567 
<a name="l00568"></a>00568     <span class="keywordflow">return</span> 0;
<a name="l00569"></a>00569 }
<a name="l00570"></a>00570 
<a name="l00571"></a>00571 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l00572"></a>00572 recv_tick (<a class="code" href="structRecvFSM.html">RecvFSM</a> *fsm, evutil_socket_t sockfd)
<a name="l00573"></a>00573 {
<a name="l00574"></a>00574     <a class="code" href="struct__SeafBlockManager.html">SeafBlockManager</a> *block_mgr = <a class="code" href="seaf-daemon_8c.html#ae66636d1834d105bd51d89ff01acfe15">seaf</a>-&gt;<a class="code" href="struct__SeafileSession.html#a4b29afaa0ca920084596a236c8460df2">block_mgr</a>;
<a name="l00575"></a>00575     <span class="keywordtype">char</span> *<a class="code" href="block-tx-utils_8h.html#a2d616e1f81d11995c8b388444be651ef">block_id</a>;
<a name="l00576"></a>00576     <a class="code" href="struct__BHandle.html">BlockHandle</a> *handle;
<a name="l00577"></a>00577     <span class="keywordtype">int</span> n, round;
<a name="l00578"></a>00578     <span class="keywordtype">char</span> buf[<a class="code" href="blocktx-common-impl-v2_8h.html#a722507cf2472bd985d296aa202057d42">IO_BUF_LEN</a>];
<a name="l00579"></a>00579 <span class="preprocessor">#ifdef GETBLOCK_PROC</span>
<a name="l00580"></a>00580 <span class="preprocessor"></span>    gint recv_bytes;
<a name="l00581"></a>00581 <span class="preprocessor">#endif</span>
<a name="l00582"></a>00582 <span class="preprocessor"></span>
<a name="l00583"></a>00583     <span class="keywordflow">switch</span> (fsm-&gt;<a class="code" href="structRecvFSM.html#a2ec7b790a57d2f9dc2d6c1e44daee3c3">state</a>) {
<a name="l00584"></a>00584     <span class="keywordflow">case</span> <a class="code" href="blocktx-common-impl_8h.html#adc29c2ff13d900c2f185ee95427fb06ca959f63413812c69cbaf8e7dff55c708f">RECV_STATE_HEADER</a>:
<a name="l00585"></a>00585         n = recv (sockfd, 
<a name="l00586"></a>00586                   (<span class="keywordtype">char</span> *)&amp;fsm-&gt;<a class="code" href="structRecvFSM.html#a03c333c28bdbb8a6497106f1788dec0d">hdr</a> + <span class="keyword">sizeof</span>(BlockPacket) - fsm-&gt;<a class="code" href="structRecvFSM.html#a3304a6c7dccfb11a90164457e482e630">remain</a>, 
<a name="l00587"></a>00587                   fsm-&gt;<a class="code" href="structRecvFSM.html#a3304a6c7dccfb11a90164457e482e630">remain</a>, 0);
<a name="l00588"></a>00588         <span class="keywordflow">if</span> (n &lt; 0) {
<a name="l00589"></a>00589             seaf_warning (<span class="stringliteral">&quot;Failed to read block pkt: %s.\n&quot;</span>,
<a name="l00590"></a>00590                        evutil_socket_error_to_string(EVUTIL_SOCKET_ERROR()));
<a name="l00591"></a>00591             <span class="keywordflow">return</span> -1;
<a name="l00592"></a>00592         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (n == 0) {
<a name="l00593"></a>00593             seaf_debug (<span class="stringliteral">&quot;data connection closed.\n&quot;</span>);
<a name="l00594"></a>00594             <span class="keywordflow">return</span> -1;
<a name="l00595"></a>00595         }
<a name="l00596"></a>00596 
<a name="l00597"></a>00597         fsm-&gt;<a class="code" href="structRecvFSM.html#a3304a6c7dccfb11a90164457e482e630">remain</a> -= n;
<a name="l00598"></a>00598         <span class="keywordflow">if</span> (fsm-&gt;<a class="code" href="structRecvFSM.html#a3304a6c7dccfb11a90164457e482e630">remain</a> == 0) {
<a name="l00599"></a>00599             fsm-&gt;<a class="code" href="structRecvFSM.html#a3304a6c7dccfb11a90164457e482e630">remain</a> = (int) ntohl (fsm-&gt;<a class="code" href="structRecvFSM.html#a03c333c28bdbb8a6497106f1788dec0d">hdr</a>.block_size);
<a name="l00600"></a>00600             block_id = fsm-&gt;<a class="code" href="structRecvFSM.html#a03c333c28bdbb8a6497106f1788dec0d">hdr</a>.block_id;
<a name="l00601"></a>00601             block_id[40] = 0;
<a name="l00602"></a>00602 
<a name="l00603"></a>00603             handle = <a class="code" href="block-mgr_8c.html#a056c34bef84deef28712969643b00dbc">seaf_block_manager_open_block</a> (block_mgr,
<a name="l00604"></a>00604                                                     fsm-&gt;store_id, fsm-&gt;repo_version,
<a name="l00605"></a>00605                                                     block_id, <a class="code" href="block_8h.html#a99fb83031ce9923c84392b4e92f956b5a0a33c2a4005cb32ae50b7f3688cfbc76">BLOCK_WRITE</a>);
<a name="l00606"></a>00606             <span class="keywordflow">if</span> (!handle) {
<a name="l00607"></a>00607                 seaf_warning (<span class="stringliteral">&quot;failed to open block %s.\n&quot;</span>, block_id);
<a name="l00608"></a>00608                 <span class="keywordflow">return</span> -1;
<a name="l00609"></a>00609             }
<a name="l00610"></a>00610             fsm-&gt;<a class="code" href="structRecvFSM.html#a9b38d59482965864aa683384724258ba">handle</a> = handle; 
<a name="l00611"></a>00611             fsm-&gt;<a class="code" href="structRecvFSM.html#a2ec7b790a57d2f9dc2d6c1e44daee3c3">state</a> = <a class="code" href="blocktx-common-impl_8h.html#adc29c2ff13d900c2f185ee95427fb06cac5babe15028b197b16414bb49e5daf61">RECV_STATE_BLOCK</a>;
<a name="l00612"></a>00612 
<a name="l00613"></a>00613             <span class="keywordflow">if</span> (fsm-&gt;tdata-&gt;encrypt_channel) {
<a name="l00614"></a>00614                 decrypt_init (&amp;fsm-&gt;ctx, fsm-&gt;tdata-&gt;key, fsm-&gt;tdata-&gt;iv);
<a name="l00615"></a>00615                 fsm-&gt;enc_init = TRUE;
<a name="l00616"></a>00616             }
<a name="l00617"></a>00617         }
<a name="l00618"></a>00618         <span class="keywordflow">break</span>;
<a name="l00619"></a>00619     <span class="keywordflow">case</span> <a class="code" href="blocktx-common-impl_8h.html#adc29c2ff13d900c2f185ee95427fb06cac5babe15028b197b16414bb49e5daf61">RECV_STATE_BLOCK</a>:
<a name="l00620"></a>00620 <span class="preprocessor">#ifdef GETBLOCK_PROC</span>
<a name="l00621"></a>00621 <span class="preprocessor"></span>        recv_bytes = g_atomic_int_get (&amp;(<a class="code" href="seaf-daemon_8c.html#ae66636d1834d105bd51d89ff01acfe15">seaf</a>-&gt;<a class="code" href="struct__SeafileSession.html#aa04a8214ef989d1e5d68799dc19cbf22">transfer_mgr</a>-&gt;recv_bytes));
<a name="l00622"></a>00622         <span class="keywordflow">if</span> (<a class="code" href="seaf-daemon_8c.html#ae66636d1834d105bd51d89ff01acfe15">seaf</a>-&gt;<a class="code" href="struct__SeafileSession.html#aa04a8214ef989d1e5d68799dc19cbf22">transfer_mgr</a>-&gt;download_limit &gt; 0 &amp;&amp;
<a name="l00623"></a>00623             recv_bytes &gt; <a class="code" href="seaf-daemon_8c.html#ae66636d1834d105bd51d89ff01acfe15">seaf</a>-&gt;<a class="code" href="struct__SeafileSession.html#aa04a8214ef989d1e5d68799dc19cbf22">transfer_mgr</a>-&gt;download_limit) {
<a name="l00624"></a>00624             g_usleep (100000);
<a name="l00625"></a>00625             <span class="keywordflow">return</span> 0;
<a name="l00626"></a>00626         }
<a name="l00627"></a>00627 <span class="preprocessor">#endif</span>
<a name="l00628"></a>00628 <span class="preprocessor"></span>
<a name="l00629"></a>00629         handle = fsm-&gt;<a class="code" href="structRecvFSM.html#a9b38d59482965864aa683384724258ba">handle</a>;
<a name="l00630"></a>00630         block_id = fsm-&gt;<a class="code" href="structRecvFSM.html#a03c333c28bdbb8a6497106f1788dec0d">hdr</a>.block_id;
<a name="l00631"></a>00631 
<a name="l00632"></a>00632         round = MIN (fsm-&gt;<a class="code" href="structRecvFSM.html#a3304a6c7dccfb11a90164457e482e630">remain</a>, <a class="code" href="blocktx-common-impl-v2_8h.html#a722507cf2472bd985d296aa202057d42">IO_BUF_LEN</a>);
<a name="l00633"></a>00633         n = recv (sockfd, buf, round, 0);
<a name="l00634"></a>00634         <span class="keywordflow">if</span> (n &lt; 0) {
<a name="l00635"></a>00635             seaf_warning (<span class="stringliteral">&quot;failed to read data: %s.\n&quot;</span>,
<a name="l00636"></a>00636                        evutil_socket_error_to_string(EVUTIL_SOCKET_ERROR()));
<a name="l00637"></a>00637             <span class="keywordflow">return</span> -1;
<a name="l00638"></a>00638         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (n == 0) {
<a name="l00639"></a>00639             seaf_debug (<span class="stringliteral">&quot;data connection closed.\n&quot;</span>);
<a name="l00640"></a>00640             <span class="keywordflow">return</span> -1;
<a name="l00641"></a>00641         }
<a name="l00642"></a>00642         fsm-&gt;<a class="code" href="structRecvFSM.html#a3304a6c7dccfb11a90164457e482e630">remain</a> -= n;
<a name="l00643"></a>00643 
<a name="l00644"></a>00644         <span class="keywordtype">int</span> ret;
<a name="l00645"></a>00645         <span class="keywordflow">if</span> (fsm-&gt;tdata-&gt;encrypt_channel)
<a name="l00646"></a>00646             ret = write_decrypted_data (buf, n, fsm);
<a name="l00647"></a>00647         <span class="keywordflow">else</span>
<a name="l00648"></a>00648             ret = <a class="code" href="block-mgr_8c.html#a3a19508559060678dcdf1b2426b8ed99">seaf_block_manager_write_block</a> (block_mgr, handle, buf, n);
<a name="l00649"></a>00649 
<a name="l00650"></a>00650         <span class="keywordflow">if</span> (ret &lt; 0) {
<a name="l00651"></a>00651             seaf_warning (<span class="stringliteral">&quot;Failed to write block %s.\n&quot;</span>, fsm-&gt;<a class="code" href="structRecvFSM.html#a03c333c28bdbb8a6497106f1788dec0d">hdr</a>.block_id);
<a name="l00652"></a>00652             <span class="keywordflow">return</span> -1;
<a name="l00653"></a>00653         }
<a name="l00654"></a>00654 
<a name="l00655"></a>00655 <span class="preprocessor">#ifdef GETBLOCK_PROC</span>
<a name="l00656"></a>00656 <span class="preprocessor"></span>        <span class="comment">/* Update global transferred bytes. */</span>
<a name="l00657"></a>00657         g_atomic_int_add (&amp;(fsm-&gt;tdata-&gt;task-&gt;tx_bytes), n);
<a name="l00658"></a>00658         g_atomic_int_add (&amp;(<a class="code" href="seaf-daemon_8c.html#ae66636d1834d105bd51d89ff01acfe15">seaf</a>-&gt;<a class="code" href="struct__SeafileSession.html#aa04a8214ef989d1e5d68799dc19cbf22">transfer_mgr</a>-&gt;recv_bytes), n);
<a name="l00659"></a>00659 <span class="preprocessor">#endif</span>
<a name="l00660"></a>00660 <span class="preprocessor"></span>
<a name="l00661"></a>00661         <span class="keywordflow">if</span> (fsm-&gt;<a class="code" href="structRecvFSM.html#a3304a6c7dccfb11a90164457e482e630">remain</a> == 0) {
<a name="l00662"></a>00662             <span class="keywordflow">if</span> (fsm-&gt;tdata-&gt;encrypt_channel) {
<a name="l00663"></a>00663                 EVP_CIPHER_CTX_cleanup (&amp;fsm-&gt;ctx);
<a name="l00664"></a>00664                 fsm-&gt;enc_init = FALSE;
<a name="l00665"></a>00665             }
<a name="l00666"></a>00666 
<a name="l00667"></a>00667             <span class="keywordflow">if</span> (<a class="code" href="block-mgr_8c.html#aa78b63ce0fb941132f6db665de4966bc">seaf_block_manager_close_block</a> (block_mgr, handle) &lt; 0) {
<a name="l00668"></a>00668                 seaf_warning (<span class="stringliteral">&quot;Failed to close block %s.\n&quot;</span>, fsm-&gt;<a class="code" href="structRecvFSM.html#a03c333c28bdbb8a6497106f1788dec0d">hdr</a>.block_id);
<a name="l00669"></a>00669                 <span class="keywordflow">return</span> -1;
<a name="l00670"></a>00670             }
<a name="l00671"></a>00671 
<a name="l00672"></a>00672             <span class="keywordflow">if</span> (<a class="code" href="block-mgr_8c.html#a30d3350f36f7448fcf414ccc2cd59824">seaf_block_manager_commit_block</a> (block_mgr, handle) &lt; 0) {
<a name="l00673"></a>00673                 seaf_warning (<span class="stringliteral">&quot;Failed to commit block %s.\n&quot;</span>, fsm-&gt;<a class="code" href="structRecvFSM.html#a03c333c28bdbb8a6497106f1788dec0d">hdr</a>.block_id);
<a name="l00674"></a>00674                 <span class="keywordflow">return</span> -1;
<a name="l00675"></a>00675             }
<a name="l00676"></a>00676 
<a name="l00677"></a>00677             <a class="code" href="block-mgr_8c.html#a61d32d9d0d064dea33a1e2e7008215c1">seaf_block_manager_block_handle_free</a> (block_mgr, handle);
<a name="l00678"></a>00678             <span class="comment">/* Set this handle to invalid. */</span>
<a name="l00679"></a>00679             fsm-&gt;<a class="code" href="structRecvFSM.html#a9b38d59482965864aa683384724258ba">handle</a> = NULL;
<a name="l00680"></a>00680 
<a name="l00681"></a>00681             <span class="comment">/* Notify finish receiving this block. */</span>
<a name="l00682"></a>00682             send_block_rsp (fsm-&gt;<a class="code" href="structRecvFSM.html#a8a0aa1b5a6581e4e0e4180658a3820c1">cevent_id</a>,
<a name="l00683"></a>00683                             (<span class="keywordtype">int</span>)ntohl (fsm-&gt;<a class="code" href="structRecvFSM.html#a03c333c28bdbb8a6497106f1788dec0d">hdr</a>.block_idx),
<a name="l00684"></a>00684                             block_id,
<a name="l00685"></a>00685                             (<span class="keywordtype">int</span>)ntohl (fsm-&gt;<a class="code" href="structRecvFSM.html#a03c333c28bdbb8a6497106f1788dec0d">hdr</a>.block_size), 0);
<a name="l00686"></a>00686 
<a name="l00687"></a>00687             <span class="comment">/* Prepare for the next packet. */</span>
<a name="l00688"></a>00688             fsm-&gt;<a class="code" href="structRecvFSM.html#a2ec7b790a57d2f9dc2d6c1e44daee3c3">state</a> = <a class="code" href="blocktx-common-impl_8h.html#adc29c2ff13d900c2f185ee95427fb06ca959f63413812c69cbaf8e7dff55c708f">RECV_STATE_HEADER</a>;
<a name="l00689"></a>00689             fsm-&gt;<a class="code" href="structRecvFSM.html#a3304a6c7dccfb11a90164457e482e630">remain</a> = <span class="keyword">sizeof</span>(BlockPacket);
<a name="l00690"></a>00690         }
<a name="l00691"></a>00691         <span class="keywordflow">break</span>;
<a name="l00692"></a>00692     }
<a name="l00693"></a>00693 
<a name="l00694"></a>00694     <span class="keywordflow">return</span> 0;
<a name="l00695"></a>00695 }
<a name="l00696"></a>00696 
<a name="l00697"></a>00697 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l00698"></a>00698 recv_blocks (<a class="code" href="structThreadData.html">ThreadData</a> *tdata)
<a name="l00699"></a>00699 {
<a name="l00700"></a>00700     fd_set fds;
<a name="l00701"></a>00701     <span class="keywordtype">int</span> max_fd = MAX (tdata-&gt;<a class="code" href="structThreadData.html#a661392febd30e97efaa1ed18ce77f08a">task_pipe</a>[0], tdata-&gt;<a class="code" href="structThreadData.html#af62c31466a162c9a0197778da78477ae">data_fd</a>);
<a name="l00702"></a>00702     <span class="keyword">struct </span>timeval tv = { <a class="code" href="blocktx-common-impl-v2_8h.html#a6d8ea342c6a0c6abf6f7b3e673fe5471">BLOCKTX_TIMEOUT</a>, 0 };
<a name="l00703"></a>00703     <span class="keywordtype">int</span> rc;
<a name="l00704"></a>00704 
<a name="l00705"></a>00705     <a class="code" href="structRecvFSM.html">RecvFSM</a> *fsm = g_new0 (<a class="code" href="structRecvFSM.html">RecvFSM</a>, 1);
<a name="l00706"></a>00706     fsm-&gt;<a class="code" href="structRecvFSM.html#a3304a6c7dccfb11a90164457e482e630">remain</a> = <span class="keyword">sizeof</span> (BlockPacket);
<a name="l00707"></a>00707     fsm-&gt;<a class="code" href="structRecvFSM.html#a8a0aa1b5a6581e4e0e4180658a3820c1">cevent_id</a> = tdata-&gt;<a class="code" href="structThreadData.html#aa92f35671104d9f3c2bc60fc5a15adfd">cevent_id</a>;
<a name="l00708"></a>00708     fsm-&gt;tdata = tdata;
<a name="l00709"></a>00709 
<a name="l00710"></a>00710     <a class="code" href="struct__SeafRepo.html">SeafRepo</a> *repo = <a class="code" href="daemon_2Backups_2repo-mgr_8c.html#af0276c036723560e3e8b9aa5529133d6">seaf_repo_manager_get_repo</a> (<a class="code" href="seaf-daemon_8c.html#ae66636d1834d105bd51d89ff01acfe15">seaf</a>-&gt;<a class="code" href="struct__SeafileSession.html#a08681eb4d012b49f2552a91f4ba494f7">repo_mgr</a>, tdata-&gt;<a class="code" href="structThreadData.html#aa248e41d5e9ef522d91dab0591a8ab68">repo_id</a>);
<a name="l00711"></a>00711     <span class="keywordflow">if</span> (!repo) {
<a name="l00712"></a>00712         seaf_warning (<span class="stringliteral">&quot;Failed to get repo %.8s.\n&quot;</span>, tdata-&gt;<a class="code" href="structThreadData.html#aa248e41d5e9ef522d91dab0591a8ab68">repo_id</a>);
<a name="l00713"></a>00713         g_free (fsm);
<a name="l00714"></a>00714         <span class="keywordflow">return</span> -1;
<a name="l00715"></a>00715     }
<a name="l00716"></a>00716     memcpy (fsm-&gt;store_id, repo-&gt;<a class="code" href="struct__SeafRepo.html#a806d8d4c51581a0a06e7b675023178ae">store_id</a>, 36);
<a name="l00717"></a>00717     fsm-&gt;repo_version = repo-&gt;<a class="code" href="struct__SeafRepo.html#ab75d342176657e7504c5cddd5ca2c56a">version</a>;
<a name="l00718"></a>00718 
<a name="l00719"></a>00719 <span class="preprocessor">#ifdef PUTBLOCK_PROC</span>
<a name="l00720"></a>00720 <span class="preprocessor"></span>    <a class="code" href="fuse_2Backups_2repo-mgr_8c.html#af6bedb063685823d91f2a335c6882e07">seaf_repo_unref</a> (repo);
<a name="l00721"></a>00721 <span class="preprocessor">#endif</span>
<a name="l00722"></a>00722 <span class="preprocessor"></span>
<a name="l00723"></a>00723     <span class="keywordflow">while</span> (1) {
<a name="l00724"></a>00724         FD_ZERO (&amp;fds);
<a name="l00725"></a>00725         FD_SET (tdata-&gt;<a class="code" href="structThreadData.html#a661392febd30e97efaa1ed18ce77f08a">task_pipe</a>[0], &amp;fds);
<a name="l00726"></a>00726         FD_SET (tdata-&gt;<a class="code" href="structThreadData.html#af62c31466a162c9a0197778da78477ae">data_fd</a>, &amp;fds);
<a name="l00727"></a>00727         tv.tv_sec = <a class="code" href="blocktx-common-impl-v2_8h.html#a6d8ea342c6a0c6abf6f7b3e673fe5471">BLOCKTX_TIMEOUT</a>;
<a name="l00728"></a>00728         tv.tv_usec = 0;
<a name="l00729"></a>00729 
<a name="l00730"></a>00730         rc = select (max_fd + 1, &amp;fds, NULL, NULL, &amp;tv);
<a name="l00731"></a>00731         <span class="keywordflow">if</span> (rc &lt; 0 &amp;&amp; errno == EINTR) {
<a name="l00732"></a>00732             <span class="keywordflow">continue</span>;
<a name="l00733"></a>00733         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (rc &lt; 0) {
<a name="l00734"></a>00734             seaf_warning (<span class="stringliteral">&quot;select error: %s.\n&quot;</span>, strerror(errno));
<a name="l00735"></a>00735             <span class="keywordflow">goto</span> error;
<a name="l00736"></a>00736         }
<a name="l00737"></a>00737 
<a name="l00738"></a>00738 <span class="preprocessor">#ifdef RECVBLOCK_PROC</span>
<a name="l00739"></a>00739 <span class="preprocessor"></span>        <span class="keywordflow">if</span> (rc == 0) {
<a name="l00740"></a>00740             seaf_warning (<span class="stringliteral">&quot;Recv block timeout.\n&quot;</span>);
<a name="l00741"></a>00741             <span class="keywordflow">goto</span> error;
<a name="l00742"></a>00742         }
<a name="l00743"></a>00743 <span class="preprocessor">#endif</span>
<a name="l00744"></a>00744 <span class="preprocessor"></span>
<a name="l00745"></a>00745 <span class="preprocessor">#ifdef GETBLOCK_PROC</span>
<a name="l00746"></a>00746 <span class="preprocessor"></span>        <span class="keywordflow">if</span> (rc == 0)
<a name="l00747"></a>00747             <span class="keywordflow">continue</span>;
<a name="l00748"></a>00748 <span class="preprocessor">#endif</span>
<a name="l00749"></a>00749 <span class="preprocessor"></span>
<a name="l00750"></a>00750         <span class="keywordflow">if</span> (FD_ISSET (tdata-&gt;<a class="code" href="structThreadData.html#af62c31466a162c9a0197778da78477ae">data_fd</a>, &amp;fds)) {
<a name="l00751"></a>00751             <span class="keywordflow">if</span> (recv_tick (fsm, tdata-&gt;<a class="code" href="structThreadData.html#af62c31466a162c9a0197778da78477ae">data_fd</a>) &lt; 0) {
<a name="l00752"></a>00752                 <span class="keywordflow">goto</span> error;
<a name="l00753"></a>00753             }
<a name="l00754"></a>00754         }
<a name="l00755"></a>00755 
<a name="l00756"></a>00756         <span class="keywordflow">if</span> (FD_ISSET (tdata-&gt;<a class="code" href="structThreadData.html#a661392febd30e97efaa1ed18ce77f08a">task_pipe</a>[0], &amp;fds)) {
<a name="l00757"></a>00757             <span class="comment">/* task_pipe becomes readable only when the write end</span>
<a name="l00758"></a>00758 <span class="comment">             * is closed, in this case 0 is returned.</span>
<a name="l00759"></a>00759 <span class="comment">             * This means the processor was done.</span>
<a name="l00760"></a>00760 <span class="comment">             */</span>
<a name="l00761"></a>00761             <span class="keywordtype">char</span> buf[1];
<a name="l00762"></a>00762             <a class="code" href="seafile-4_81_82_2lib_2utils_8h.html#ab4c7c5fbaad73e7853c2818f1611bf42">piperead</a> (tdata-&gt;<a class="code" href="structThreadData.html#a661392febd30e97efaa1ed18ce77f08a">task_pipe</a>[0], buf, <span class="keyword">sizeof</span>(buf));
<a name="l00763"></a>00763             seaf_debug (<span class="stringliteral">&quot;Task pipe closed. Worker thread exits now.\n&quot;</span>);
<a name="l00764"></a>00764             <span class="keywordflow">goto</span> error;
<a name="l00765"></a>00765         }
<a name="l00766"></a>00766     }
<a name="l00767"></a>00767 
<a name="l00768"></a>00768     g_free (fsm);
<a name="l00769"></a>00769     <span class="keywordflow">return</span> 0;
<a name="l00770"></a>00770 
<a name="l00771"></a>00771 error:
<a name="l00772"></a>00772     <span class="keywordflow">if</span> (fsm-&gt;tdata-&gt;encrypt_channel &amp;&amp; fsm-&gt;enc_init)
<a name="l00773"></a>00773         EVP_CIPHER_CTX_cleanup (&amp;fsm-&gt;ctx);
<a name="l00774"></a>00774     <span class="keywordflow">if</span> (fsm-&gt;<a class="code" href="structRecvFSM.html#a9b38d59482965864aa683384724258ba">handle</a>) {
<a name="l00775"></a>00775         <a class="code" href="block-mgr_8c.html#aa78b63ce0fb941132f6db665de4966bc">seaf_block_manager_close_block</a> (<a class="code" href="seaf-daemon_8c.html#ae66636d1834d105bd51d89ff01acfe15">seaf</a>-&gt;<a class="code" href="struct__SeafileSession.html#a4b29afaa0ca920084596a236c8460df2">block_mgr</a>, fsm-&gt;<a class="code" href="structRecvFSM.html#a9b38d59482965864aa683384724258ba">handle</a>);
<a name="l00776"></a>00776         <a class="code" href="block-mgr_8c.html#a61d32d9d0d064dea33a1e2e7008215c1">seaf_block_manager_block_handle_free</a> (<a class="code" href="seaf-daemon_8c.html#ae66636d1834d105bd51d89ff01acfe15">seaf</a>-&gt;<a class="code" href="struct__SeafileSession.html#a4b29afaa0ca920084596a236c8460df2">block_mgr</a>, fsm-&gt;<a class="code" href="structRecvFSM.html#a9b38d59482965864aa683384724258ba">handle</a>);
<a name="l00777"></a>00777     }
<a name="l00778"></a>00778     g_free (fsm);
<a name="l00779"></a>00779     <span class="keywordflow">return</span> -1;
<a name="l00780"></a>00780 }
<a name="l00781"></a>00781 
<a name="l00782"></a>00782 <span class="preprocessor">#endif  </span><span class="comment">/* defined GETBLOCK_PROC || defined RECVBLOCK_PROC */</span>
<a name="l00783"></a>00783 
<a name="l00784"></a>00784 <span class="preprocessor">#if defined GETBLOCK_PROC || defined SENDBLOCK_PROC</span>
<a name="l00785"></a>00785 <span class="preprocessor"></span>
<a name="l00786"></a>00786 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l00787"></a>00787 master_block_proc_start (<a class="code" href="struct__CcnetProcessor.html">CcnetProcessor</a> *processor,
<a name="l00788"></a>00788                          <a class="code" href="struct__TransferTask.html">TransferTask</a> *tx_task,
<a name="l00789"></a>00789                          <span class="keyword">const</span> <span class="keywordtype">char</span> *remote_processor_name,
<a name="l00790"></a>00790                          Bitfield *active,
<a name="l00791"></a>00791                          Bitfield *block_bitmap)
<a name="l00792"></a>00792 {
<a name="l00793"></a>00793     GString *buf;
<a name="l00794"></a>00794     <span class="keywordflow">if</span> (!tx_task || !tx_task-&gt;<a class="code" href="struct__TransferTask.html#aa13c238f263454f4f4e8efa7f6c8281b">session_token</a>) {
<a name="l00795"></a>00795         seaf_warning (<span class="stringliteral">&quot;transfer task not set.\n&quot;</span>);
<a name="l00796"></a>00796         <span class="keywordflow">return</span> -1;
<a name="l00797"></a>00797     }
<a name="l00798"></a>00798 
<a name="l00799"></a>00799     BitfieldConstruct (active,
<a name="l00800"></a>00800                        tx_task-&gt;<a class="code" href="struct__TransferTask.html#a9baa45e64248034aa15eed4f2a57ff70">block_list</a>-&gt;block_map.bitCount);
<a name="l00801"></a>00801     BitfieldConstruct (block_bitmap,
<a name="l00802"></a>00802                        tx_task-&gt;<a class="code" href="struct__TransferTask.html#a9baa45e64248034aa15eed4f2a57ff70">block_list</a>-&gt;block_map.bitCount);
<a name="l00803"></a>00803 
<a name="l00804"></a>00804     buf = g_string_new (NULL);
<a name="l00805"></a>00805     g_string_printf (buf, <span class="stringliteral">&quot;remote %s %s %s&quot;</span>, 
<a name="l00806"></a>00806                      processor-&gt;<a class="code" href="struct__CcnetProcessor.html#ab9b1e96d5681f0880e23e66400effa50">peer_id</a>,
<a name="l00807"></a>00807                      remote_processor_name,
<a name="l00808"></a>00808                      tx_task-&gt;<a class="code" href="struct__TransferTask.html#aa13c238f263454f4f4e8efa7f6c8281b">session_token</a>);
<a name="l00809"></a>00809                          
<a name="l00810"></a>00810     <a class="code" href="include_2ccnet_2processor_8h.html#ac354e19db989f98be49e2559b7def26f">ccnet_processor_send_request</a> (processor, buf-&gt;str);
<a name="l00811"></a>00811     g_string_free (buf, TRUE);
<a name="l00812"></a>00812 
<a name="l00813"></a>00813     <span class="keywordflow">return</span> 0;
<a name="l00814"></a>00814 }
<a name="l00815"></a>00815 
<a name="l00816"></a>00816 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l00817"></a>00817 descruct_bitfield (Bitfield *block_bitmap,
<a name="l00818"></a>00818                    Bitfield *active,
<a name="l00819"></a>00819                    <a class="code" href="struct__TransferTask.html">TransferTask</a> *tx_task)
<a name="l00820"></a>00820 {
<a name="l00821"></a>00821     BitfieldDestruct (block_bitmap);
<a name="l00822"></a>00822     <span class="comment">/*</span>
<a name="l00823"></a>00823 <span class="comment">     * Set all the queued blocks to inactive so that they can be rescheduled.</span>
<a name="l00824"></a>00824 <span class="comment">     */</span>
<a name="l00825"></a>00825     <span class="keywordflow">if</span> (tx_task-&gt;<a class="code" href="struct__TransferTask.html#a1d4ba9aacf2e9930fb136b0092bf9531">state</a> == <a class="code" href="transfer-mgr_8h.html#a724f9ce2351c125b3b7f6c7923822bceac3efc29c1793f3f902e002589c600b33">TASK_STATE_NORMAL</a>)
<a name="l00826"></a>00826         BitfieldDifference (&amp;tx_task-&gt;active, active);
<a name="l00827"></a>00827     BitfieldDestruct (active);
<a name="l00828"></a>00828 }
<a name="l00829"></a>00829 
<a name="l00830"></a>00830 <span class="keyword">static</span> <span class="keywordtype">void</span>* do_transfer(<span class="keywordtype">void</span> *vtdata)
<a name="l00831"></a>00831 {
<a name="l00832"></a>00832     <a class="code" href="structThreadData.html">ThreadData</a> *tdata = vtdata;
<a name="l00833"></a>00833 
<a name="l00834"></a>00834     <span class="keyword">struct </span>sockaddr_storage addr;
<a name="l00835"></a>00835     <span class="keyword">struct </span>sockaddr *sa  = (<span class="keyword">struct </span>sockaddr*) &amp;addr;
<a name="l00836"></a>00836     socklen_t sa_len = <span class="keyword">sizeof</span> (addr);
<a name="l00837"></a>00837     evutil_socket_t data_fd;
<a name="l00838"></a>00838 
<a name="l00839"></a>00839     <a class="code" href="struct__CcnetPeer.html">CcnetPeer</a> *peer = tdata-&gt;<a class="code" href="structThreadData.html#accb5430140f9b5b9139c395b7279c604">peer</a>;
<a name="l00840"></a>00840 
<a name="l00841"></a>00841     <span class="keywordflow">if</span> (peer-&gt;<a class="code" href="struct__CcnetPeer.html#a33dce85d1cad5a5d054c542776fbc5fd">addr_str</a> == NULL) {
<a name="l00842"></a>00842         seaf_warning (<span class="stringliteral">&quot;peer address is NULL\n&quot;</span>);
<a name="l00843"></a>00843         tdata-&gt;<a class="code" href="structThreadData.html#a2e8c4bf0bc10240ae1fa4db655356a7d">thread_ret</a> = -1;
<a name="l00844"></a>00844         <span class="keywordflow">goto</span> out;
<a name="l00845"></a>00845     }
<a name="l00846"></a>00846 
<a name="l00847"></a>00847     <span class="keywordflow">if</span> (<a class="code" href="seafile-4_81_82_2lib_2net_8c.html#af84e07e71144e844c5937afa2df1b696">sock_pton</a>(peer-&gt;<a class="code" href="struct__CcnetPeer.html#a33dce85d1cad5a5d054c542776fbc5fd">addr_str</a>, tdata-&gt;<a class="code" href="structThreadData.html#adfba38dfc5a126bf475273dd244848fd">port</a>, &amp;addr) &lt; 0) {
<a name="l00848"></a>00848         seaf_warning (<span class="stringliteral">&quot;wrong address format %s\n&quot;</span>, peer-&gt;<a class="code" href="struct__CcnetPeer.html#a33dce85d1cad5a5d054c542776fbc5fd">addr_str</a>);
<a name="l00849"></a>00849         tdata-&gt;<a class="code" href="structThreadData.html#a2e8c4bf0bc10240ae1fa4db655356a7d">thread_ret</a> = -1;
<a name="l00850"></a>00850         <span class="keywordflow">goto</span> out;
<a name="l00851"></a>00851     }
<a name="l00852"></a>00852 
<a name="l00853"></a>00853     <span class="keywordflow">if</span> ((data_fd = socket(sa-&gt;sa_family, SOCK_STREAM, 0)) &lt; 0) {
<a name="l00854"></a>00854         seaf_warning (<span class="stringliteral">&quot;socket error: %s\n&quot;</span>, strerror(errno));
<a name="l00855"></a>00855         tdata-&gt;<a class="code" href="structThreadData.html#a2e8c4bf0bc10240ae1fa4db655356a7d">thread_ret</a> = -1;
<a name="l00856"></a>00856         <span class="keywordflow">goto</span> out;
<a name="l00857"></a>00857     }
<a name="l00858"></a>00858 
<a name="l00859"></a>00859 <span class="preprocessor">#if defined SENDBLOCK_PROC &amp;&amp; defined WIN32</span>
<a name="l00860"></a>00860 <span class="preprocessor"></span>    <span class="comment">/* Set large enough TCP buffer size.</span>
<a name="l00861"></a>00861 <span class="comment">     * This greatly enhances sync speed for high latency network.</span>
<a name="l00862"></a>00862 <span class="comment">     * Windows by default use 8KB buffers, which is too small for such case.</span>
<a name="l00863"></a>00863 <span class="comment">     * Linux has auto-tuning for TCP buffers, so don&#39;t need to set manually.</span>
<a name="l00864"></a>00864 <span class="comment">     * OSX is TBD.</span>
<a name="l00865"></a>00865 <span class="comment">     */</span>
<a name="l00866"></a>00866 
<a name="l00867"></a>00867     <span class="comment">/* Set send buffer size. */</span>
<a name="l00868"></a>00868     <span class="keywordtype">int</span> sndbuf_size;
<a name="l00869"></a>00869     ev_socklen_t optlen = <span class="keyword">sizeof</span>(int);
<a name="l00870"></a>00870     getsockopt (data_fd, SOL_SOCKET, SO_SNDBUF, (<span class="keywordtype">char</span> *)&amp;sndbuf_size, &amp;optlen);
<a name="l00871"></a>00871 
<a name="l00872"></a>00872     <span class="keywordflow">if</span> (sndbuf_size &lt; <a class="code" href="blocktx-common-impl-v2_8h.html#a1c46953a017f054a3e69c50ff8c834a8">DEFAULT_SNDBUF_SIZE</a>) {
<a name="l00873"></a>00873         sndbuf_size = <a class="code" href="blocktx-common-impl-v2_8h.html#a1c46953a017f054a3e69c50ff8c834a8">DEFAULT_SNDBUF_SIZE</a>;
<a name="l00874"></a>00874         optlen = <span class="keyword">sizeof</span>(int);
<a name="l00875"></a>00875         setsockopt (data_fd, SOL_SOCKET, SO_SNDBUF, (<span class="keywordtype">char</span> *)&amp;sndbuf_size, optlen);
<a name="l00876"></a>00876     }
<a name="l00877"></a>00877 <span class="preprocessor">#endif</span>
<a name="l00878"></a>00878 <span class="preprocessor"></span>
<a name="l00879"></a>00879 <span class="preprocessor">#ifdef __APPLE__</span>
<a name="l00880"></a>00880 <span class="preprocessor"></span>    <span class="keywordflow">if</span> (sa-&gt;sa_family == AF_INET)
<a name="l00881"></a>00881         sa_len = <span class="keyword">sizeof</span>(<span class="keyword">struct </span>sockaddr_in);
<a name="l00882"></a>00882     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (sa-&gt;sa_family == PF_INET6)
<a name="l00883"></a>00883         sa_len = <span class="keyword">sizeof</span>(<span class="keyword">struct </span>sockaddr_in6);
<a name="l00884"></a>00884 <span class="preprocessor">#endif</span>
<a name="l00885"></a>00885 <span class="preprocessor"></span>
<a name="l00886"></a>00886     <span class="keywordflow">if</span> (connect(data_fd, sa, sa_len) &lt; 0) {
<a name="l00887"></a>00887         seaf_warning (<span class="stringliteral">&quot;connect error: %s\n&quot;</span>, strerror(errno));
<a name="l00888"></a>00888         evutil_closesocket (data_fd);
<a name="l00889"></a>00889         tdata-&gt;<a class="code" href="structThreadData.html#a2e8c4bf0bc10240ae1fa4db655356a7d">thread_ret</a> = -1;
<a name="l00890"></a>00890         <span class="keywordflow">goto</span> out;
<a name="l00891"></a>00891     }
<a name="l00892"></a>00892 
<a name="l00893"></a>00893     <span class="keywordtype">int</span> token_len = strlen(tdata-&gt;<a class="code" href="structThreadData.html#aefb5ab8272276bd942950a4780773cdf">token</a>) + 1;
<a name="l00894"></a>00894     <span class="keywordflow">if</span> (<a class="code" href="seafile-4_81_82_2lib_2utils_8c.html#aa324f32349cf5a256d5bd7802ab87e84">sendn</a> (data_fd, tdata-&gt;<a class="code" href="structThreadData.html#aefb5ab8272276bd942950a4780773cdf">token</a>, token_len) != token_len) {
<a name="l00895"></a>00895         seaf_warning (<span class="stringliteral">&quot;send connection token error: %s\n&quot;</span>, strerror(errno));
<a name="l00896"></a>00896         evutil_closesocket (data_fd);
<a name="l00897"></a>00897         tdata-&gt;<a class="code" href="structThreadData.html#a2e8c4bf0bc10240ae1fa4db655356a7d">thread_ret</a> = -1;
<a name="l00898"></a>00898         <span class="keywordflow">goto</span> out;
<a name="l00899"></a>00899     }
<a name="l00900"></a>00900 
<a name="l00901"></a>00901     tdata-&gt;<a class="code" href="structThreadData.html#af62c31466a162c9a0197778da78477ae">data_fd</a> = data_fd;
<a name="l00902"></a>00902 
<a name="l00903"></a>00903     <span class="comment">/* The client can send block requests now. */</span>
<a name="l00904"></a>00904     g_atomic_int_set (&amp;tdata-&gt;<a class="code" href="structThreadData.html#a3ff1006f44c3e35b2750f5e792751b99">state</a>, <a class="code" href="putblock-proc_8c.html#a61dadd085c1777f559549e05962b2c9ea6564f2f3e15be06b670547bbcaaf0798">READY</a>);
<a name="l00905"></a>00905 
<a name="l00906"></a>00906     tdata-&gt;<a class="code" href="structThreadData.html#a2e8c4bf0bc10240ae1fa4db655356a7d">thread_ret</a> = tdata-&gt;<a class="code" href="structThreadData.html#a2af444f30f1d00bd762fb2f5f2dd2930">transfer_func</a>(tdata);
<a name="l00907"></a>00907 
<a name="l00908"></a>00908     evutil_closesocket (tdata-&gt;<a class="code" href="structThreadData.html#af62c31466a162c9a0197778da78477ae">data_fd</a>);
<a name="l00909"></a>00909 
<a name="l00910"></a>00910 out:
<a name="l00911"></a>00911     <a class="code" href="seafile-4_81_82_2lib_2utils_8h.html#a597da6cd8fcd52017eb622068a9538dc">pipeclose</a> (tdata-&gt;<a class="code" href="structThreadData.html#a661392febd30e97efaa1ed18ce77f08a">task_pipe</a>[0]);
<a name="l00912"></a>00912     g_object_unref (peer);
<a name="l00913"></a>00913 
<a name="l00914"></a>00914     <span class="keywordflow">return</span> vtdata;
<a name="l00915"></a>00915 }
<a name="l00916"></a>00916 
<a name="l00917"></a>00917 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l00918"></a>00918 get_port (<a class="code" href="struct__CcnetProcessor.html">CcnetProcessor</a> *processor, <span class="keywordtype">char</span> *content, <span class="keywordtype">int</span> clen)
<a name="l00919"></a>00919 {
<a name="l00920"></a>00920     <a class="code" href="putblock-proc_8c.html#a52bd1fa7793027a7386a1b3d55b3bceb">USE_PRIV</a>;
<a name="l00921"></a>00921     <a class="code" href="structThreadData.html">ThreadData</a> *tdata = <a class="code" href="monitor-tool_8c.html#a694b59386a408403dbb70994ed5beaa1">priv</a>-&gt;tdata;
<a name="l00922"></a>00922     <span class="keywordtype">char</span> *p, *port_str, *token;
<a name="l00923"></a>00923     <a class="code" href="struct__CcnetPeer.html">CcnetPeer</a> *peer = NULL;
<a name="l00924"></a>00924 
<a name="l00925"></a>00925     <span class="keywordflow">if</span> (content[clen-1] != <span class="charliteral">&#39;\0&#39;</span>) {
<a name="l00926"></a>00926         seaf_warning (<span class="stringliteral">&quot;Bad port and token\n&quot;</span>);
<a name="l00927"></a>00927         <span class="keywordflow">goto</span> fail;
<a name="l00928"></a>00928     }
<a name="l00929"></a>00929 
<a name="l00930"></a>00930     p = strchr (content, <span class="charliteral">&#39;\t&#39;</span>);
<a name="l00931"></a>00931     <span class="keywordflow">if</span> (!p) {
<a name="l00932"></a>00932         seaf_warning (<span class="stringliteral">&quot;Bad port and token\n&quot;</span>);
<a name="l00933"></a>00933         <span class="keywordflow">goto</span> fail;
<a name="l00934"></a>00934     }
<a name="l00935"></a>00935 
<a name="l00936"></a>00936     *p = <span class="charliteral">&#39;\0&#39;</span>;
<a name="l00937"></a>00937     port_str = content; token = p + 1;
<a name="l00938"></a>00938 
<a name="l00939"></a>00939     peer = <a class="code" href="ccnet_8h.html#a136915227534e9204ffca3d7dc4d331e">ccnet_get_peer</a> (<a class="code" href="seaf-daemon_8c.html#ae66636d1834d105bd51d89ff01acfe15">seaf</a>-&gt;<a class="code" href="struct__SeafileSession.html#add541d96cca483ad72ff56ad061d1d32">ccnetrpc_client</a>, processor-&gt;<a class="code" href="struct__CcnetProcessor.html#ab9b1e96d5681f0880e23e66400effa50">peer_id</a>);
<a name="l00940"></a>00940     <span class="keywordflow">if</span> (!peer) {
<a name="l00941"></a>00941         seaf_warning (<span class="stringliteral">&quot;Invalid peer %s.\n&quot;</span>, processor-&gt;<a class="code" href="struct__CcnetProcessor.html#ab9b1e96d5681f0880e23e66400effa50">peer_id</a>);
<a name="l00942"></a>00942         <span class="keywordflow">goto</span> fail;
<a name="l00943"></a>00943     }
<a name="l00944"></a>00944     <span class="comment">/* Store peer address so that we don&#39;t need to call ccnet_get_peer()</span>
<a name="l00945"></a>00945 <span class="comment">     * in the worker thread later.</span>
<a name="l00946"></a>00946 <span class="comment">     */</span>
<a name="l00947"></a>00947     <span class="keywordflow">if</span> (<a class="code" href="seafile-4_81_82_2lib_2utils_8h.html#a316a8da8d8eac0625b051bf2155bdc58">ccnet_pipe</a> (tdata-&gt;<a class="code" href="structThreadData.html#a661392febd30e97efaa1ed18ce77f08a">task_pipe</a>) &lt; 0) {
<a name="l00948"></a>00948         seaf_warning (<span class="stringliteral">&quot;failed to create task pipe.\n&quot;</span>);
<a name="l00949"></a>00949         <span class="keywordflow">goto</span> fail;
<a name="l00950"></a>00950     }
<a name="l00951"></a>00951     
<a name="l00952"></a>00952     tdata-&gt;<a class="code" href="structThreadData.html#adfba38dfc5a126bf475273dd244848fd">port</a> = atoi (port_str);
<a name="l00953"></a>00953     tdata-&gt;<a class="code" href="structThreadData.html#aefb5ab8272276bd942950a4780773cdf">token</a> = g_strdup(token);
<a name="l00954"></a>00954     tdata-&gt;<a class="code" href="structThreadData.html#accb5430140f9b5b9139c395b7279c604">peer</a> = peer;
<a name="l00955"></a>00955 
<a name="l00956"></a>00956     <span class="keywordflow">if</span> (peer-&gt;<a class="code" href="struct__CcnetPeer.html#ab4c84a80901fa9548a2d188b51356e0e">encrypt_channel</a>)
<a name="l00957"></a>00957         generate_encrypt_key (tdata, peer);
<a name="l00958"></a>00958 
<a name="l00959"></a>00959     thread_data_ref (tdata);
<a name="l00960"></a>00960     <a class="code" href="job-mgr_8h.html#ac2bb163f21ddd6494f8d0101cc989768">ccnet_job_manager_schedule_job</a> (<a class="code" href="seaf-daemon_8c.html#ae66636d1834d105bd51d89ff01acfe15">seaf</a>-&gt;<a class="code" href="struct__SeafileSession.html#abcbb9886e315abb16c620ce49808a0b2">job_mgr</a>,
<a name="l00961"></a>00961                                     do_transfer,
<a name="l00962"></a>00962                                     thread_done,
<a name="l00963"></a>00963                                     tdata);
<a name="l00964"></a>00964 
<a name="l00965"></a>00965     <span class="keywordflow">return</span>;
<a name="l00966"></a>00966 
<a name="l00967"></a>00967 fail:
<a name="l00968"></a>00968     <span class="keywordflow">if</span> (peer)
<a name="l00969"></a>00969         g_object_unref (peer);
<a name="l00970"></a>00970     <a class="code" href="include_2ccnet_2processor_8h.html#a5358a9392f5e9235cec39e141fea81dc">ccnet_processor_send_update</a> (processor, <a class="code" href="status-code_8h.html#ab05019e3f22dd474823754a02576e258">SC_SHUTDOWN</a>, <a class="code" href="status-code_8h.html#a34269b8dfaf8666bbee7cef87fdf973b">SS_SHUTDOWN</a>,
<a name="l00971"></a>00971                                  NULL, 0);
<a name="l00972"></a>00972     <a class="code" href="include_2ccnet_2processor_8h.html#a562f3a09215f5220c957bc24d60f7929">ccnet_processor_done</a> (processor, FALSE);
<a name="l00973"></a>00973 }
<a name="l00974"></a>00974 
<a name="l00975"></a>00975 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l00976"></a>00976 send_block_list (<a class="code" href="struct__CcnetProcessor.html">CcnetProcessor</a> *processor)
<a name="l00977"></a>00977 {
<a name="l00978"></a>00978 <span class="preprocessor">#ifdef SENDBLOCK_PROC</span>
<a name="l00979"></a>00979 <span class="preprocessor"></span>    <a class="code" href="struct__SeafileSendblockV2Proc.html">SeafileSendblockV2Proc</a> *proc = (<a class="code" href="struct__SeafileSendblockV2Proc.html">SeafileSendblockV2Proc</a> *)processor;
<a name="l00980"></a>00980 <span class="preprocessor">#else</span>
<a name="l00981"></a>00981 <span class="preprocessor"></span>    <a class="code" href="struct__SeafileGetblockV2Proc.html">SeafileGetblockV2Proc</a> *proc = (<a class="code" href="struct__SeafileGetblockV2Proc.html">SeafileGetblockV2Proc</a> *)processor;
<a name="l00982"></a>00982 <span class="preprocessor">#endif</span>
<a name="l00983"></a>00983 <span class="preprocessor"></span>    <a class="code" href="structBlockList.html">BlockList</a> *bl = proc-&gt;<a class="code" href="struct__SeafileGetblockV2Proc.html#ab79ab6c43b483f63350d40f917251658">tx_task</a>-&gt;<a class="code" href="struct__TransferTask.html#a9baa45e64248034aa15eed4f2a57ff70">block_list</a>;
<a name="l00984"></a>00984     <span class="keywordtype">int</span> i, n = 0;
<a name="l00985"></a>00985     <span class="keywordtype">char</span> buf[<a class="code" href="blocktx-common-impl-v2_8h.html#a455b010f8eb4daaf25446b668dcde8a6">MAX_BL_LEN</a> * 41];
<a name="l00986"></a>00986     <span class="keywordtype">int</span> len = 0;
<a name="l00987"></a>00987 
<a name="l00988"></a>00988     <span class="keywordflow">for</span> (i = 0; i &lt; bl-&gt;<a class="code" href="structBlockList.html#a2ca09d61d434980fabd07ad6668ced3a">n_blocks</a>; ++i) {
<a name="l00989"></a>00989         memcpy (&amp;buf[len], g_ptr_array_index(bl-&gt;<a class="code" href="structBlockList.html#a11da65abdf8aff4a0161c28ded3ccaad">block_ids</a>, i), 41);
<a name="l00990"></a>00990         len += 41;
<a name="l00991"></a>00991 
<a name="l00992"></a>00992         <span class="keywordflow">if</span> (++n == <a class="code" href="blocktx-common-impl-v2_8h.html#a455b010f8eb4daaf25446b668dcde8a6">MAX_BL_LEN</a>) {
<a name="l00993"></a>00993             <a class="code" href="include_2ccnet_2processor_8h.html#a5358a9392f5e9235cec39e141fea81dc">ccnet_processor_send_update</a> (processor, <a class="code" href="blocktx-common-impl-v2_8h.html#aac96b613eae9d781c96a831650184da9">SC_BLOCKLIST</a>, <a class="code" href="blocktx-common-impl-v2_8h.html#a9604fd6d73c5d1a1ab626428d1ba56c5">SS_BLOCKLIST</a>,
<a name="l00994"></a>00994                                          (<span class="keywordtype">char</span> *)buf, len);
<a name="l00995"></a>00995             n = 0;
<a name="l00996"></a>00996             len = 0;
<a name="l00997"></a>00997         }
<a name="l00998"></a>00998     }
<a name="l00999"></a>00999 
<a name="l01000"></a>01000     <span class="keywordflow">if</span> (n != 0)
<a name="l01001"></a>01001         <a class="code" href="include_2ccnet_2processor_8h.html#a5358a9392f5e9235cec39e141fea81dc">ccnet_processor_send_update</a> (processor, <a class="code" href="blocktx-common-impl-v2_8h.html#aac96b613eae9d781c96a831650184da9">SC_BLOCKLIST</a>, <a class="code" href="blocktx-common-impl-v2_8h.html#a9604fd6d73c5d1a1ab626428d1ba56c5">SS_BLOCKLIST</a>,
<a name="l01002"></a>01002                                      (<span class="keywordtype">char</span> *)buf, len);
<a name="l01003"></a>01003 }
<a name="l01004"></a>01004 
<a name="l01005"></a>01005 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l01006"></a>01006 process_block_bitmap (<a class="code" href="struct__CcnetProcessor.html">CcnetProcessor</a> *processor, <span class="keywordtype">char</span> *content, <span class="keywordtype">int</span> clen)
<a name="l01007"></a>01007 {
<a name="l01008"></a>01008 <span class="preprocessor">#ifdef SENDBLOCK_PROC</span>
<a name="l01009"></a>01009 <span class="preprocessor"></span>    <a class="code" href="struct__SeafileSendblockV2Proc.html">SeafileSendblockV2Proc</a> *proc = (<a class="code" href="struct__SeafileSendblockV2Proc.html">SeafileSendblockV2Proc</a> *)processor;
<a name="l01010"></a>01010 <span class="preprocessor">#else</span>
<a name="l01011"></a>01011 <span class="preprocessor"></span>    <a class="code" href="struct__SeafileGetblockV2Proc.html">SeafileGetblockV2Proc</a> *proc = (<a class="code" href="struct__SeafileGetblockV2Proc.html">SeafileGetblockV2Proc</a> *)processor;
<a name="l01012"></a>01012 <span class="preprocessor">#endif</span>
<a name="l01013"></a>01013 <span class="preprocessor"></span>    <a class="code" href="putblock-proc_8c.html#a52bd1fa7793027a7386a1b3d55b3bceb">USE_PRIV</a>;
<a name="l01014"></a>01014 
<a name="l01015"></a>01015     <span class="keywordflow">if</span> (proc-&gt;<a class="code" href="struct__SeafileGetblockV2Proc.html#a0e0e29a567180fbddaaf49a1c384f77a">block_bitmap</a>.byteCount &lt; <a class="code" href="monitor-tool_8c.html#a694b59386a408403dbb70994ed5beaa1">priv</a>-&gt;bm_offset + clen) {
<a name="l01016"></a>01016         seaf_warning (<span class="stringliteral">&quot;Received block bitmap is too large.\n&quot;</span>);
<a name="l01017"></a>01017         <a class="code" href="include_2ccnet_2processor_8h.html#a5358a9392f5e9235cec39e141fea81dc">ccnet_processor_send_update</a> (processor, <a class="code" href="status-code_8h.html#ab05019e3f22dd474823754a02576e258">SC_SHUTDOWN</a>, <a class="code" href="status-code_8h.html#a34269b8dfaf8666bbee7cef87fdf973b">SS_SHUTDOWN</a>,
<a name="l01018"></a>01018                                      NULL, 0);
<a name="l01019"></a>01019         <a class="code" href="include_2ccnet_2processor_8h.html#a562f3a09215f5220c957bc24d60f7929">ccnet_processor_done</a> (processor, FALSE);
<a name="l01020"></a>01020         <span class="keywordflow">return</span> -1;
<a name="l01021"></a>01021     }
<a name="l01022"></a>01022     memcpy (proc-&gt;<a class="code" href="struct__SeafileGetblockV2Proc.html#a0e0e29a567180fbddaaf49a1c384f77a">block_bitmap</a>.bits + <a class="code" href="monitor-tool_8c.html#a694b59386a408403dbb70994ed5beaa1">priv</a>-&gt;bm_offset, content, clen);
<a name="l01023"></a>01023 
<a name="l01024"></a>01024     <a class="code" href="monitor-tool_8c.html#a694b59386a408403dbb70994ed5beaa1">priv</a>-&gt;bm_offset += clen;
<a name="l01025"></a>01025     <span class="keywordflow">if</span> (<a class="code" href="monitor-tool_8c.html#a694b59386a408403dbb70994ed5beaa1">priv</a>-&gt;bm_offset == proc-&gt;<a class="code" href="struct__SeafileGetblockV2Proc.html#a0e0e29a567180fbddaaf49a1c384f77a">block_bitmap</a>.byteCount) {
<a name="l01026"></a>01026 <span class="preprocessor">#ifdef SENDBLOCK_PROC</span>
<a name="l01027"></a>01027 <span class="preprocessor"></span>        <span class="comment">/* Update global uploaded bitmap. */</span>
<a name="l01028"></a>01028         BitfieldOr (&amp;proc-&gt;<a class="code" href="struct__SeafileGetblockV2Proc.html#ab79ab6c43b483f63350d40f917251658">tx_task</a>-&gt;uploaded, &amp;proc-&gt;<a class="code" href="struct__SeafileGetblockV2Proc.html#a0e0e29a567180fbddaaf49a1c384f77a">block_bitmap</a>);
<a name="l01029"></a>01029         proc-&gt;<a class="code" href="struct__SeafileGetblockV2Proc.html#ab79ab6c43b483f63350d40f917251658">tx_task</a>-&gt;<a class="code" href="struct__TransferTask.html#a18f81c0ae781b272104067d203f37e1d">n_uploaded</a> = BitfieldCountTrueBits (&amp;proc-&gt;<a class="code" href="struct__SeafileGetblockV2Proc.html#ab79ab6c43b483f63350d40f917251658">tx_task</a>-&gt;uploaded);
<a name="l01030"></a>01030 <span class="preprocessor">#endif</span>
<a name="l01031"></a>01031 <span class="preprocessor"></span>        <a class="code" href="include_2ccnet_2processor_8h.html#a5358a9392f5e9235cec39e141fea81dc">ccnet_processor_send_update</a> (processor, <a class="code" href="blocktx-common-impl-v2_8h.html#a363f56128af6e41c7980bd7b46fae7cf">SC_GET_PORT</a>, <a class="code" href="blocktx-common-impl-v2_8h.html#a5783dd77ead790f0d719da714c4f2576">SS_GET_PORT</a>,
<a name="l01032"></a>01032                                      NULL, 0);
<a name="l01033"></a>01033         <a class="code" href="monitor-tool_8c.html#a694b59386a408403dbb70994ed5beaa1">priv</a>-&gt;tdata-&gt;state = <a class="code" href="getblock-proc_8c.html#af9bdc3014f3d54c426b6d2df10de4960a6eb3dd47323441214246ed749be134ba">GET_PORT</a>;
<a name="l01034"></a>01034     }
<a name="l01035"></a>01035 
<a name="l01036"></a>01036     <span class="keywordflow">return</span> 0;
<a name="l01037"></a>01037 }
<a name="l01038"></a>01038 
<a name="l01039"></a>01039 <span class="preprocessor">#endif  </span><span class="comment">/* defined SENDBLOCK_PROC || GETBLOCK_PROC */</span>
<a name="l01040"></a>01040 
<a name="l01041"></a>01041 <span class="preprocessor">#if defined RECVBLOCK_PROC || defined PUTBLOCK_PROC</span>
<a name="l01042"></a>01042 <span class="preprocessor"></span>
<a name="l01043"></a>01043 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l01044"></a>01044 verify_session_token (<a class="code" href="struct__CcnetProcessor.html">CcnetProcessor</a> *processor, <span class="keywordtype">char</span> *ret_repo_id,
<a name="l01045"></a>01045                       <span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> **argv)
<a name="l01046"></a>01046 {
<a name="l01047"></a>01047     <span class="keywordflow">if</span> (argc != 1) {
<a name="l01048"></a>01048         <span class="keywordflow">return</span> -1;
<a name="l01049"></a>01049     }
<a name="l01050"></a>01050 
<a name="l01051"></a>01051     <span class="keywordtype">char</span> *session_token = argv[0];
<a name="l01052"></a>01052     <span class="keywordflow">if</span> (<a class="code" href="token-mgr_8c.html#a01dea9c27c5a8be4ff3e3964b30bda47">seaf_token_manager_verify_token</a> (<a class="code" href="seaf-daemon_8c.html#ae66636d1834d105bd51d89ff01acfe15">seaf</a>-&gt;<a class="code" href="struct__SeafileSession.html#a488687f0c6d0efb92e701a5bdc276886">token_mgr</a>,
<a name="l01053"></a>01053                                          NULL,
<a name="l01054"></a>01054                                          processor-&gt;<a class="code" href="struct__CcnetProcessor.html#ab9b1e96d5681f0880e23e66400effa50">peer_id</a>,
<a name="l01055"></a>01055                                          session_token, ret_repo_id) &lt; 0) {
<a name="l01056"></a>01056         <span class="keywordflow">return</span> -1;
<a name="l01057"></a>01057     }
<a name="l01058"></a>01058 
<a name="l01059"></a>01059     <span class="keywordflow">return</span> 0;
<a name="l01060"></a>01060 }
<a name="l01061"></a>01061 
<a name="l01062"></a>01062 
<a name="l01063"></a>01063 <span class="keyword">static</span> <span class="keywordtype">void</span>* do_passive_transfer(<span class="keywordtype">void</span> *vtdata)
<a name="l01064"></a>01064 {
<a name="l01065"></a>01065     <a class="code" href="structThreadData.html">ThreadData</a> *tdata = vtdata;
<a name="l01066"></a>01066 
<a name="l01067"></a>01067     tdata-&gt;<a class="code" href="structThreadData.html#a2e8c4bf0bc10240ae1fa4db655356a7d">thread_ret</a> = tdata-&gt;<a class="code" href="structThreadData.html#a2af444f30f1d00bd762fb2f5f2dd2930">transfer_func</a> (tdata);
<a name="l01068"></a>01068     
<a name="l01069"></a>01069     <a class="code" href="seafile-4_81_82_2lib_2utils_8h.html#a597da6cd8fcd52017eb622068a9538dc">pipeclose</a> (tdata-&gt;<a class="code" href="structThreadData.html#a661392febd30e97efaa1ed18ce77f08a">task_pipe</a>[0]);
<a name="l01070"></a>01070     evutil_closesocket (tdata-&gt;<a class="code" href="structThreadData.html#af62c31466a162c9a0197778da78477ae">data_fd</a>);
<a name="l01071"></a>01071     
<a name="l01072"></a>01072     <span class="keywordflow">return</span> vtdata;
<a name="l01073"></a>01073 }
<a name="l01074"></a>01074 
<a name="l01075"></a>01075 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l01076"></a>01076 accept_connection (evutil_socket_t connfd, <span class="keywordtype">void</span> *vdata)
<a name="l01077"></a>01077 {
<a name="l01078"></a>01078     <a class="code" href="structThreadData.html">ThreadData</a> *tdata = vdata;
<a name="l01079"></a>01079     <a class="code" href="struct__CcnetProcessor.html">CcnetProcessor</a> *processor;
<a name="l01080"></a>01080     <a class="code" href="struct__CcnetPeer.html">CcnetPeer</a> *peer = NULL;
<a name="l01081"></a>01081 
<a name="l01082"></a>01082     <span class="comment">/* </span>
<a name="l01083"></a>01083 <span class="comment">     * The processor may have been shutdown since accept_connection()</span>
<a name="l01084"></a>01084 <span class="comment">     * is run outside of the processor&#39;s context.</span>
<a name="l01085"></a>01085 <span class="comment">     */</span>
<a name="l01086"></a>01086     <span class="keywordflow">if</span> (tdata-&gt;<a class="code" href="structThreadData.html#a02d6dca5e8a071c080b95299e9cc54af">processor_done</a>) {
<a name="l01087"></a>01087         thread_data_unref (tdata);
<a name="l01088"></a>01088         <span class="keywordflow">if</span> (connfd &gt;= 0)
<a name="l01089"></a>01089             evutil_closesocket (connfd);
<a name="l01090"></a>01090         <span class="keywordflow">return</span>;
<a name="l01091"></a>01091     }
<a name="l01092"></a>01092 
<a name="l01093"></a>01093     processor = tdata-&gt;<a class="code" href="structThreadData.html#a4d788ba804c065e35978c0a8d2d88daa">processor</a>;
<a name="l01094"></a>01094 
<a name="l01095"></a>01095     <span class="keywordflow">if</span> (connfd &lt; 0)
<a name="l01096"></a>01096         <span class="keywordflow">goto</span> fail;
<a name="l01097"></a>01097 
<a name="l01098"></a>01098     peer = <a class="code" href="ccnet_8h.html#a136915227534e9204ffca3d7dc4d331e">ccnet_get_peer</a> (<a class="code" href="seaf-daemon_8c.html#ae66636d1834d105bd51d89ff01acfe15">seaf</a>-&gt;<a class="code" href="struct__SeafileSession.html#add541d96cca483ad72ff56ad061d1d32">ccnetrpc_client</a>, processor-&gt;<a class="code" href="struct__CcnetProcessor.html#ab9b1e96d5681f0880e23e66400effa50">peer_id</a>);
<a name="l01099"></a>01099     <span class="keywordflow">if</span> (!peer) {
<a name="l01100"></a>01100         seaf_warning (<span class="stringliteral">&quot;Invalid peer %s.\n&quot;</span>, processor-&gt;<a class="code" href="struct__CcnetProcessor.html#ab9b1e96d5681f0880e23e66400effa50">peer_id</a>);
<a name="l01101"></a>01101         evutil_closesocket (tdata-&gt;<a class="code" href="structThreadData.html#af62c31466a162c9a0197778da78477ae">data_fd</a>);
<a name="l01102"></a>01102         <span class="keywordflow">goto</span> fail;
<a name="l01103"></a>01103     }
<a name="l01104"></a>01104 
<a name="l01105"></a>01105     tdata-&gt;<a class="code" href="structThreadData.html#af62c31466a162c9a0197778da78477ae">data_fd</a> = connfd;
<a name="l01106"></a>01106 
<a name="l01107"></a>01107     <span class="comment">/* Start to accept block requests from the client */</span>
<a name="l01108"></a>01108     tdata-&gt;<a class="code" href="structThreadData.html#a3ff1006f44c3e35b2750f5e792751b99">state</a> = <a class="code" href="putblock-proc_8c.html#a61dadd085c1777f559549e05962b2c9ea6564f2f3e15be06b670547bbcaaf0798">READY</a>;
<a name="l01109"></a>01109 
<a name="l01110"></a>01110     <span class="keywordflow">if</span> (<a class="code" href="seafile-4_81_82_2lib_2utils_8h.html#a316a8da8d8eac0625b051bf2155bdc58">ccnet_pipe</a> (tdata-&gt;<a class="code" href="structThreadData.html#a661392febd30e97efaa1ed18ce77f08a">task_pipe</a>) &lt; 0) {
<a name="l01111"></a>01111         seaf_warning (<span class="stringliteral">&quot;failed to create task pipe.\n&quot;</span>);
<a name="l01112"></a>01112         evutil_closesocket (tdata-&gt;<a class="code" href="structThreadData.html#af62c31466a162c9a0197778da78477ae">data_fd</a>);
<a name="l01113"></a>01113         <span class="keywordflow">goto</span> fail;
<a name="l01114"></a>01114     }
<a name="l01115"></a>01115 
<a name="l01116"></a>01116     <span class="keywordflow">if</span> (peer-&gt;<a class="code" href="struct__CcnetPeer.html#ab4c84a80901fa9548a2d188b51356e0e">encrypt_channel</a>)
<a name="l01117"></a>01117         generate_encrypt_key (tdata, peer);
<a name="l01118"></a>01118     g_object_unref (peer);
<a name="l01119"></a>01119 
<a name="l01120"></a>01120     <span class="comment">/* Don&#39;t need to ref thread data again. We&#39;re already holding one.</span>
<a name="l01121"></a>01121 <span class="comment">     */</span>
<a name="l01122"></a>01122     <a class="code" href="job-mgr_8h.html#ac2bb163f21ddd6494f8d0101cc989768">ccnet_job_manager_schedule_job</a> (<a class="code" href="seaf-daemon_8c.html#ae66636d1834d105bd51d89ff01acfe15">seaf</a>-&gt;<a class="code" href="struct__SeafileSession.html#abcbb9886e315abb16c620ce49808a0b2">job_mgr</a>,
<a name="l01123"></a>01123                                     do_passive_transfer,
<a name="l01124"></a>01124                                     thread_done,
<a name="l01125"></a>01125                                     tdata);
<a name="l01126"></a>01126     <span class="keywordflow">return</span>;
<a name="l01127"></a>01127 
<a name="l01128"></a>01128 fail:
<a name="l01129"></a>01129     <span class="keywordflow">if</span> (peer)
<a name="l01130"></a>01130         g_object_unref (peer);
<a name="l01131"></a>01131     <a class="code" href="include_2ccnet_2processor_8h.html#a990a7c85ac8c9b5cb020391b10affe82">ccnet_processor_send_response</a> (processor, <a class="code" href="status-code_8h.html#ab05019e3f22dd474823754a02576e258">SC_SHUTDOWN</a>, <a class="code" href="status-code_8h.html#a34269b8dfaf8666bbee7cef87fdf973b">SS_SHUTDOWN</a>,
<a name="l01132"></a>01132                                    NULL, 0);
<a name="l01133"></a>01133     <a class="code" href="include_2ccnet_2processor_8h.html#a562f3a09215f5220c957bc24d60f7929">ccnet_processor_done</a> (processor, FALSE);
<a name="l01134"></a>01134     thread_data_unref (tdata);
<a name="l01135"></a>01135 }
<a name="l01136"></a>01136 
<a name="l01137"></a>01137 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l01138"></a>01138 send_port (<a class="code" href="struct__CcnetProcessor.html">CcnetProcessor</a> *processor)
<a name="l01139"></a>01139 {
<a name="l01140"></a>01140     <a class="code" href="putblock-proc_8c.html#a52bd1fa7793027a7386a1b3d55b3bceb">USE_PRIV</a>;
<a name="l01141"></a>01141     <span class="keywordtype">char</span> buf[256];
<a name="l01142"></a>01142     <span class="keywordtype">char</span> *token = NULL;
<a name="l01143"></a>01143     <span class="keywordtype">int</span> len;
<a name="l01144"></a>01144 
<a name="l01145"></a>01145     token = <a class="code" href="listen-mgr_8c.html#a1bab146578319d15c8a24e74593f1245">seaf_listen_manager_generate_token</a> (<a class="code" href="seaf-daemon_8c.html#ae66636d1834d105bd51d89ff01acfe15">seaf</a>-&gt;<a class="code" href="struct__SeafileSession.html#a956cb7b17169bd6f62ee0c5c6e90175c">listen_mgr</a>);
<a name="l01146"></a>01146     <span class="keywordflow">if</span> (<a class="code" href="listen-mgr_8c.html#afdc648d41fae1976ac451b8f89c0dbbf">seaf_listen_manager_register_token</a> (<a class="code" href="seaf-daemon_8c.html#ae66636d1834d105bd51d89ff01acfe15">seaf</a>-&gt;<a class="code" href="struct__SeafileSession.html#a956cb7b17169bd6f62ee0c5c6e90175c">listen_mgr</a>, token,
<a name="l01147"></a>01147                         (<a class="code" href="listen-mgr_8h.html#a7939b62a4be182d32e6946fcb57f31ca">ConnAcceptedCB</a>)accept_connection,
<a name="l01148"></a>01148                         <a class="code" href="monitor-tool_8c.html#a694b59386a408403dbb70994ed5beaa1">priv</a>-&gt;tdata, <a class="code" href="blocktx-common-impl-v2_8h.html#ac59acf70f92ce9820ee44a1e6ed09f61">TOKEN_TIMEOUT</a>) &lt; 0) {
<a name="l01149"></a>01149         seaf_warning (<span class="stringliteral">&quot;failed to register token\n&quot;</span>);
<a name="l01150"></a>01150         g_free (token);
<a name="l01151"></a>01151         <a class="code" href="include_2ccnet_2processor_8h.html#a990a7c85ac8c9b5cb020391b10affe82">ccnet_processor_send_response</a> (processor, <a class="code" href="status-code_8h.html#ab05019e3f22dd474823754a02576e258">SC_SHUTDOWN</a>, <a class="code" href="status-code_8h.html#a34269b8dfaf8666bbee7cef87fdf973b">SS_SHUTDOWN</a>,
<a name="l01152"></a>01152                                        NULL, 0);
<a name="l01153"></a>01153         <a class="code" href="include_2ccnet_2processor_8h.html#a562f3a09215f5220c957bc24d60f7929">ccnet_processor_done</a> (processor, FALSE);
<a name="l01154"></a>01154     }
<a name="l01155"></a>01155 
<a name="l01156"></a>01156     <span class="comment">/* We&#39;re leaving processor context, make sure tdata is still available</span>
<a name="l01157"></a>01157 <span class="comment">     * when the callback is run.</span>
<a name="l01158"></a>01158 <span class="comment">     */</span>
<a name="l01159"></a>01159     thread_data_ref (<a class="code" href="monitor-tool_8c.html#a694b59386a408403dbb70994ed5beaa1">priv</a>-&gt;tdata);
<a name="l01160"></a>01160 
<a name="l01161"></a>01161     len = snprintf (buf, <span class="keyword">sizeof</span>(buf), <span class="stringliteral">&quot;%d\t%s&quot;</span>, <a class="code" href="seaf-daemon_8c.html#ae66636d1834d105bd51d89ff01acfe15">seaf</a>-&gt;<a class="code" href="struct__SeafileSession.html#a956cb7b17169bd6f62ee0c5c6e90175c">listen_mgr</a>-&gt;<a class="code" href="struct__SeafListenManager.html#a5784b3c3ee3d13e706150b287d827ccc">port</a>, token);
<a name="l01162"></a>01162     <a class="code" href="include_2ccnet_2processor_8h.html#a990a7c85ac8c9b5cb020391b10affe82">ccnet_processor_send_response</a> (processor,
<a name="l01163"></a>01163                                    <a class="code" href="blocktx-common-impl-v2_8h.html#a69df665dae8be77f3fceff8d0eaf6cf8">SC_SEND_PORT</a>, <a class="code" href="blocktx-common-impl-v2_8h.html#a5d7c6432dc3c709a8b503e7ce446c5d2">SS_SEND_PORT</a>,
<a name="l01164"></a>01164                                    buf, len+1);
<a name="l01165"></a>01165 
<a name="l01166"></a>01166     g_free (token);
<a name="l01167"></a>01167 }
<a name="l01168"></a>01168 
<a name="l01169"></a>01169 <span class="preprocessor">#ifdef RECVBLOCK_PROC</span>
<a name="l01170"></a>01170 <span class="preprocessor"></span><span class="keyword">static</span> <span class="keywordtype">void</span> *
<a name="l01171"></a>01171 check_block_list (<span class="keywordtype">void</span> *vtdata)
<a name="l01172"></a>01172 {
<a name="l01173"></a>01173     <a class="code" href="structThreadData.html">ThreadData</a> *tdata = vtdata;
<a name="l01174"></a>01174     <span class="keywordtype">char</span> *block_list = tdata-&gt;<a class="code" href="structThreadData.html#ab48b75c727949f8d231096df1eea82a3">blinfo</a>-&gt;<a class="code" href="structBLInfo.html#ad4796950d31aa956f57cebc6f9c095fa">block_list</a>;
<a name="l01175"></a>01175     <span class="keywordtype">int</span> n_blocks = tdata-&gt;<a class="code" href="structThreadData.html#ab48b75c727949f8d231096df1eea82a3">blinfo</a>-&gt;<a class="code" href="structBLInfo.html#ac5dd9911ffc9cf662ce7d1a8ff730266">n_blocks</a>;
<a name="l01176"></a>01176     <span class="keywordtype">char</span> *<a class="code" href="block-tx-utils_8h.html#a2d616e1f81d11995c8b388444be651ef">block_id</a>;
<a name="l01177"></a>01177     <span class="keywordtype">int</span> i;
<a name="l01178"></a>01178 
<a name="l01179"></a>01179     BitfieldConstruct (&amp;tdata-&gt;<a class="code" href="structThreadData.html#aa4dbcc457646e548e7fa2a7abf574ddf">bitmap</a>, n_blocks);
<a name="l01180"></a>01180 
<a name="l01181"></a>01181     block_id = block_list;
<a name="l01182"></a>01182     <span class="keywordflow">for</span> (i = 0; i &lt; n_blocks; ++i) {
<a name="l01183"></a>01183         block_id[40] = <span class="charliteral">&#39;\0&#39;</span>;
<a name="l01184"></a>01184         <span class="keywordflow">if</span> (<a class="code" href="block-mgr_8c.html#acc8d899bbbf17d0db6d07c9eda67fd0c">seaf_block_manager_block_exists</a>(<a class="code" href="seaf-daemon_8c.html#ae66636d1834d105bd51d89ff01acfe15">seaf</a>-&gt;<a class="code" href="struct__SeafileSession.html#a4b29afaa0ca920084596a236c8460df2">block_mgr</a>, block_id))
<a name="l01185"></a>01185             BitfieldAdd (&amp;tdata-&gt;<a class="code" href="structThreadData.html#aa4dbcc457646e548e7fa2a7abf574ddf">bitmap</a>, i);
<a name="l01186"></a>01186         block_id += 41;
<a name="l01187"></a>01187     }
<a name="l01188"></a>01188 
<a name="l01189"></a>01189     g_free (tdata-&gt;<a class="code" href="structThreadData.html#ab48b75c727949f8d231096df1eea82a3">blinfo</a>-&gt;<a class="code" href="structBLInfo.html#ad4796950d31aa956f57cebc6f9c095fa">block_list</a>);
<a name="l01190"></a>01190     g_free (tdata-&gt;<a class="code" href="structThreadData.html#ab48b75c727949f8d231096df1eea82a3">blinfo</a>);
<a name="l01191"></a>01191 
<a name="l01192"></a>01192     <span class="keywordflow">return</span> vtdata;
<a name="l01193"></a>01193 }
<a name="l01194"></a>01194 
<a name="l01195"></a>01195 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l01196"></a>01196 check_block_list_done (<span class="keywordtype">void</span> *vtdata)
<a name="l01197"></a>01197 {
<a name="l01198"></a>01198     <a class="code" href="structThreadData.html">ThreadData</a> *tdata = vtdata;
<a name="l01199"></a>01199     Bitfield *pbitmap = &amp;tdata-&gt;<a class="code" href="structThreadData.html#aa4dbcc457646e548e7fa2a7abf574ddf">bitmap</a>;
<a name="l01200"></a>01200 
<a name="l01201"></a>01201     tdata-&gt;<a class="code" href="structThreadData.html#af9b1f92f18c54fab940148136003317e">checking_bl</a> = FALSE;
<a name="l01202"></a>01202 
<a name="l01203"></a>01203     <span class="keywordflow">if</span> (tdata-&gt;<a class="code" href="structThreadData.html#a02d6dca5e8a071c080b95299e9cc54af">processor_done</a>) {
<a name="l01204"></a>01204         BitfieldDestruct (pbitmap);
<a name="l01205"></a>01205         thread_data_unref (tdata);
<a name="l01206"></a>01206         <span class="keywordflow">return</span>;
<a name="l01207"></a>01207     }
<a name="l01208"></a>01208 
<a name="l01209"></a>01209     <a class="code" href="include_2ccnet_2processor_8h.html#a990a7c85ac8c9b5cb020391b10affe82">ccnet_processor_send_response</a> (tdata-&gt;<a class="code" href="structThreadData.html#a4d788ba804c065e35978c0a8d2d88daa">processor</a>, <a class="code" href="blocktx-common-impl-v2_8h.html#a1e76bf080b96abf54e0b329e1b454b80">SC_BBITMAP</a>, <a class="code" href="blocktx-common-impl-v2_8h.html#ab4442994005daa15a90ae1bbe9b99b3c">SS_BBITMAP</a>,
<a name="l01210"></a>01210                                    (<span class="keywordtype">char</span> *)(pbitmap-&gt;bits), pbitmap-&gt;byteCount);
<a name="l01211"></a>01211     BitfieldDestruct (pbitmap);
<a name="l01212"></a>01212 
<a name="l01213"></a>01213     <span class="comment">/* Process next block list segment, or exit. */</span>
<a name="l01214"></a>01214     <span class="keywordflow">if</span> (tdata-&gt;<a class="code" href="structThreadData.html#aee2731427928b31eab553cbc1b5e2c72">bl_queue</a> != NULL) {
<a name="l01215"></a>01215         <a class="code" href="structBLInfo.html">BLInfo</a> *blinfo = g_queue_pop_head (tdata-&gt;<a class="code" href="structThreadData.html#aee2731427928b31eab553cbc1b5e2c72">bl_queue</a>);
<a name="l01216"></a>01216         <span class="keywordflow">if</span> (blinfo != NULL) {
<a name="l01217"></a>01217             tdata-&gt;<a class="code" href="structThreadData.html#af9b1f92f18c54fab940148136003317e">checking_bl</a> = TRUE;
<a name="l01218"></a>01218             tdata-&gt;<a class="code" href="structThreadData.html#ab48b75c727949f8d231096df1eea82a3">blinfo</a> = blinfo;
<a name="l01219"></a>01219             thread_data_ref (tdata);
<a name="l01220"></a>01220             <a class="code" href="job-mgr_8h.html#ac2bb163f21ddd6494f8d0101cc989768">ccnet_job_manager_schedule_job</a> (<a class="code" href="seaf-daemon_8c.html#ae66636d1834d105bd51d89ff01acfe15">seaf</a>-&gt;<a class="code" href="struct__SeafileSession.html#abcbb9886e315abb16c620ce49808a0b2">job_mgr</a>,
<a name="l01221"></a>01221                                             check_block_list,
<a name="l01222"></a>01222                                             check_block_list_done,
<a name="l01223"></a>01223                                             tdata);
<a name="l01224"></a>01224         }
<a name="l01225"></a>01225     }
<a name="l01226"></a>01226 
<a name="l01227"></a>01227     thread_data_unref (tdata);
<a name="l01228"></a>01228 }
<a name="l01229"></a>01229 <span class="preprocessor">#endif  </span><span class="comment">/* RECVBLOCK_PROC */</span>
<a name="l01230"></a>01230 
<a name="l01231"></a>01231 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l01232"></a>01232 process_block_list (<a class="code" href="struct__CcnetProcessor.html">CcnetProcessor</a> *processor, <span class="keywordtype">char</span> *content, <span class="keywordtype">int</span> clen)
<a name="l01233"></a>01233 {
<a name="l01234"></a>01234     <span class="keywordtype">int</span> n_blocks;
<a name="l01235"></a>01235 
<a name="l01236"></a>01236     <span class="keywordflow">if</span> (clen % 41 != 0) {
<a name="l01237"></a>01237         seaf_warning (<span class="stringliteral">&quot;Bad block list.\n&quot;</span>);
<a name="l01238"></a>01238         <a class="code" href="include_2ccnet_2processor_8h.html#a990a7c85ac8c9b5cb020391b10affe82">ccnet_processor_send_response</a> (processor, <a class="code" href="blocktx-common-impl-v2_8h.html#ae6e5353da95fe7379aced8dd7395aafd">SC_BAD_BL</a>, <a class="code" href="blocktx-common-impl-v2_8h.html#aaa37f98a5ba3ee19a308d125ba4c7499">SS_BAD_BL</a>, NULL, 0);
<a name="l01239"></a>01239         <a class="code" href="include_2ccnet_2processor_8h.html#a562f3a09215f5220c957bc24d60f7929">ccnet_processor_done</a> (processor, FALSE);
<a name="l01240"></a>01240         <span class="keywordflow">return</span>;
<a name="l01241"></a>01241     }
<a name="l01242"></a>01242     n_blocks = clen/41;
<a name="l01243"></a>01243 
<a name="l01244"></a>01244 <span class="preprocessor">#ifdef PUTBLOCK_PROC</span>
<a name="l01245"></a>01245 <span class="preprocessor"></span>    Bitfield bitmap;
<a name="l01246"></a>01246 
<a name="l01247"></a>01247     <span class="comment">/* If it&#39;s a download, we can assume all the blocks are present</span>
<a name="l01248"></a>01248 <span class="comment">     * on the server. So no need to check.</span>
<a name="l01249"></a>01249 <span class="comment">     */</span>
<a name="l01250"></a>01250     BitfieldConstruct (&amp;bitmap, n_blocks);
<a name="l01251"></a>01251 
<a name="l01252"></a>01252     BitfieldAddRange (&amp;bitmap, 0, n_blocks);
<a name="l01253"></a>01253     <a class="code" href="include_2ccnet_2processor_8h.html#a990a7c85ac8c9b5cb020391b10affe82">ccnet_processor_send_response</a> (processor, <a class="code" href="blocktx-common-impl-v2_8h.html#a1e76bf080b96abf54e0b329e1b454b80">SC_BBITMAP</a>, <a class="code" href="blocktx-common-impl-v2_8h.html#ab4442994005daa15a90ae1bbe9b99b3c">SS_BBITMAP</a>,
<a name="l01254"></a>01254                                    (<span class="keywordtype">char</span> *)(bitmap.bits), bitmap.byteCount);
<a name="l01255"></a>01255     BitfieldDestruct (&amp;bitmap);
<a name="l01256"></a>01256 <span class="preprocessor">#endif</span>
<a name="l01257"></a>01257 <span class="preprocessor"></span>
<a name="l01258"></a>01258 <span class="preprocessor">#ifdef RECVBLOCK_PROC</span>
<a name="l01259"></a>01259 <span class="preprocessor"></span>    <a class="code" href="putblock-proc_8c.html#a52bd1fa7793027a7386a1b3d55b3bceb">USE_PRIV</a>;
<a name="l01260"></a>01260     <a class="code" href="structThreadData.html">ThreadData</a> *tdata = <a class="code" href="monitor-tool_8c.html#a694b59386a408403dbb70994ed5beaa1">priv</a>-&gt;tdata;
<a name="l01261"></a>01261     <a class="code" href="structBLInfo.html">BLInfo</a> *blinfo;
<a name="l01262"></a>01262 
<a name="l01263"></a>01263     <span class="comment">/* If a worker thread is already running, push this block list to queue.</span>
<a name="l01264"></a>01264 <span class="comment">     * It will be processed after the worker thread finishes the current one.</span>
<a name="l01265"></a>01265 <span class="comment">     * Otherwise start a new worker thread.</span>
<a name="l01266"></a>01266 <span class="comment">     */</span>
<a name="l01267"></a>01267     blinfo = g_new0 (<a class="code" href="structBLInfo.html">BLInfo</a>, 1);
<a name="l01268"></a>01268     blinfo-&gt;<a class="code" href="structBLInfo.html#ad4796950d31aa956f57cebc6f9c095fa">block_list</a> = g_memdup (content, clen);
<a name="l01269"></a>01269     blinfo-&gt;<a class="code" href="structBLInfo.html#ac5dd9911ffc9cf662ce7d1a8ff730266">n_blocks</a> = n_blocks;
<a name="l01270"></a>01270 
<a name="l01271"></a>01271     <span class="keywordflow">if</span> (!tdata-&gt;<a class="code" href="structThreadData.html#af9b1f92f18c54fab940148136003317e">checking_bl</a>) {
<a name="l01272"></a>01272         tdata-&gt;<a class="code" href="structThreadData.html#af9b1f92f18c54fab940148136003317e">checking_bl</a> = TRUE;
<a name="l01273"></a>01273         tdata-&gt;<a class="code" href="structThreadData.html#ab48b75c727949f8d231096df1eea82a3">blinfo</a> = blinfo;
<a name="l01274"></a>01274         thread_data_ref (tdata);
<a name="l01275"></a>01275         <a class="code" href="job-mgr_8h.html#ac2bb163f21ddd6494f8d0101cc989768">ccnet_job_manager_schedule_job</a> (<a class="code" href="seaf-daemon_8c.html#ae66636d1834d105bd51d89ff01acfe15">seaf</a>-&gt;<a class="code" href="struct__SeafileSession.html#abcbb9886e315abb16c620ce49808a0b2">job_mgr</a>,
<a name="l01276"></a>01276                                         check_block_list,
<a name="l01277"></a>01277                                         check_block_list_done,
<a name="l01278"></a>01278                                         tdata);
<a name="l01279"></a>01279     } <span class="keywordflow">else</span> {
<a name="l01280"></a>01280         <span class="keywordflow">if</span> (!tdata-&gt;<a class="code" href="structThreadData.html#aee2731427928b31eab553cbc1b5e2c72">bl_queue</a>)
<a name="l01281"></a>01281             tdata-&gt;<a class="code" href="structThreadData.html#aee2731427928b31eab553cbc1b5e2c72">bl_queue</a> = g_queue_new ();
<a name="l01282"></a>01282         g_queue_push_tail (tdata-&gt;<a class="code" href="structThreadData.html#aee2731427928b31eab553cbc1b5e2c72">bl_queue</a>, blinfo);
<a name="l01283"></a>01283     }
<a name="l01284"></a>01284 <span class="preprocessor">#endif</span>
<a name="l01285"></a>01285 <span class="preprocessor"></span>}
<a name="l01286"></a>01286 
<a name="l01287"></a>01287 <span class="preprocessor">#endif  </span><span class="comment">/* defined RECVBLOCK_PROC || defined PUTBLOCK_PROC */</span>
<a name="l01288"></a>01288 
<a name="l01289"></a>01289 <span class="preprocessor">#endif  </span><span class="comment">/* BLOCKTX_COMMON_IMPL_V2_H */</span>
</pre></div></div><!-- contents -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>



<hr class="footer"/><address class="footer"><small>
Generated on Wed Aug 19 2015 03:59:41 for My Project by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.7.6.1
</small></address>

</body>
</html>
